// ==UserScript==
// @name         MGTools
// @namespace    http://tampermonkey.net/
// @version      3.6.8
// @description  All-in-one assistant for Magic Garden with beautiful unified UI (Enhanced Discord Support!)
// @author       Unified Script
// @updateURL    https://github.com/Myke247/MGTools/raw/refs/heads/Live-Beta/MGTools.user.js
// @downloadURL  https://github.com/Myke247/MGTools/raw/refs/heads/Live-Beta/MGTools.user.js
// @match        https://magiccircle.gg/r/*
// @match        https://magicgarden.gg/r/*
// @match        https://starweaver.org/r/*
// @match        https://*.discordsays.com/*
// @match        https://1227719606223765687.discordsays.com/*
// @grant        GM_setValue
// @grant        GM_getValue
// @grant        GM_addStyle
// @grant        GM_addElement
// @grant        unsafeWindow
// @grant        GM_xmlhttpRequest
// @connect      raw.githubusercontent.com
// @connect      *
// @inject-into  page
// @run-at       document-start
// ==/UserScript==

// === CSP Guard: Disable external Google Fonts in Discord/webview ===
(function(){
    try {
      const isDiscord = /discord|overlay|electron/i.test(navigator.userAgent) || (window.DiscordNative || window.__discordApp);
      if (isDiscord) {
        console.log('üõ°Ô∏è [CSP] External font loads disabled in Discord context.');
      }
      const origCreateElement = Document.prototype.createElement;
      Document.prototype.createElement = function(tag){
        const el = origCreateElement.call(this, tag);
        try {
          if (isDiscord && tag && tag.toLowerCase() === 'link') {
            const origSetAttribute = el.setAttribute;
            el.setAttribute = function(name, value){
              if (name === 'href' && typeof value === 'string' && /fonts\.googleapis/i.test(value)) {
                console.log('üõ°Ô∏è [CSP] Prevented external font link injection:', value);
                return;
              }
              return origSetAttribute.apply(this, arguments);
            };
          }
        } catch(_){}
        return el;
      };
    } catch(_){}
  })();
  
  (function() {
      'use strict';

      // ==================== SAFE LOCALSTORAGE WRAPPER ====================
      // Discord iframes don't have localStorage access, so we need a fallback
      const safeStorage = (() => {
          const memoryStore = {};
          let nativeLocalStorage;
          let isLocalStorageAvailable = false;

          // Try to access native localStorage
          try {
              if (window.localStorage && typeof window.localStorage !== 'undefined') {
                  nativeLocalStorage = window.localStorage;
                  const test = '__localStorage_test__';
                  nativeLocalStorage.setItem(test, test);
                  nativeLocalStorage.removeItem(test);
                  isLocalStorageAvailable = true;
                  console.log('‚úÖ [STORAGE] Direct localStorage access available');
              } else {
                  // localStorage is undefined or deleted (Discord scenario)
                  throw new Error('localStorage undefined');
              }
          } catch (e) {
              console.warn('[MGTools] Direct localStorage blocked, trying iframe workaround...');

              // Discord Fix: Try iframe workaround for localStorage access
              // Discord deletes window.localStorage but the object itself still exists
              // A fresh iframe contentWindow has untouched localStorage property
              try {
                  const iframe = document.createElement('iframe');
                  iframe.style.display = 'none';
                  iframe.style.position = 'absolute';
                  iframe.style.width = '0';
                  iframe.style.height = '0';

                  // Wait for body to exist in Discord
                  if (!document.body) {
                      console.warn('[MGTools] document.body not ready, waiting...');
                      // Use a different approach - create iframe without body
                      document.documentElement.appendChild(iframe);
                  } else {
                      document.body.appendChild(iframe);
                  }

                  const iframeStorage = iframe.contentWindow.localStorage;

                  // Test if it works
                  const test = '__mgtools_iframe_test__';
                  iframeStorage.setItem(test, test);
                  iframeStorage.removeItem(test);

                  nativeLocalStorage = iframeStorage;
                  isLocalStorageAvailable = true;
                  console.log('‚úÖ [STORAGE] Iframe localStorage workaround successful (Discord mode)');

                  // Keep iframe for localStorage access
              } catch (iframeError) {
                  console.warn('[MGTools] Iframe localStorage workaround failed, using memory fallback:', iframeError.message);
                  isLocalStorageAvailable = false;
              }
          }

          return {
              getItem: (key) => {
                  if (isLocalStorageAvailable) {
                      return nativeLocalStorage.getItem(key);
                  }
                  return memoryStore[key] || null;
              },
              setItem: (key, value) => {
                  if (isLocalStorageAvailable) {
                      nativeLocalStorage.setItem(key, value);
                  } else {
                      memoryStore[key] = String(value);
                  }
              },
              removeItem: (key) => {
                  if (isLocalStorageAvailable) {
                      nativeLocalStorage.removeItem(key);
                  } else {
                      delete memoryStore[key];
                  }
              },
              get length() {
                  if (isLocalStorageAvailable) {
                      return nativeLocalStorage.length;
                  }
                  return Object.keys(memoryStore).length;
              },
              key: (index) => {
                  if (isLocalStorageAvailable) {
                      return nativeLocalStorage.key(index);
                  }
                  return Object.keys(memoryStore)[index] || null;
              }
          };
      })();

      // Override localStorage globally for this script
      const localStorage = safeStorage;

      // ==================== VERSION INFO ====================
      const CURRENT_VERSION = '3.6.8';  // Current version
      const VERSION_CHECK_URL_STABLE = 'https://raw.githubusercontent.com/Myke247/MGTools/main/MGTools.user.js';
      const VERSION_CHECK_URL_BETA = 'https://raw.githubusercontent.com/Myke247/MGTools/Live-Beta/MGTools.user.js';
      const STABLE_DOWNLOAD_URL = 'https://github.com/Myke247/MGTools/raw/refs/heads/main/MGTools.user.js';
      const BETA_DOWNLOAD_URL = 'https://github.com/Myke247/MGTools/raw/refs/heads/Live-Beta/MGTools.user.js';

      // Detect if running Live Beta version (check @updateURL in script)
      // Safe check for Discord pop-out and console paste compatibility
      const IS_LIVE_BETA = (() => {
          try {
              if (typeof GM_info === 'undefined') {
                  return false;
              }
              return GM_info?.script?.updateURL?.includes('Live-Beta') || false;
          } catch (e) {
              console.warn('[MGTOOLS] Branch detection failed:', e.message);
              return false;
          }
      })();

      // Detect if running without Tampermonkey (console paste or incompatible environment)
      const isRunningWithoutTampermonkey = typeof GM_info === 'undefined';

      if (isRunningWithoutTampermonkey) {
          console.error('%c‚ö†Ô∏è MGTOOLS INSTALLATION ERROR', 'font-size:16px;color:#ff0000;font-weight:bold');
          console.error('%cMGTools MUST be installed via Tampermonkey!', 'font-size:14px;color:#ff9900');
          console.error('%cDo NOT paste the script in console - it will not work correctly!', 'font-size:14px;color:#ff9900');
          console.error('%c\nüìã Correct Installation:\n1. Install Tampermonkey: https://www.tampermonkey.net/\n2. Click: https://github.com/Myke247/MGTools/raw/main/MGTools.user.js\n3. Click "Install" button\n4. Refresh Magic Garden', 'font-size:12px;color:#00ffff');

          // Try to continue anyway using localStorage fallback
          console.warn('%c‚ö†Ô∏è Attempting to run in fallback mode (limited functionality)...', 'font-size:12px;color:#ffff00');
      }

      // Semantic version comparison function
      function compareVersions(v1, v2) {
          // Returns: -1 if v1 < v2, 0 if v1 === v2, 1 if v1 > v2
          const parts1 = v1.split('.').map(Number);
          const parts2 = v2.split('.').map(Number);
  
          for (let i = 0; i < Math.max(parts1.length, parts2.length); i++) {
              const part1 = parts1[i] || 0;
              const part2 = parts2[i] || 0;
  
              if (part1 > part2) return 1;
              if (part1 < part2) return -1;
          }
  
          return 0;
      }
  
      // ==================== PRODUCTION MODE (MUST BE FIRST) ====================
      // Set to true to disable non-critical logging for performance
      const PRODUCTION = true; // OPTIMIZED: Enabled to dramatically improve FPS
  
      // ==================== UNIFIED LOGGING SYSTEM ====================
      // Leveled logging with categories for better debugging
      const LogLevel = {
          NONE: 0,     // No logging
          ERROR: 1,    // Critical errors only
          WARN: 2,     // Warnings and errors
          INFO: 3,     // Info, warnings, and errors
          DEBUG: 4     // Everything including debug messages
      };
  
      let tooltipContainer = null;
  
      // Set current log level based on production mode
      const CURRENT_LOG_LEVEL = PRODUCTION ? LogLevel.WARN : LogLevel.DEBUG;
  
      // Unified logging function with categories
      function log(level, category, message, data) {
          if (level > CURRENT_LOG_LEVEL) return;
  
          const prefix = `[${category}]`;
          const args = data !== undefined ? [prefix, message, data] : [prefix, message];
  
          if (level === LogLevel.ERROR) console.error(...args);
          else if (level === LogLevel.WARN) console.warn(...args);
          else console.log(...args);
      }
  
      // Convenience functions for each level
      const logError = (cat, msg, data) => log(LogLevel.ERROR, cat, msg, data);
      const logWarn = (cat, msg, data) => log(LogLevel.WARN, cat, msg, data);
      const logInfo = (cat, msg, data) => log(LogLevel.INFO, cat, msg, data);
      const logDebug = (cat, msg, data) => log(LogLevel.DEBUG, cat, msg, data);
  
      // Legacy compatibility - redirect to new unified logging system
      // These automatically extract categories from [CATEGORY] tags in messages
      const productionLog = (...args) => {
          // Extract category from message if possible (e.g., "[INIT] Starting..." -> category: "INIT")
          const message = String(args[0] || '');
          const categoryMatch = message.match(/^\[([A-Z][A-Z-]*)\]/);
          const category = categoryMatch ? categoryMatch[1] : 'LEGACY';
          // Changed from logDebug to logInfo so logs appear in PRODUCTION mode
          logInfo(category, ...args);
      };
      const productionWarn = (...args) => {
          const message = String(args[0] || '');
          const categoryMatch = message.match(/^\[([A-Z][A-Z-]*)\]/);
          const category = categoryMatch ? categoryMatch[1] : 'LEGACY';
          logWarn(category, ...args);
      };
      const productionError = (...args) => {
          const message = String(args[0] || '');
          const categoryMatch = message.match(/^\[([A-Z][A-Z-]*)\]/);
          const category = categoryMatch ? categoryMatch[1] : 'LEGACY';
          logError(category, ...args);
      };

      // Export logging functions globally for IIFE access
      if (typeof window !== 'undefined') {
          window.productionLog = productionLog;
          window.productionWarn = productionWarn;
          window.productionError = productionError;
      }
      if (typeof unsafeWindow !== 'undefined' && unsafeWindow !== window) {
          unsafeWindow.productionLog = productionLog;
          unsafeWindow.productionWarn = productionWarn;
          unsafeWindow.productionError = productionError;
      }

      // ==================== COMPATIBILITY MODE SYSTEM ====================
      // Advanced CSP detection and compatibility mode for Discord/managed devices
      const CompatibilityMode = {
          flags: {
              enabled: false,
              blockExternalFonts: false,
              blockExternalBeacons: false,
              wsReconnectWhenHidden: false,
              strictNoEvalDynamicImport: false,
              inlineAssetsOnly: false,
              uiReducedMode: false,
              domOnlyStyles: false,
              bypassCSPNetworking: false
          },

          detectionComplete: false,
          cspViolations: [],
          detectionReason: null,

          detect() {
              // Check for user override first
              try {
                  const disabled = localStorage.getItem('mgtools_compat_disabled');
                  if (disabled === 'true') {
                      logInfo('COMPAT', 'Compatibility mode disabled by user');
                      this.detectionComplete = true;
                      return;
                  }

                  const forced = localStorage.getItem('mgtools_compat_forced');
                  if (forced === 'true') {
                      this.enableCompat('user-forced');
                      this.detectionComplete = true;
                      return;
                  }
              } catch (e) {
                  logWarn('COMPAT', 'Unable to check localStorage for compat settings', e);
              }

              // 1. Discord embed detection (enhanced)
              const host = window.location.host;
              const isDiscordEmbed = host.includes('discordsays.com') ||
                                    host.includes('discordactivities.com') ||
                                    host.includes('discord.gg') ||
                                    host.includes('discord.com') ||
                                    // Check for Discord SDK presence
                                    (typeof window.DiscordSDK !== 'undefined') ||
                                    (typeof window.__DISCORD__ !== 'undefined') ||
                                    (typeof window.DiscordNative !== 'undefined');

              if (isDiscordEmbed) {
                  this.enableCompat('discord-embed');
                  this.detectionComplete = true;
                  return;
              }

              // 2. CSP violation listener (500ms window) with duplicate prevention
              const originalError = console.error.bind(console);
              const self = this;
              const seenCSPMessages = new Set();

              console.error = function(...args) {
                  const msg = args.join(' ');

                  // Check for CSP-related errors
                  if ((msg.includes('Content Security Policy') ||
                       msg.includes('Refused to load') ||
                       msg.includes('violates the following')) &&
                      !msg.includes('mgtools')) {  // Ignore our own CSP issues

                      // Skip duplicate CSP violations to reduce console spam
                      if (seenCSPMessages.has(msg)) {
                          return; // Silently skip duplicate
                      }
                      seenCSPMessages.add(msg);

                      self.cspViolations.push(msg);
                      if (self.cspViolations.length >= 2 && !self.flags.enabled) {
                          self.enableCompat('csp-violations');
                      }
                  }
                  return originalError.apply(console, args);
              };

              // 3. Test storage availability
              setTimeout(() => {
                  if (!this.flags.enabled) {
                      try {
                          const testKey = '__mgtools_compat_test_' + Date.now();
                          GM_setValue(testKey, 'test');
                          GM_deleteValue(testKey);
                      } catch (e) {
                          this.enableCompat('storage-failed');
                      }
                  }

                  this.detectionComplete = true;
                  if (this.flags.enabled) {
                      logInfo('COMPAT', 'Compatibility mode ACTIVE', {
                          reason: this.detectionReason,
                          violations: this.cspViolations.length
                      });
                  } else {
                      logDebug('COMPAT', 'Compatibility mode not needed, running in normal mode');
                  }
              }, 500);
          },

          enableCompat(reason) {
              if (this.flags.enabled) return; // Already enabled

              logInfo('COMPAT', `Enabling compatibility mode: ${reason}`);

              // Discord Fix: Add detailed Discord-specific logging
              const isDiscordReason = reason.includes('discord') || reason.includes('csp');
              if (isDiscordReason) {
                  productionLog('üéÆ [DISCORD] Compatibility mode activated for Discord environment');
                  productionLog('   üìã [DISCORD] Features enabled:');
                  productionLog('      ‚Ä¢ Inline styles only (no external CSS)');
                  productionLog('      ‚Ä¢ System fonts (no Google Fonts CDN)');
                  productionLog('      ‚Ä¢ GM_xmlhttpRequest for network requests');
                  productionLog('      ‚Ä¢ DOM mutation observer for UI persistence');
              }

              this.detectionReason = reason;
              this.flags.enabled = true;
              this.flags.blockExternalFonts = true;
              this.flags.blockExternalBeacons = true;
              this.flags.wsReconnectWhenHidden = true;
              this.flags.strictNoEvalDynamicImport = true;
              this.flags.inlineAssetsOnly = true;
              this.flags.uiReducedMode = true;
              this.flags.domOnlyStyles = true;
              this.flags.bypassCSPNetworking = true;

              // Save preference
              try {
                  localStorage.setItem('mgtools_compat_mode', 'true');
                  localStorage.setItem('mgtools_compat_reason', reason);
              } catch (e) {
                  // Ignore localStorage errors in restricted environments
              }
          },

          disableCompat() {
              this.flags.enabled = false;
              Object.keys(this.flags).forEach(key => {
                  if (key !== 'enabled') this.flags[key] = false;
              });

              try {
                  localStorage.setItem('mgtools_compat_disabled', 'true');
                  localStorage.removeItem('mgtools_compat_mode');
              } catch (e) {}

              logInfo('COMPAT', 'Compatibility mode disabled');
          },

          isEnabled() {
              return this.flags.enabled;
          }
      };

      // Initialize compatibility detection immediately
      CompatibilityMode.detect();

      // ==================== NETWORK ABSTRACTION LAYER ====================
      // Unified network layer that bypasses CSP using GM_xmlhttpRequest in compat mode
      const Network = {
          async fetch(url, options = {}) {
              if (CompatibilityMode.flags.bypassCSPNetworking &&
                  typeof GM_xmlhttpRequest === 'function' &&
                  !url.startsWith(window.location.origin)) {
                  // Use GM_xmlhttpRequest to bypass CSP for external requests
                  logDebug('NETWORK', `Using GM_xmlhttpRequest for: ${url}`);
                  return new Promise((resolve, reject) => {
                      GM_xmlhttpRequest({
                          url,
                          method: options.method || 'GET',
                          headers: options.headers || {},
                          data: options.body,
                          responseType: 'text',
                          timeout: options.timeout || 10000,
                          onload: (response) => {
                              resolve({
                                  ok: response.status >= 200 && response.status < 300,
                                  status: response.status,
                                  statusText: response.statusText,
                                  text: () => Promise.resolve(response.responseText),
                                  json: () => Promise.resolve(JSON.parse(response.responseText)),
                                  headers: {
                                      get: (name) => response.responseHeaders.match(
                                          new RegExp(`^${name}:\\s*(.*)$`, 'mi')
                                      )?.[1]
                                  }
                              });
                          },
                          onerror: (error) => reject(new Error(error.statusText || 'Network error')),
                          ontimeout: () => reject(new Error('Request timeout'))
                      });
                  });
              } else {
                  // Normal fetch
                  return fetch(url, options);
              }
          }
      };

      // ==================== ASSET MANAGEMENT (STYLES & FONTS) ====================
      // Compatibility-aware style and font loading
      const AssetManager = {
          addStyles(css, id) {
              // Discord Fix: Prefer GM_addElement for best CSP compatibility
              // GM_addElement bypasses CSP better than regular createElement
              if (typeof GM_addElement === 'function' && CompatibilityMode.flags.enabled) {
                  try {
                      const attrs = { textContent: css };
                      if (id) attrs.id = id;
                      GM_addElement('style', attrs);
                      logDebug('ASSETS', `Added styles via GM_addElement${id ? ` (${id})` : ''} (Discord-safe)`);
                      return;
                  } catch (e) {
                      logWarn('ASSETS', 'GM_addElement failed, falling back to standard method', e);
                  }
              }

              if (CompatibilityMode.flags.domOnlyStyles) {
                  // Inline styles only - inject into head with style element
                  const style = document.createElement('style');
                  style.textContent = css;
                  if (id) style.id = id;
                  document.head.appendChild(style);
                  logDebug('ASSETS', `Injected inline styles${id ? ` (${id})` : ''}`);
              } else {
                  // Normal mode - use GM_addStyle if available
                  if (typeof GM_addStyle === 'function') {
                      GM_addStyle(css);
                  } else {
                      const style = document.createElement('style');
                      style.textContent = css;
                      if (id) style.id = id;
                      document.head.appendChild(style);
                  }
                  logDebug('ASSETS', `Added styles${id ? ` (${id})` : ''}`);
              }
          },

          loadFonts() {
              if (CompatibilityMode.flags.blockExternalFonts) {
                  // Use system fonts only
                  this.addStyles(`
                      .mgtools-ui *, .mga-dock *, .mga-sidebar *, .mga-panel * {
                          font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
                                       Roboto, Helvetica, Arial, sans-serif !important;
                      }
                      .fancy-header, .mgtools-header {
                          font-family: Georgia, "Times New Roman", serif !important;
                          font-style: italic;
                      }
                  `, 'mgtools-compat-fonts');
                  logInfo('ASSETS', 'Using system fonts (compat mode)');
              } else {
                  // Normal font loading - Google Fonts
                  // The CSP guard at the top of the file will prevent this in Discord anyway
                  logDebug('ASSETS', 'External fonts allowed (normal mode)');
              }
          },

          // Icon helper - returns data URI in compat mode or emoji/text fallback
          getIcon(name) {
              // In compat mode or for simplicity, use emoji fallbacks
              const icons = {
                  'pet': 'üêæ',
                  'timer': '‚è∞',
                  'shop': 'üõí',
                  'seeds': 'üå±',
                  'values': 'üíé',
                  'abilities': '‚ö°',
                  'rooms': 'üè†',
                  'tools': 'üîß',
                  'settings': '‚öôÔ∏è',
                  'hotkeys': '‚å®Ô∏è',
                  'help': '‚ùì',
                  'alert': 'üîî',
                  'close': '‚úñÔ∏è',
                  'refresh': 'üîÑ',
                  'save': 'üíæ',
                  'export': 'üì§',
                  'import': 'üì•'
              };
              return icons[name] || 'üì¶';
          }
      };

      // Call font setup early
      AssetManager.loadFonts();

      // ==================== SELECTIVE CONTEXT ISOLATION ====================
      // Detect execution context and set up selective window/document references
      const isUserscript = typeof unsafeWindow !== 'undefined';
      let targetWindow = isUserscript ? unsafeWindow : window;
      let targetDocument = targetWindow.document;

      // Track which atoms have been hooked to prevent duplicates
      const hookedAtoms = new Set();

      // Set context identifier for debugging (use window not targetWindow to avoid modifying page)
      window.MGA_CONTEXT = isUserscript ? 'userscript' : 'console';

      // ==================== API BASE URL HELPER (MUST BE EARLY) ====================
      // This function MUST be defined early because roomsInfo() IIFE needs it immediately
      // Determines correct API base URL to prevent 404 errors in Discord browser
      targetWindow.getGameApiBaseUrl = function() {
          try {
              // Check if we're in Discord browser or Discord activity
              const isDiscordHost = window.location.host.includes('discordsays.com') ||
                                    window.location.host.endsWith('.discordsays.com') ||
                                    window.location.host.includes('discord.com');

              const isInIframe = window.location !== window.parent.location;
              const hasDiscordNative = window.DiscordNative !== undefined;

              // If in any Discord context, use magiccircle.gg API
              // This prevents 404 errors when trying to fetch from discord.com/api/rooms/
              if (isDiscordHost || hasDiscordNative || (isInIframe && document.referrer && document.referrer.includes('discord'))) {
                  return 'https://magiccircle.gg';
              }

              // Otherwise use current origin for proper same-origin requests
              return location.origin;
          } catch (err) {
              console.error('[API-BASE] Failed to determine API base URL:', err);
              // Safe fallback: use magiccircle.gg if detection fails
              return 'https://magiccircle.gg';
          }
      };

      // Also define as regular function for convenience
      const getGameApiBaseUrl = targetWindow.getGameApiBaseUrl;

      // Verify function is accessible and log current API base
      console.log('‚úÖ [API-BASE] getGameApiBaseUrl() defined and accessible');
      try {
          console.log('üîó [API-BASE] Current API base:', targetWindow.getGameApiBaseUrl());
      } catch (e) {
          console.error('‚ùå [API-BASE] Function exists but failed to execute:', e);
      }

      // GM API availability check with actual functionality test
      let gmApiCheckResult = null; // Cache the result
      let gmApiWarningShown = false; // Only warn once

      function isGMApiAvailable() {
          // CRITICAL: Wrap entire function in try-catch to prevent script failure on managed devices
          try {
              // Return cached result if already tested
              if (gmApiCheckResult !== null) {
                  return gmApiCheckResult;
              }

              // Check if functions exist
              if (typeof GM_setValue === 'undefined' || typeof GM_getValue === 'undefined') {
                  gmApiCheckResult = false;
                  if (!gmApiWarningShown) {
                      try {
                          logWarn('GM-STORAGE', 'GM API functions not defined - using localStorage fallback');
                      } catch (e) {
                          console.warn('‚ö†Ô∏è [GM-STORAGE] GM API not available - using localStorage fallback');
                      }
                      gmApiWarningShown = true;
                  }
                  return false;
              }

              // Try to actually USE the functions (managed devices may block them)
              try {
                  const testKey = '__mgtools_gm_test__';
                  const testValue = 'test_' + Date.now();
                  GM_setValue(testKey, testValue);
                  const retrieved = GM_getValue(testKey, null);

                  // Clean up test
                  try {
                      if (typeof GM_deleteValue !== 'undefined') {
                          GM_deleteValue(testKey);
                      }
                  } catch (e) {
                      // Ignore cleanup errors
                  }

                  // Check if it actually worked
                  if (retrieved === testValue) {
                      gmApiCheckResult = true;
                      try {
                          logInfo('GM-STORAGE', 'GM API fully functional');
                      } catch (e) {
                          console.log('‚úÖ [GM-STORAGE] GM API fully functional');
                      }
                      return true;
                  } else {
                      throw new Error('GM_getValue returned incorrect value');
                  }
              } catch (e) {
                  gmApiCheckResult = false;
                  if (!gmApiWarningShown) {
                      try {
                          logWarn('GM-STORAGE', 'GM API blocked by security policy - using localStorage fallback');
                      } catch (e2) {
                          console.warn('‚ö†Ô∏è [GM-STORAGE] GM API blocked - using localStorage fallback');
                      }
                      gmApiWarningShown = true;
                  }
                  return false;
              }
          } catch (outerError) {
              // Absolute last resort - assume GM API is not available and continue
              gmApiCheckResult = false;
              gmApiWarningShown = true;
              try {
                  console.warn('‚ö†Ô∏è [GM-STORAGE] Unexpected error testing GM API - using localStorage fallback');
              } catch (e) {
                  // Even console might fail on heavily locked down devices
              }
              return false;
          }
      }
  
      // SELECTIVE CONTEXT FUNCTIONS - Use these instead of direct document/window references
      function createMGAElement(tag, className) {
          const element = targetDocument.createElement(tag);
          if (className) element.className = className;
          return element;
      }
  
      function attachToMGAContext(element) {
          targetDocument.body.appendChild(element);
      }
  
      function isMGAEvent(event) {
          try {
              return event && event.target && event.target.closest &&
                     event.target.closest('.mga-panel, .mga-toggle-btn, .mga-overlay');
          } catch (error) {
              console.error('‚ùå [BASIC-DEBUG] Error in isMGAEvent:', error);
              return false;
          }
      }
  
      function checkForGameModals() {
          try {
              // Use regular document for game modal detection to avoid interference
              const modals = document.querySelectorAll('[class*="modal"], [class*="dialog"], [role="dialog"]');
              // CRITICAL FIX: Exclude game drag overlays that are normal game UI, not blocking modals
              const overlays = document.querySelectorAll('[class*="overlay"]:not(.mga-overlay):not(.top-drag-overlay):not(.bottom-drag-overlay)');
              const popups = document.querySelectorAll('[class*="popup"]:not(.mga-panel)');
  
              // More comprehensive modal detection
              const mgcModals = document.querySelectorAll('[class*="MGC"], [class*="magic-circle"]');
              const saveDiscardButtons = document.querySelectorAll('button:not(.mga-btn)');
  
              const totalModalElements = modals.length + overlays.length + popups.length + mgcModals.length;
  
              // Check for excluded drag overlays
              const dragOverlays = document.querySelectorAll('.top-drag-overlay, .bottom-drag-overlay');
  
              // DEBUG: Log every modal check with full details
              const modalDetails = {
                  modals: modals.length,
                  overlays: overlays.length,
                  popups: popups.length,
                  mgcElements: mgcModals.length,
                  dragOverlaysExcluded: dragOverlays.length,
                  total: totalModalElements,
                  modalClasses: Array.from(modals).map(m => m.className),
                  overlayClasses: Array.from(overlays).map(o => o.className),
                  mgcClasses: Array.from(mgcModals).map(m => m.className)
              };
  
              if (window.MGA_DEBUG) {
                  window.MGA_DEBUG.logModalEvent('MODAL_CHECK_PERFORMED', modalDetails);
              }
  
              // Log drag overlay exclusion
              if (dragOverlays.length > 0) {
                  logInfo('INIT', `Excluding ${dragOverlays.length} game drag overlays (normal game UI, not blocking modals)`);
              }
  
              // DISABLED: False positive detection - game naturally has modal/overlay elements
              // This was blocking initialization and causing infinite retry loops
              if (false && totalModalElements > 0) {
                  logInfo('INIT', 'Game modal system active - deferring MGA interactions', modalDetails);
                  if (window.MGA_DEBUG) {
                      window.MGA_DEBUG.logModalEvent('MODAL_SYSTEM_ACTIVE', modalDetails);
                  }
                  return false;
              }
  
              // SIMPLIFIED: Only block for actual modal/dialog containers, not individual buttons
              // If there are no modals/dialogs detected above, allow initialization
              logInfo('INIT', 'No blocking modals detected - MGA initialization allowed');
  
              return true;
          } catch (error) {
              console.error('‚ùå [MODAL-CHECK] Error in modal detection:', error);
              if (window.MGA_DEBUG) {
                  window.MGA_DEBUG.logError(error, 'checkForGameModals');
              }
              return true; // Allow MGA operations if modal check fails
          }
      }
  
      // ==================== SCRIPT IDENTIFICATION ====================
      // DO NOT override console - causes issues in Tampermonkey sandbox
  
      logInfo('CONTEXT', 'Script context:', window.MGA_CONTEXT);
      logInfo('CONTEXT', 'GM API available:', isGMApiAvailable());
      logInfo('CONTEXT', 'unsafeWindow available:', isUserscript);
      logInfo('CONTEXT', 'Selective isolation enabled - game modals preserved');
  
      // Add manual debug export command
      logInfo('DEBUG', 'Manual debug export: Run "MGA_DEBUG.exportDebug()" in console anytime');
      logInfo('DEBUG', 'Auto-export will trigger in 30s if issues are detected');
  
      // Verify debug system is working
      setTimeout(() => {
          if (typeof window.MGA_DEBUG === 'undefined') {
              console.error('‚ùå [DEBUG-VERIFY] MGA_DEBUG is not defined! Debug system failed to initialize');
              logWarn('DEBUG', 'Basic logging will continue without full debug system');
          } else {
              logInfo('DEBUG', 'MGA_DEBUG is available and working');
              logDebug('DEBUG', 'Available methods:', Object.keys(window.MGA_DEBUG));
          }
      }, 100);
  
      // Add modal system verification logging
      function logModalSystemStatus() {
          const initialModalCheck = checkForGameModals();
          logInfo('INIT', 'Modal isolation verification:', {
              gameModalsActive: !initialModalCheck,
              eventIsolationActive: typeof isMGAEvent === 'function',
              contextIsolationActive: typeof createMGAElement === 'function',
              targetDocumentAvailable: !!targetDocument,
              regularDocumentIntact: !!document
          });
  
          // Test event isolation function
          const testEvent = { target: document.body };
          const testMGAEvent = { target: { closest: () => null } };
          logDebug('INIT', 'Event isolation test:', {
              gameEventBlocked: !isMGAEvent(testEvent),
              mgaEventAllowed: !isMGAEvent(testMGAEvent) // Should be false since closest returns null
          });
      }
  
      // Run modal system verification after a short delay
      setTimeout(logModalSystemStatus, 100);
  
      // ==================== COMPREHENSIVE DEBUG SYSTEM ====================
  
      function createDebugLogger() {
          const debugData = {
              timestamp: new Date().toISOString(),
              loadingStages: [],
              modalEvents: [],
              contextIssues: [],
              errorLogs: [],
              performanceMetrics: {
                  scriptStart: performance.now(),
                  domReady: null,
                  gameReady: null,
                  uiCreated: null,
                  fullyLoaded: null
              }
          };
  
          // Enhanced logging functions
          function logStage(stage, details = {}) {
              const entry = {
                  timestamp: performance.now(),
                  stage,
                  details,
                  domState: document.readyState,
                  gameElements: {
                      jotaiAtoms: !!(targetWindow && targetWindow.jotaiAtomCache),
                      magicCircle: !!(targetWindow && targetWindow.MagicCircle_RoomConnection),
                      canvas: !!document.querySelector('canvas'),
                      gameContainer: !!document.querySelector('#game-container, #app, .game-wrapper, main')
                  }
              };
              debugData.loadingStages.push(entry);
              logDebug('DEBUG-SYSTEM', `Stage: ${stage}`, entry);
          }
  
          function logModalEvent(event, details = {}) {
              const entry = {
                  timestamp: performance.now(),
                  event,
                  details,
                  gameModals: document.querySelectorAll('[class*="modal"], [class*="dialog"], [role="dialog"]').length,
                  mgaElements: targetDocument.querySelectorAll('.mga-panel, .mga-toggle-btn').length
              };
              debugData.modalEvents.push(entry);
              logDebug('DEBUG-SYSTEM', `Modal Event: ${event}`, entry);
          }
  
          function logContextIssue(issue, details = {}) {
              const entry = {
                  timestamp: performance.now(),
                  issue,
                  details,
                  context: {
                      isUserscript,
                      targetWindow: targetWindow === window ? 'same' : 'different',
                      targetDocument: targetDocument === document ? 'same' : 'different',
                      gmApiAvailable: isGMApiAvailable()
                  }
              };
              debugData.contextIssues.push(entry);
              logDebug('DEBUG-SYSTEM', `Context Issue: ${issue}`, entry);
          }
  
          function logError(error, context = '') {
              const entry = {
                  timestamp: performance.now(),
                  error: error.toString(),
                  stack: error.stack,
                  context
              };
              debugData.errorLogs.push(entry);
              console.error(`üêõ [DEBUG-ERROR] ${context}:`, entry);
          }
  
          // Store debug functions globally
          window.MGA_DEBUG = {
              logStage,
              logModalEvent,
              logContextIssue,
              logError,
              getData: () => debugData,
              exportDebug: () => {
                  logInfo('DEBUG-SYSTEM', 'Complete debug data:', JSON.stringify(debugData, null, 2));
                  return debugData;
              }
          };
  
          logStage('DEBUG_SYSTEM_INITIALIZED', {
              userAgent: navigator.userAgent,
              url: window.location.href,
              contextDetection: { isUserscript, targetWindow: targetWindow.constructor.name }
          });
  
          return window.MGA_DEBUG;
      }
  
      // Initialize debug system immediately with error handling
      let DEBUG;
      try {
          DEBUG = createDebugLogger();
          logInfo('DEBUG-SYSTEM', 'Debug system initialized successfully');
      } catch (error) {
          logError('DEBUG-SYSTEM', 'Failed to initialize debug system:', error);
          // Create a minimal debug fallback
          window.MGA_DEBUG = {
              logStage: (stage, details) => logDebug('DEBUG-SYSTEM', `Stage: ${stage}`, details),
              logModalEvent: (event, details) => logDebug('DEBUG-SYSTEM', `Modal Event: ${event}`, details),
              logContextIssue: (issue, details) => logDebug('DEBUG-SYSTEM', `Context Issue: ${issue}`, details),
              logError: (error, context) => logError('DEBUG-SYSTEM', `Error in ${context}:`, error),
              getData: () => ({ error: 'Debug system failed to initialize', fallback: true }),
              exportDebug: () => logWarn('DEBUG-SYSTEM', 'Debug system failed to initialize properly')
          };
          DEBUG = window.MGA_DEBUG;
      }
  
      // Add global error handler for comprehensive error logging
      window.addEventListener('error', (event) => {
          if (window.MGA_DEBUG) {
              window.MGA_DEBUG.logError(event.error || new Error(event.message), 'GLOBAL_ERROR_HANDLER');
          }
      });
  
      window.addEventListener('unhandledrejection', (event) => {
          if (window.MGA_DEBUG) {
              window.MGA_DEBUG.logError(event.reason || new Error('Unhandled Promise Rejection'), 'UNHANDLED_REJECTION');
          }
      });
  
      // Auto-export debug data after 30 seconds if issues detected
      setTimeout(() => {
          if (window.MGA_DEBUG) {
              const debugData = window.MGA_DEBUG.getData();
              const hasErrors = debugData.errorLogs.length > 0;
              const hasModalIssues = debugData.modalEvents.some(e => e.event === 'MODAL_SYSTEM_ACTIVE');
              const uiNotCreated = !debugData.loadingStages.some(s => s.stage === 'CREATE_UI_COMPLETED');
  
              if (hasErrors || hasModalIssues || uiNotCreated) {
                  productionLog('üö® [AUTO-DEBUG] Issues detected - exporting debug data...');
                  window.MGA_DEBUG.exportDebug();
                  productionLog('üìã [AUTO-DEBUG] Copy the debug data above and paste it into mgdebug.txt');
              } else {
                  productionLog('‚úÖ [AUTO-DEBUG] No issues detected in first 30 seconds');
              }
          }
      }, 30000);

      // ==================== CRITICAL EXECUTION CHECKPOINT ====================
      console.log('üîçüîçüîç [EXECUTION] Reached line 951 - About to define initialization');
      console.log('üîç typeof document:', typeof document);
      console.log('üîç typeof window:', typeof window);
      console.log('üîç document.readyState:', document?.readyState);

      // ==================== PROPER PAGE LOAD DETECTION ====================
      // Fix for document-idle timing issues - wait for complete page load
      let initializationStarted = false;
  
      function initializeWhenReady() {
          console.log('üîçüîçüîç [EXECUTION] initializeWhenReady() called!');
          console.log(`üîç [EXECUTION] initializationStarted = ${initializationStarted}`);
          if (initializationStarted) {
              console.log('üîç [EXECUTION] Already initialized, returning early');
              return;
          }
          initializationStarted = true;
          console.log('üîç [EXECUTION] Set initializationStarted = true');
  
          productionLog('üöÄ Magic Garden Unified Assistant v3.5.2 - Discord Fix');
          productionLog('üîß CRITICAL: Disabled data-destroying migration system');
          productionLog('üîß Fixed: Now uses localStorage directly (100% reliable)');
          productionLog('üîß Fixed: Active pets detection with retry logic');
          productionLog('‚úÖ Seeds + Pet Presets will now SAVE and LOAD correctly!');
          productionLog('üîß [TIMING] Page load state:', document.readyState);
          productionLog('üîß [BASIC-DEBUG] Script execution started at:', new Date().toISOString());
          productionLog('üîß [BASIC-DEBUG] Location:', window.location.href);
          productionLog('üîß [BASIC-DEBUG] User Agent:', navigator.userAgent);
  
          // Proceed with initialization
          console.log('üîç [EXECUTION] About to call startMGAInitialization()');
          startMGAInitialization();
          console.log('üîç [EXECUTION] startMGAInitialization() returned');
      }
  
      // CRITICAL FIX: Handle all readyState possibilities for Tampermonkey compatibility
      // document-idle means readyState is 'interactive' - not 'loading' or 'complete'

      console.log('üîçüîçüîç [EXECUTION] Reached line 982 - INITIALIZATION BLOCK START');
      console.log('üîç About to call productionLog for readyState...');

      try {
          productionLog('üîß [INIT] Initial readyState:', document.readyState);
      } catch (e) {
          console.error('‚ùå [EXECUTION] productionLog FAILED:', e);
      }

      // Detect Discord environment for special handling
      const isDiscordEnv = window.location.host.includes('discordsays.com') ||
                           window.location.host.includes('discord.com') ||
                           (typeof window.DiscordNative !== 'undefined') ||
                           (typeof window.__DISCORD__ !== 'undefined');

      if (isDiscordEnv) {
          productionLog('üéÆ [DISCORD] Discord environment detected, using specialized initialization');
      }

      // Discord Fix: Use shorter delay for Discord, check for canvas existence
      const initDelay = isDiscordEnv ? 500 : (isUserscript ? 3000 : 100);

      // Helper function to check if game canvas is ready
      function isGameCanvasReady() {
          const canvas = document.querySelector('canvas');
          const gameContainer = document.querySelector('#game-container, #app, .game-wrapper, main, body');
          const ready = canvas && gameContainer;
          if (!ready && isDiscordEnv) {
              productionLog('‚è≥ [DISCORD] Waiting for game canvas...');
          }
          return ready;
      }

      // Discord Fix: Wait for canvas with retry mechanism
      function initWithCanvasCheck(attempt = 0) {
          console.log(`üîç [EXECUTION] initWithCanvasCheck called, attempt=${attempt}`);
          if (isGameCanvasReady()) {
              console.log('üîç [EXECUTION] Canvas ready! Calling initializeWhenReady()');
              productionLog('‚úÖ [INIT] Game canvas detected, initializing MGTools');
              initializeWhenReady();
          } else if (attempt < 20) {
              // Retry up to 20 times (10 seconds) for Discord
              console.log(`üîç [EXECUTION] Canvas not ready, scheduling retry ${attempt + 1}/20`);
              productionLog(`üîÑ [INIT] Canvas not ready, retry ${attempt + 1}/20`);
              setTimeout(() => initWithCanvasCheck(attempt + 1), 500);
          } else {
              console.log('üîç [EXECUTION] Max retries reached, calling initializeWhenReady() anyway');
              productionLog('‚ö†Ô∏è [INIT] Canvas not detected after 10s, initializing anyway');
              initializeWhenReady();
          }
      }

      console.log('üîç [EXECUTION] About to check document.readyState...');

      try {
          if (document.readyState === 'complete') {
              // Page is already fully loaded
              console.log('üîç [EXECUTION] readyState is complete');
              console.log(`üîç [EXECUTION] isDiscordEnv = ${isDiscordEnv}, initDelay = ${initDelay}ms`);
              productionLog(`üîß [INIT] Page already complete, initializing in ${initDelay}ms`);
              console.log(`üîç [EXECUTION] About to schedule setTimeout for ${initDelay}ms`);
              setTimeout(() => {
                  console.log('üîçüîçüîç [EXECUTION] setTimeout FIRED! About to call init function...');
                  if (isDiscordEnv) {
                      console.log('üîç [EXECUTION] Calling initWithCanvasCheck()');
                      initWithCanvasCheck();
                  } else {
                      console.log('üîç [EXECUTION] Calling initializeWhenReady()');
                      initializeWhenReady();
                  }
              }, initDelay);
          } else if (document.readyState === 'interactive') {
              console.log('üîç [EXECUTION] readyState is interactive');
              // DOM is ready but resources still loading (document-idle state)
              productionLog(`üîß [INIT] DOM interactive (document-idle), initializing in ${initDelay}ms...`);
              setTimeout(() => {
                  if (isDiscordEnv) {
                      initWithCanvasCheck();
                  } else {
                      initializeWhenReady();
                  }
              }, initDelay);
          } else {
              // readyState is 'loading' - wait for full page load
              productionLog('üîß [INIT] DOM still loading, waiting for load event...');

              // Discord Fix: Use DOMContentLoaded for Discord like friendscript does
              if (isDiscordEnv) {
                  document.addEventListener('DOMContentLoaded', () => {
                      productionLog('‚úÖ [DISCORD] DOM ready, checking for canvas...');
                      setTimeout(() => initWithCanvasCheck(), initDelay);
                  });
              } else {
                  window.addEventListener('load', initializeWhenReady);

                  // Backup: also listen for DOMContentLoaded
                  document.addEventListener('DOMContentLoaded', () => {
                      productionLog('üîß [TIMING] DOM ready, waiting for complete load...');
                  });
              }
          }
      } catch (initError) {
          console.error('‚ùå‚ùå‚ùå [EXECUTION] CRITICAL ERROR in initialization block:', initError);
          console.error('Stack:', initError.stack);
          // Try to initialize anyway as fallback
          console.log('üîÑ [EXECUTION] Attempting fallback initialization in 1s...');
          setTimeout(() => {
              try {
                  initializeWhenReady();
              } catch (e2) {
                  console.error('‚ùå [EXECUTION] Fallback also failed:', e2);
              }
          }, 1000);
      }

      console.log('‚úÖ [EXECUTION] Initialization block completed without throwing');

      function startMGAInitialization() {
          console.log('üîçüîçüîçüîçüîç [EXECUTION] ENTERED startMGAInitialization() function!');
          console.log('üîç [EXECUTION] document.readyState:', document.readyState);
          productionLog('üöÄ [TIMING] Starting MGA initialization with readyState:', document.readyState);
          console.log('üîç [EXECUTION] productionLog completed, continuing...');

      // ==================== PROACTIVE STORAGE CLEANUP ====================
      // CRITICAL: Clean up large debug/console storage items BEFORE MGTools tries to save anything
      // This prevents quota errors on managed devices with monitoring software
      (function cleanupStorageBeforeInit() {
          try {
              const debugKeys = [
                  'console-history',
                  'mga-debug-cache',
                  'mga-temp-cache',
                  'console-insights-onboarding-finished',
                  'experiments',
                  'settles',
                  'getItem',
                  'removeItem',
                  'key',
                  'localInspectorVersion'
              ];

              let cleaned = 0;
              let freedBytes = 0;

              for (const key of debugKeys) {
                  try {
                      const value = localStorage.getItem(key);
                      if (value) {
                          const size = value.length;
                          // Remove any item over 100KB or any console-history regardless of size
                          if (size > 100000 || key.includes('console')) {
                              localStorage.removeItem(key);
                              cleaned++;
                              freedBytes += size;
                              logInfo('STORAGE-CLEANUP', `Removed ${key} (${(size / 1024).toFixed(1)}KB)`);
                          }
                      }
                  } catch (e) {
                      // Ignore errors for individual keys
                  }
              }

              if (cleaned > 0) {
                  logInfo('STORAGE-CLEANUP', `Freed ${(freedBytes / 1024).toFixed(1)}KB by removing ${cleaned} debug items`);
              }
          } catch (e) {
              logWarn('STORAGE-CLEANUP', 'Could not clean storage, continuing anyway', e);
          }
      })();

      // Detect other Magic Garden scripts
      setTimeout(() => {
          const hasMainScript = typeof window.loadJSON === 'function' ||
                               typeof window.petAbilityLogs !== 'undefined' ||
                               document.hidden === false;
          if (hasMainScript) {
              productionLog('üìù [COMPAT] Detected mainscript.txt is also running - compatibility mode enabled');
          } else {
              productionLog('üìù [COMPAT] No other Magic Garden scripts detected - running standalone');
          }
      }, 100);
  
      // ==================== IMMEDIATE IDLE PREVENTION ====================
      // CRITICAL: Apply idle prevention immediately before any game code runs
      (function() {
          productionLog('üö´ [IDLE-PREVENTION] Applying immediate anti-idle protection...');
  
          // Override document properties to prevent idle detection
          try {
              Object.defineProperty(document, "hidden", {
                  value: false,
                  writable: false,
                  configurable: false
              });
              Object.defineProperty(document, "visibilityState", {
                  value: "visible",
                  writable: false,
                  configurable: false
              });
              productionLog('‚úÖ [IDLE-PREVENTION] Document properties overridden');
          } catch (e) {
              productionWarn('‚ö†Ô∏è [IDLE-PREVENTION] Could not override document properties:', e);
          }
  
          // Block idle detection events with capture phase (highest priority)
          document.addEventListener("visibilitychange", (e) => {
              e.stopImmediatePropagation();
              e.preventDefault();
          }, true);
  
          window.addEventListener("blur", (e) => {
              e.stopImmediatePropagation();
              e.preventDefault();
          }, true);
  
          window.addEventListener("focus", (e) => {
              e.stopImmediatePropagation();
              e.preventDefault();
          }, true);
  
          productionLog('‚úÖ [IDLE-PREVENTION] Event listeners added with capture phase');
      })();
  
      // ==================== INITIALIZATION ====================
      /* CHECKPOINT removed: INITIALIZATION_START */
  
      // ==================== GLOBAL STYLES ====================
      // Skip Google Fonts on Discord to avoid CSP violations
      const isDiscordPage = window.location.hostname.includes('discord.com') ||
                            window.location.hostname.includes('discordsays.com') ||
                            (typeof window.DiscordNative !== 'undefined') ||
                            (typeof window.__DISCORD__ !== 'undefined');

      // Use empty string for Discord (system fonts only), otherwise no Google Fonts CDN
      // We never use external CDN to avoid CSP issues entirely
      const googleFontsImport = '';
  
      const UNIFIED_STYLES = `
          ${googleFontsImport}
  
          /* ==================== HYBRID DOCK STYLES ==================== */
          #mgh-dock {
              font-family: 'Inter', sans-serif;
              position: fixed;
              display: flex;
              gap: 6px;
              background: rgba(10, 10, 10, 0.9);
              backdrop-filter: blur(20px);
              border: 1px solid rgba(255, 255, 255, 0.15);
              padding: 8px 12px;
              z-index: 999999;
              box-shadow: 0 8px 24px rgba(0, 0, 0, 0.5);
              /* No transition for instant drag response */
          }
  
          #mgh-dock.horizontal {
              bottom: 16px;
              left: 50%;
              transform: translateX(-50%);
              flex-direction: row;
              border-radius: 16px;
          }
  
          #mgh-dock.vertical {
              left: 16px;
              top: 20px;
              transform: none;
              flex-direction: column;
              border-radius: 16px;
              max-height: calc(100vh - 40px);
              overflow-y: auto;
              overflow-x: hidden;
          }
  
          /* Custom scrollbar for vertical dock */
          #mgh-dock.vertical::-webkit-scrollbar {
              width: 4px;
          }
  
          #mgh-dock.vertical::-webkit-scrollbar-track {
              background: transparent;
          }
  
          #mgh-dock.vertical::-webkit-scrollbar-thumb {
              background: rgba(255, 255, 255, 0.2);
              border-radius: 2px;
          }
  
          #mgh-dock.vertical::-webkit-scrollbar-thumb:hover {
              background: rgba(255, 255, 255, 0.3);
          }
  
          /* Scroll indicators - gradient shadows at top/bottom when scrollable */
          #mgh-dock.vertical::before,
          #mgh-dock.vertical::after {
              content: '';
              position: sticky;
              display: block;
              left: 0;
              right: 0;
              height: 20px;
              pointer-events: none;
              z-index: 10;
          }
  
          #mgh-dock.vertical::before {
              top: 0;
              background: linear-gradient(to bottom, rgba(31, 41, 55, 0.9), transparent);
              margin-bottom: -20px;
          }
  
          #mgh-dock.vertical::after {
              bottom: 0;
              background: linear-gradient(to top, rgba(31, 41, 55, 0.9), transparent);
              margin-top: -20px;
          }
  
          .mgh-dock-item {
              width: 44px;
              height: 44px;
              background: rgba(255, 255, 255, 0.05);
              border: 1px solid rgba(255, 255, 255, 0.57);
              border-radius: 10px;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 18px;
              cursor: pointer;
              transition: all 0.3s ease;
              position: relative;
          }
  
          .mgh-dock-item:hover {
              background: rgba(255, 255, 255, 0.15);
              transform: scale(1.1);
          }
  
          .mgh-dock-item.active {
              background: rgba(102, 126, 234, 0.3);
              border-color: #667eea;
          }
  
          .mgh-dock-item.flip-toggle {
              background: rgba(255, 255, 255, 0.08);
              font-size: 14px;
          }
  
          .mgh-dock-item.flip-toggle:hover {
              background: rgba(255, 255, 255, 0.12);
          }
  
          /* Optimized sizes for vertical mode */
          #mgh-dock.vertical .mgh-dock-item {
              width: 40px;
              height: 40px;
          }
  
          #mgh-dock.vertical .mgh-dock-item img {
              /* FIX: Match scriptwithicons sizing exactly */
              width: 24px;
              height: 24px;
          }
  
          #mgh-dock.vertical .mgh-dock-item {
              font-size: 20px;
          }
  
          .mgh-tooltip {
              position: absolute;
              background: rgba(10, 10, 10, 0.95);
              padding: 6px 10px;
              border-radius: 6px;
              font-size: 11px;
              color: white;
              white-space: nowrap;
              opacity: 0;
              pointer-events: none;
              transition: opacity 0.2s;
              border: 1px solid rgba(255, 255, 255, 0.57);
              z-index: 10;
          }
  
          #mgh-dock.horizontal .mgh-tooltip {
              bottom: 56px;
              left: 50%;
              transform: translateX(-50%);
          }
  
          #mgh-dock.vertical .mgh-tooltip {
              left: 56px;
              top: 50%;
              transform: translateY(-50%);
          }
  
          .mgh-dock-item:hover .mgh-tooltip { opacity: 1; }
  
          .mgh-tail-group {
              display: flex;
              gap: 6px;
              transition: opacity 0.3s ease;
          }
  
          #mgh-dock.horizontal .mgh-tail-group {
              flex-direction: row;
          }
  
          #mgh-dock.vertical .mgh-tail-group {
              flex-direction: column;
          }
  
          /* ==================== SIDEBAR STYLES ==================== */
          #mgh-sidebar {
              font-family: 'Inter', sans-serif;
              position: fixed;
              left: -420px;
              top: 0;
              width: 400px;
              height: 100vh;
              background: rgba(10, 10, 10, 0.95);
              backdrop-filter: blur(20px);
              border-right: 1px solid rgba(255, 255, 255, 0.15);
              z-index: 999998;
              transition: left 0.3s ease;
              display: flex;
              flex-direction: column;
              box-shadow: 4px 0 24px rgba(0, 0, 0, 0.6);
          }
  
          #mgh-sidebar.open { left: 0; }
  
          /* ==================== SHOP SIDEBAR STYLES ==================== */
          .mga-shop-sidebar {
              font-family: 'Inter', sans-serif;
              position: fixed;
              top: 0;
              width: 380px;
              height: 100vh;
              background: rgba(10, 10, 10, 0.95);
              backdrop-filter: blur(20px);
              border: 1px solid rgba(255, 255, 255, 0.15);
              z-index: 999998;
              transition: left 0.3s ease, right 0.3s ease;
              display: flex;
              flex-direction: column;
              box-shadow: 0 0 24px rgba(0, 0, 0, 0.6);
          }
  
          .mga-shop-sidebar-left {
              left: -400px;
              border-right: 1px solid rgba(255, 255, 255, 0.15);
          }
  
          .mga-shop-sidebar-left.open {
              left: 0;
          }
  
          .mga-shop-sidebar-right {
              right: -400px;
              border-left: 1px solid rgba(255, 255, 255, 0.15);
          }
  
          .mga-shop-sidebar-right.open {
              right: 0;
          }
  
          .mga-shop-sidebar-header {
              padding: 20px;
              border-bottom: 1px solid rgba(255, 255, 255, 0.57);
              display: flex;
              justify-content: space-between;
              align-items: center;
              background: rgba(20, 20, 20, 0.5);
          }
  
          .mgh-sidebar-header {
              padding: 20px;
              border-bottom: 1px solid rgba(255, 255, 255, 0.57);
              display: flex;
              justify-content: space-between;
              align-items: center;
          }
  
          .mgh-sidebar-title {
              font-size: 16px;
              font-weight: 600;
              color: white;
          }
  
          .mgh-sidebar-close {
              width: 32px;
              height: 32px;
              background: transparent;
              border: 1px solid rgba(255, 255, 255, 0.73);
              border-radius: 8px;
              color: rgba(255, 255, 255, 0.7);
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              font-size: 18px;
              transition: all 0.2s;
          }
  
          .mgh-sidebar-close:hover {
              background: rgba(255, 255, 255, 0.57);
              color: white;
          }
  
          .mgh-sidebar-body {
              flex: 1;
              padding: 20px;
              overflow-y: auto;
              color: white;
          }
  
          .mgh-sidebar-body::-webkit-scrollbar { width: 6px; }
          .mgh-sidebar-body::-webkit-scrollbar-thumb {
              background: rgba(255, 255, 255, 0.73);
              border-radius: 3px;
          }
  
          /* ==================== PRESERVE ORIGINAL MGA STYLES ==================== */
          .mga-btn {
              background: rgba(255, 255, 255, 0.57);
              border: 1px solid rgba(255, 255, 255, 0.73);
              color: #ffffff;
              padding: 6px 12px;
              border-radius: 6px;
              cursor: pointer;
              font-size: 13px;
              transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
              outline: none !important;
          }
  
          .mga-btn:hover {
              background: rgba(255, 255, 255, 0.2);
              border-color: rgba(74, 158, 255, 0.6);
              box-shadow: 0 0 12px rgba(74, 158, 255, 0.4);
          }
  
          .mga-input, .mga-select {
              background: rgba(255, 255, 255, 0.05);
              border: 1px solid rgba(255, 255, 255, 0.2);
              color: #ffffff;
              padding: 6px 12px;
              border-radius: 6px;
              font-size: 13px;
              font-family: inherit;
          }
  
          .mga-input:focus, .mga-select:focus {
              outline: none;
              border-color: rgba(102, 126, 234, 0.5);
              background: rgba(255, 255, 255, 0.08);
          }
  
          .mga-select option {
              background: rgba(20, 20, 20, 0.95);
              color: #ffffff;
              padding: 8px;
          }

          .mga-select option:hover {
              background: rgba(74, 158, 255, 0.3);
          }

          .mga-select optgroup {
              background: rgba(0, 0, 0, 0.5);
              color: #4a9eff;
              font-weight: bold;
              font-size: 11px;
              padding: 6px;
              border-top: 1px solid rgba(255, 255, 255, 0.57);
          }

          /* Shop item name colors */
          .shop-color-white { color: #ffffff !important; }
          .shop-color-green { color: #2afd23ff !important; }
          .shop-color-blue { color: #0084ffff !important; }
          .shop-color-yellow { color: #fced19ff !important; }
          .shop-color-purple { color: #774cb3 !important; }
          .shop-color-orange { color: #ff7300ff !important; }
  
          /* Rainbow text for celestial items */
          .shop-rainbow-text {
              background: linear-gradient(90deg,
                  #ff0000, #ff7b00, #ffd800, #3cff2a, #00b5ff, #774cb3, #ff2ab7, #ff0000);
              background-size: 200% 100%;
              background-repeat: repeat;
              -webkit-background-clip: text;
              background-clip: text;
              color: transparent !important;
              animation: shopRainbowShift 3s linear infinite;
              font-weight: 700;
              -webkit-font-smoothing: antialiased;
              -moz-osx-font-smoothing: grayscale;
          }
  
          @keyframes shopRainbowShift {
              0%   { background-position: 0% 50%; }
              100% { background-position: 200% 50%; }
          }

          /* ========== TEXTURE ANIMATIONS ========== */
          @keyframes textureSlowDrift {
              0%   { background-position: 0px 0px, 0 0; }
              100% { background-position: 200px 200px, 0 0; }
          }

          @keyframes hologramScan {
              0%   { background-position: 0 0, 0 0; }
              100% { background-position: 0 100%, 0 0; }
          }

          @keyframes energyPulse {
              0%   { background-position: 0% 0%, 0% 0%, 0% 0%, 0 0; }
              50%  { background-position: 100% 0%, 100% 100%, 0% 100%, 0 0; }
              100% { background-position: 0% 0%, 0% 0%, 0% 0%, 0 0; }
          }

          .mga-texture-animated {
              animation: textureSlowDrift 60s linear infinite;
          }
  
          /* Shop sprite sizing */
          .shop-sprite {
              width: 28px;
              height: 28px;
              border-radius: 6px;
              object-fit: contain;
              flex-shrink: 0;
              background: rgba(255, 255, 255, 0.02);
              transition: transform 0.12s ease, box-shadow 0.12s ease;
          }
  
          .shop-item.in-stock .shop-sprite {
              transform: scale(1.04);
              box-shadow: 0 4px 10px rgba(0, 255, 42, 0.07);
          }
  
          /* Original overlay styles preserved */
          .mga-overlay {
              position: fixed;
              background: rgba(17, 24, 39, 0.95);
              border: 1px solid rgba(255, 255, 255, 0.57);
              border-radius: 12px;
              padding: 20px;
              color: #ffffff;
              z-index: 10001;
              box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
          }
  
          /* Popout widget styles */
          .mgh-popout {
              font-family: 'Inter', sans-serif;
              position: fixed;
              background: rgba(10, 10, 10, 0.95);
              backdrop-filter: blur(20px);
              border: 1px solid rgba(255, 255, 255, 0.15);
              border-radius: 12px;
              box-shadow: 0 8px 32px rgba(0, 0, 0, 0.6);
              z-index: 1000000;
              min-width: 320px;
              width: 400px; /* Default width, resizable */
              height: 400px; /* Default height, resizable */
              display: flex;
              flex-direction: column;
              /* No transition for instant drag response */
          }
  
          .mgh-popout-header {
              padding: 12px 16px;
              border-bottom: 1px solid rgba(255, 255, 255, 0.57);
              display: flex;
              align-items: center;
              justify-content: space-between;
              cursor: grab;
              user-select: none;
              background: rgba(20, 20, 20, 0.5);
              flex-shrink: 0;
          }
  
          .mgh-popout-header:active {
              cursor: grabbing;
          }
  
          .mgh-popout-body {
              padding: 16px;
              color: white;
              flex: 1;
              min-height: 0;
              overflow-y: auto;
          }
  
          /* ==================== PET MANAGEMENT STYLES ==================== */
          .mga-section {
              margin-bottom: 20px;
          }
  
          .mga-section-title {
              font-size: 14px;
              font-weight: 600;
              color: rgba(255, 255, 255, 0.9);
              margin-bottom: 12px;
              padding-bottom: 8px;
              border-bottom: 1px solid rgba(255, 255, 255, 0.57);
          }
  
          .mga-pet-section-title {
              background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
              -webkit-background-clip: text;
              -webkit-text-fill-color: transparent;
              background-clip: text;
          }
  
          /* Active Pets Display */
          .mga-active-pets-display {
              background: rgba(255, 255, 255, 0.03);
              border: 1px solid rgba(255, 255, 255, 0.57);
              border-radius: 8px;
              padding: 12px;
              margin-bottom: 12px;
          }
  
          .mga-active-pets-header {
              color: #93c5fd;
              font-size: 12px;
              margin-bottom: 8px;
              font-weight: 500;
          }
  
          .mga-active-pets-list {
              display: flex;
              flex-wrap: wrap;
              gap: 8px;
          }
  
          .mga-pet-slot {
              display: flex;
              flex-direction: column;
              align-items: center;
              gap: 4px;
          }
  
          .mga-pet-badge {
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              color: white;
              padding: 6px 12px;
              border-radius: 6px;
              font-size: 12px;
              font-weight: 600;
              white-space: nowrap;
              box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
              transition: all 0.2s ease;
          }
  
          .mga-pet-badge:hover {
              transform: translateY(-2px);
              box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
          }
  
          .mga-hunger-timer {
              font-size: 11px;
              font-weight: 600;
              padding: 2px 6px;
              border-radius: 4px;
              background: rgba(0, 0, 0, 0.48);
          }
  
          /* Pet Presets */
          .mga-presets-container {
              display: flex;
              flex-direction: column;
              gap: 8px;
          }
  
          .mga-preset {
              background: rgba(255, 255, 255, 0.05);
              border: 1px solid rgba(255, 255, 255, 0.57);
              border-radius: 8px;
              padding: 12px;
              transition: all 0.2s ease;
          }
  
          .mga-preset-clickable {
              cursor: pointer;
          }
  
          .mga-preset-clickable:hover {
              background: rgba(255, 255, 255, 0.55);
              border-color: #667eea;
              transform: translateY(-2px);
              box-shadow: 0 4px 12px rgba(102, 126, 234, 0.48);
          }
  
          .mga-preset-header {
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 8px;
          }
  
          .mga-preset-name {
              font-size: 13px;
              font-weight: 600;
              color: #93c5fd;
          }
  
          .mga-preset-pets {
              font-size: 12px;
              color: rgba(255, 255, 255, 0.7);
              line-height: 1.5;
          }
  
          /* Empty State */
          .mga-empty-state {
              text-align: center;
              padding: 24px;
              color: rgba(255, 255, 255, 0.5);
          }
  
          .mga-empty-state-icon {
              font-size: 32px;
              margin-bottom: 8px;
              opacity: 0.5;
          }
  
          .mga-empty-state-title {
              font-size: 14px;
              font-weight: 600;
              color: rgba(255, 255, 255, 0.7);
              margin-bottom: 6px;
          }
  
          .mga-empty-state-description {
              font-size: 12px;
              color: rgba(255, 255, 255, 0.5);
              line-height: 1.5;
          }
  
          /* Scrollable containers */
          .mga-scrollable {
              overflow-y: auto;
          }
  
          .mga-scrollable::-webkit-scrollbar {
              width: 6px;
          }
  
          .mga-scrollable::-webkit-scrollbar-track {
              background: rgba(255, 255, 255, 0.05);
              border-radius: 3px;
          }
  
          .mga-scrollable::-webkit-scrollbar-thumb {
              background: rgba(255, 255, 255, 0.73);
              border-radius: 3px;
          }
  
          .mga-scrollable::-webkit-scrollbar-thumb:hover {
              background: rgba(255, 255, 255, 0.3);
          }
      `;
  
      /* CHECKPOINT removed: GLOBAL_STYLES_COMPLETE */
  
      // ==================== DEBUG SYSTEM ====================
  
      // Production flag to minimize script size by removing debug logs
      // NOTE: To enable production mode and remove ~500 console.log statements:
      // 1. Change PRODUCTION to true below
      // 2. Replace all 'productionLog(' with 'productionLog(' in the script
      // 3. Replace all 'productionWarn(' with 'productionWarn(' in the script
      // 4. Replace all 'console.error(' with 'productionError(' in the script
      // This can save ~100-150KB in script size for better performance
      const PRODUCTION = true; // OPTIMIZED: Enabled to dramatically improve FPS
  
      const DEBUG_FLAGS = {
          OVERLAY_LIFECYCLE: false,  // Disabled to reduce console spam
          HANDLER_SETUP: false,      // Disabled to reduce console spam
          THEME_APPLICATION: false,
          VALUE_CALCULATIONS: false,
          ABILITY_LOGS: false,
          BUTTON_INTERACTIONS: false,
          POP_OUT_DESIGN: false,
          ERROR_TRACKING: true,      // Keep error tracking enabled
          PERFORMANCE: false
      };
  
      // Note: productionLog, productionWarn, productionError are defined at top of file (line 26-29)
  
      // Optimized debugLog - no-op in production mode
      function debugLog(category, message, data = null) {
          if (!PRODUCTION && DEBUG_FLAGS[category]) {
              const timestamp = new Date().toLocaleTimeString();
              productionLog(`[MGA-DEBUG-${category}] ${timestamp} ${message}`, data || '');
          }
      }
  
      function debugError(category, message, error, context = {}) {
          if (DEBUG_FLAGS[category] || DEBUG_FLAGS.ERROR_TRACKING) {
              const timestamp = new Date().toLocaleTimeString();
              productionError(`[MGA-ERROR-${category}] ${timestamp} ${message}`, {
                  error: error,
                  context: context,
                  stack: error?.stack
              });
          }
      }
  
      /* CHECKPOINT removed: DEBUG_SYSTEM_COMPLETE */
  
      // ==================== RESPONSIVE TEXT SCALING ====================
  // Efficient, smooth text scaling using transform instead of recalculating fonts
  function applyResponsiveTextScaling(overlay, width, height) {
      try {
          const baseWidth = 400;
          const baseHeight = 300;
  
          const widthScale = width / baseWidth;
          const heightScale = height / baseHeight;
          const scale = Math.min(widthScale, heightScale);
  
          // Clamp to reasonable values
          const clampedScale = Math.max(0.7, Math.min(1.3, scale));
  
          // Apply smooth GPU scaling to the overlay‚Äôs inner content
          let content = overlay.querySelector('.mga-content');
          if (content) {
              content.style.transformOrigin = "top left";
              content.style.transform = `scale(${clampedScale})`;
          }
      } catch (error) {
          debugError('OVERLAY_LIFECYCLE', 'Failed to apply transform-based scaling', error, {
              overlayId: overlay.id,
              width,
              height
          });
      }
  }
  
  
      // ==================== UNIFIED STATE ====================
      // Global initialization mutex to prevent double initialization
      // Clear any stale flags from previous page load (refresh fix)
      // On normal refresh, these flags shouldn't persist, but Tampermonkey timing can cause race conditions
      const now = Date.now();
      const flagTimestamp = window._MGA_TIMESTAMP || 0;
      const flagAge = now - flagTimestamp;
  
      // If flags are older than 5 seconds, they're stale from a previous load
      if (flagAge > 5000) {
          productionLog('üîÑ Detected stale initialization flags, clearing...');
          try {
              delete window._MGA_INITIALIZING;
          } catch (e) {
              window._MGA_INITIALIZING = undefined;
          }
          try {
              delete window._MGA_INITIALIZED;
          } catch (e) {
              window._MGA_INITIALIZED = undefined;
          }
          try {
              delete window._MGA_TIMESTAMP;
          } catch (e) {
              window._MGA_TIMESTAMP = undefined;
          }
      }
  
      const forceInit = targetWindow.location.search.includes('force=true') || window._MGA_FORCE_INIT;
  
      if ((window._MGA_INITIALIZING || window._MGA_INITIALIZED) && !forceInit) {
          productionLog('üîí MGA already initializing or initialized, stopping duplicate execution');
          productionLog('üí° Use ?force=true in URL or MGA.forceInit() to re-initialize');
          return;
      }
  
      // Clear flags if forcing re-initialization
      if (forceInit) {
          productionLog('üîÑ Force initialization requested - clearing existing flags');
          window._MGA_INITIALIZED = false;
          window._MGA_FORCE_INIT = false;
      }
  
      // Set flags with timestamp
      window._MGA_INITIALIZING = true;
      window._MGA_TIMESTAMP = now;
  
      // ==================== DEFERRED CONFLICT DETECTION ====================
      // Conflict detection moved to after game initialization to prevent loading stalls
  
      // ==================== DECOR CATALOG ====================
      // Decor items available in the hourly decoration shop
      const DECOR_ITEMS = [
          // Rocks
          { id: 'SmallRock', name: 'Small Garden Rock', category: 'Rocks' },
          { id: 'MediumRock', name: 'Medium Garden Rock', category: 'Rocks' },
          { id: 'LargeRock', name: 'Large Garden Rock', category: 'Rocks' },
          // Wood Items
          { id: 'WoodBench', name: 'Wood Bench', category: 'Wood' },
          { id: 'WoodArch', name: 'Wood Arch', category: 'Wood' },
          { id: 'WoodBridge', name: 'Wood Bridge', category: 'Wood' },
          { id: 'WoodLampPost', name: 'Wood Lamp Post', category: 'Wood' },
          { id: 'WoodOwl', name: 'Wood Owl', category: 'Wood' },
          { id: 'WoodBirdhouse', name: 'Wood Birdhouse', category: 'Wood' },
          // Stone Items
          { id: 'StoneBench', name: 'Stone Bench', category: 'Stone' },
          { id: 'StoneArch', name: 'Stone Arch', category: 'Stone' },
          { id: 'StoneBridge', name: 'Stone Bridge', category: 'Stone' },
          { id: 'StoneLampPost', name: 'Stone Lamp Post', category: 'Stone' },
          { id: 'StoneGnome', name: 'Stone Gnome', category: 'Stone' },
          { id: 'StoneBirdbath', name: 'Stone Birdbath', category: 'Stone' },
          // Marble Items
          { id: 'MarbleBench', name: 'Marble Bench', category: 'Marble' },
          { id: 'MarbleArch', name: 'Marble Arch', category: 'Marble' },
          { id: 'MarbleBridge', name: 'Marble Bridge', category: 'Marble' },
          { id: 'MarbleLampPost', name: 'Marble Lamp Post', category: 'Marble' }
      ];
  
      const UnifiedState = {
          initialized: false,
          connectionStatus: false,
          panels: {
              main: null,
              toggle: null
          },
          activeTab: 'pets',
          // Interval Management System
          intervals: {
              autoDelete: null,
              heartbeat: null,
              activitySimulator: null,
              gameCheck: null,
              connectionCheck: null,
              autoSave: null
          },
          popoutWindows: new Set(), // Track all popout windows
          firebase: {
              app: null,
              database: null,
              reportInterval: null,
              unsubscribe: null
          },
          data: {
              petPresets: {},
              petPresetsOrder: [],  // Array to maintain preset display order
              petAbilityLogs: [],
              seedsToDelete: [],
              autoDeleteEnabled: false,
              inventoryValue: 0,
              gardenValue: 0,
              tileValue: 0,
              lastAbilityTimestamps: {},
              roomStatus: {
                  counts: {}, // Store room counts {MG1: 3, MG2: 2, ...}
                  currentRoom: null,
                  reporterId: null
              },
              customRooms: [], // Dynamic list of tracked rooms (initialized with defaults below)
              timers: {
                  seed: null,
                  egg: null,
                  tool: null,
                  lunar: null
              },
              settings: {
                  opacity: 95,
                  popoutOpacity: 50,
                  theme: 'default',
                  gradientStyle: 'blue-purple',
                  effectStyle: 'none',
                  compactMode: false,
                  ultraCompactMode: false,
                  useInGameOverlays: true,
                  notifications: {
                      enabled: true,
                      volume: 0.3,
                      notificationType: 'epic',  // Options: 'simple', 'triple', 'alarm', 'epic', 'continuous'
                      requiresAcknowledgment: false,
                      continuousEnabled: false,  // Controls whether continuous option is available
                      watchedSeeds: ["Carrot", "Sunflower", "Moonbinder", "Dawnbinder", "Starweaver"],
                      watchedEggs: ["CommonEgg", "MythicalEgg"],
                      watchedDecor: [], // Decoration/hourly shop items
                      // Pet hunger notifications
                      petHungerEnabled: false,
                      petHungerThreshold: 25,  // Notify when hunger drops below this % (percentage of observed max)
                      petHungerSound: 'double',  // Different sound than shop notifications
                      // Ability trigger notifications
                      abilityNotificationsEnabled: false,
                      watchedAbilities: [],  // Legacy - kept for backward compatibility
                      watchedAbilityCategories: {  // Category-based notification control
                          xpBoost: true,
                          cropSizeBoost: true,
                          selling: true,
                          harvesting: true,
                          growthSpeed: true,
                          specialMutations: true,
                          other: true
                      },
                      abilityNotificationSound: 'single',  // 'single', 'double', 'triple', 'chime', 'alert', 'buzz', 'ding', 'chirp'
                      abilityNotificationVolume: 0.2,  // Separate volume for abilities (quieter by default)
                      // Weather event notifications
                      weatherNotificationsEnabled: false,
                      watchedWeatherEvents: ['Snow', 'Rain', 'AmberMoon', 'Dawn'],
                      // Shop UI Firebase integration toggle
                      shopFirebaseEnabled: false,
                      lastSeenTimestamps: {}
                  },
                  detailedTimestamps: true,  // Show HH:MM:SS 24-hour format instead of 12-hour AM/PM
                  debugMode: false,  // Enable debug logging for troubleshooting
                  hideWeather: false,  // Hide weather visual effects (snow, rain, etc)
                  autoFavorite: {
                      enabled: false,
                      species: [],  // List of species names to auto-favorite
                      mutations: []  // List of mutations to auto-favorite (Rainbow, Gold, Frozen, etc)
                  }
              },
              hotkeys: {
                  enabled: true,
                  gameKeys: {
                      inventory: { name: 'Open Inventory', original: 'e', custom: null },
                      harvest: { name: 'Harvest/Select', original: ' ', custom: null },
                      selectLeft: { name: 'Select Left Crop', original: 'x', custom: null },
                      selectRight: { name: 'Select Right Crop', original: 'c', custom: null },
                      hotbar1: { name: 'Hotbar Slot 1', original: '1', custom: null },
                      hotbar2: { name: 'Hotbar Slot 2', original: '2', custom: null },
                      hotbar3: { name: 'Hotbar Slot 3', original: '3', custom: null },
                      hotbar4: { name: 'Hotbar Slot 4', original: '4', custom: null },
                      hotbar5: { name: 'Hotbar Slot 5', original: '5', custom: null },
                      hotbar6: { name: 'Hotbar Slot 6', original: '6', custom: null },
                      hotbar7: { name: 'Hotbar Slot 7', original: '7', custom: null },
                      hotbar8: { name: 'Hotbar Slot 8', original: '8', custom: null },
                      hotbar9: { name: 'Hotbar Slot 9', original: '9', custom: null },
                      teleportShop: { name: 'Teleport to Shop', original: 'shift+1', custom: null },
                      teleportGarden: { name: 'Teleport to Garden', original: 'shift+2', custom: null },
                      teleportSell: { name: 'Teleport to Sell', original: 'shift+3', custom: null },
                      toggleQuickShop: { name: 'Toggle Quick Shop', original: 'ctrl+b', custom: null }
                  },
                  mgToolsKeys: {
                      openPets: { name: 'Open Pets Tab', custom: null },
                      openAbilities: { name: 'Open Abilities Tab', custom: null },
                      openSeeds: { name: 'Open Seeds Tab', custom: null },
                      openValues: { name: 'Open Values Tab', custom: null },
                      openTimers: { name: 'Open Timers Tab', custom: null },
                      openRooms: { name: 'Open Rooms Tab', custom: null },
                      openShop: { name: 'Open Shop Tab', custom: null }
                  }
              },
              petPresetHotkeys: {},
              popouts: {
                  overlays: new Map(), // Track in-game overlays (Alt+key)
                  windows: new Map(),  // Track separate windows
                  widgets: new Map()   // Track shift+click popout widgets
              },
              // PAL4-style filter system
              filterMode: 'categories', // categories, byPet, custom
              abilityFilters: {
                  xpBoost: true,
                  cropSizeBoost: true,
                  selling: true,
                  harvesting: true,
                  growthSpeed: true,
                  specialMutations: true,
                  other: true
              },
              customMode: {
                  selectedAbilities: {}
              },
              petFilters: {
                  selectedPets: {}
              }
          },
          atoms: {
              activePets: [], // Initialize as empty array to prevent null errors
              petAbility: null,
              inventory: null,
              currentCrop: null,
              friendBonus: 1,
              myGarden: null,
              quinoaData: null
          }
      };
  
      // Export UnifiedState for debugging and external access
      targetWindow.UnifiedState = UnifiedState;
  
      /* CHECKPOINT removed: UNIFIED_STATE_COMPLETE */

      // ==================== DEBUG FUNCTIONS ====================
      window.debugSettingsPersistence = function() {
          console.log('=== SETTINGS PERSISTENCE DEBUG ===');
          console.log('Current settings in memory:', UnifiedState.data.settings);
          console.log('Settings in GM storage:', GM_getValue('MGA_data'));
          console.log('Settings in localStorage:', localStorage.getItem('MGA_data'));
          console.log('Handlers attached:', {
              settings: !!document.querySelector('[data-handler-setup]'),
              count: document.querySelectorAll('[data-handler-setup]').length
          });
          console.log('===================================');
      };

      // Emergency save on page unload
      window.addEventListener('beforeunload', () => {
          // Force save all settings before page unload
          if (UnifiedState && UnifiedState.data) {
              try {
                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  productionLog('üö® Emergency save triggered on page unload');
              } catch (error) {
                  console.error('Emergency save failed:', error);
              }
          }
      });

      // ==================== ROOM STATUS & FIREBASE ====================
  
      const FIREBASE_CONFIG = {
          apiKey: "AIzaSyBfFW74PLBfLIpYj5dakmKar2wRpLu1ZOA",
          authDomain: "mg-rooms.firebaseapp.com",
          databaseURL: "https://mg-rooms-default-rtdb.firebaseio.com",
          projectId: "mg-rooms",
          storageBucket: "mg-rooms.firebasestorage.app",
          messagingSenderId: "175773159635",
          appId: "1:175773159635:web:6676c5a625c3fe1da74426"
      };
  
      const REPORT_INTERVAL = 5000; // Report room count every 5 seconds
      const DEFAULT_ROOMS = ['MG1', 'MG2', 'MG3', 'MG4', 'MG5', 'MG6', 'MG7', 'MG8', 'MG9', 'MG10', 'SLAY']; // Default tracked rooms
      const DISCORD_PLAY_ROOMS = ['play#1', 'play#2', 'play#3', 'play#4', 'play#5', 'play#6', 'play#7', 'play#8', 'play#9', 'play#10']; // Discord activity rooms
  
      // Detect if running in Discord environment
      function isDiscordEnvironment() {
          try {
              // Check if in Discord iframe or Discord-hosted URL
              const isIframe = window.location !== window.parent.location;
              const isDiscordHost = window.location.host.includes('discordsays.com') || window.location.host.endsWith('.discordsays.com');
              const isDiscordActivity = isIframe || isDiscordHost;

              if (UnifiedState.data.settings?.debugMode) {
                  productionLog('[Discord Detection]', {
                      isIframe,
                      isDiscordHost,
                      isDiscordActivity,
                      host: window.location.host
                  });
              }

              return isDiscordActivity;
          } catch (err) {
              console.error('Failed to detect Discord environment:', err);
              return false;
          }
      }
      // Get current room code from URL
      function getCurrentRoomCode() {
          try {
              const match = window.location.pathname.match(/\/r\/([^\/]+)/);
              return match ? match[1].toUpperCase() : null;
          } catch (err) {
              console.error('Failed to get room code:', err);
              return null;
          }
      }
  
      // Get actual player count from game's room state
      function getActualPlayerCount() {
          try {
              const roomState = targetWindow.MagicCircle_RoomConnection?.lastRoomStateJsonable;
              if (!roomState?.child?.data?.userSlots) {
                  if (UnifiedState.data.settings.debugMode) {
                      console.log('[Room Status] No userSlots data available', {
                          hasRoomConnection: !!targetWindow.MagicCircle_RoomConnection,
                          hasRoomState: !!roomState,
                          hasChild: !!roomState?.child,
                          hasData: !!roomState?.child?.data
                      });
                  }
                  return null;
              }
              const userSlots = roomState.child.data.userSlots;
              const count = userSlots.filter(slot => slot !== null && slot !== undefined).length;
              if (UnifiedState.data.settings.debugMode) {
                  console.log('[Room Status] Player count:', count, 'userSlots:', userSlots);
              }
              return count;
          } catch (err) {
              console.error('[Room Status] Failed to get player count:', err);
              return null;
          }
      }
  
      // Generate unique reporter ID
      function getReporterId() {
          if (!UnifiedState.data.roomStatus.reporterId) {
              if (typeof crypto !== 'undefined' && crypto.randomUUID) {
                  UnifiedState.data.roomStatus.reporterId = crypto.randomUUID();
              } else {
                  UnifiedState.data.roomStatus.reporterId = 'reporter_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
              }
          }
          return UnifiedState.data.roomStatus.reporterId;
      }
  
      // Load Firebase SDK and initialize with authentication
      
async function initializeFirebase() {
    // Replaced Firebase with /info poller stub - integrates with existing listener
    try {
        const firebase = {
            __useInfo: true,
            getDatabase(){ return {}; },
            ref(db, path){ return { path }; },
            onValue(refObj, callback){
                let abort = false;
                const fetchInfo = async (room) => {
                    try{
                        // Use getGameApiBaseUrl from global scope with fallback
                        const globalScope = (typeof unsafeWindow !== 'undefined' ? unsafeWindow : window);
                        const getApiBase = globalScope.getGameApiBaseUrl || (() => location.origin);
                        const apiBase = getApiBase();
                        const url = new URL(apiBase + '/info');
                        url.searchParams.set('room', room);
                        const res = await Network.fetch(url.toString(), {credentials:'include'});
                        if (!res.ok) throw new Error('HTTP '+res.status);
                        const j = await res.json().catch(()=>({}));
                        const online = (j?.players?.online ?? j?.players?.count ?? j?.online ?? j?.count ?? 0) || 0;
                        return { count: Number(online)||0, lastUpdate: Date.now(), reporter: getReporterId() };
                    }catch{ return { count: 0, lastUpdate: Date.now(), reporter: getReporterId() }; }
                };
                async function tick(){
                    if (abort) return;
                    const out = {};
                    for (const rc of UnifiedState.data.customRooms){
                        out[rc] = await fetchInfo(rc);
                    }
                    const snapshot = { val: () => out };
                    try{ callback(snapshot); }catch(e){ console.error('rooms onValue cb error', e); }
                }
                tick();
                const iv = setInterval(tick, 5000);
                return function unsubscribe(){ abort = true; clearInterval(iv); };
            },
            set(){ /* no-op in /info mode */ },
            onDisconnect(){ return { remove(){} }; }
        };
        productionLog('‚úÖ /info rooms mode enabled (Firebase stubbed)');
        return firebase;
    } catch (err){
        console.error('‚ùå initializeFirebase (/info) failed', err);
        return null;
    }
}

  
      // Start reporting current room's player count
      async function startRoomReporting(firebase) {
  if (firebase && firebase.__useInfo) { productionLog('‚ÑπÔ∏è rooms: /info mode, reporting disabled'); return; }

          if (!firebase) return;
  
          const roomCode = getCurrentRoomCode();
          if (!roomCode) return;
  
          UnifiedState.data.roomStatus.currentRoom = roomCode;
  
          try {
              const { ref, set, onDisconnect } = firebase;
              const currentRoomRef = ref(UnifiedState.firebase.database, `roomCounts/${roomCode}`);
  
              // Try to report immediately, with retry logic
              let count = getActualPlayerCount();
              let retryCount = 0;
              const maxRetries = 10;
  
              // If no data yet, retry every 500ms for up to 5 seconds
              while (count === null && retryCount < maxRetries) {
                  await new Promise(resolve => setTimeout(resolve, 500));
                  count = getActualPlayerCount();
                  retryCount++;
                  if (UnifiedState.data.settings.debugMode) {
                      console.log(`[Room Status] Retry ${retryCount}/${maxRetries} for ${roomCode}...`);
                  }
              }
  
              if (count === null) {
                  console.warn(`[Room Status] No player data available after ${maxRetries} retries for ${roomCode}`);
                  // Still start the interval reporting - it will catch it later
              } else {
                  await set(currentRoomRef, {
                      count: count,
                      lastUpdate: Date.now(),
                      reporter: getReporterId()
                  });
  
                  // Update local state immediately so user sees their own room count
                  if (!UnifiedState.data.roomStatus.counts) {
                      UnifiedState.data.roomStatus.counts = {};
                  }
                  UnifiedState.data.roomStatus.counts[roomCode] = count;
  
                  productionLog(`üìä Reported ${count} players in ${roomCode}`);
              }
  
              // Set up onDisconnect cleanup
              await onDisconnect(currentRoomRef).remove();
  
              // Start interval reporting
              // Debounced reporting: Only update Firebase if count actually changed
              let lastReportedCount = count !== null ? count : -1; // Initialize with actual count or -1 if no data yet
              let lastForceReportTime = Date.now();
              const FORCE_REPORT_INTERVAL = 60000; // Force report every 60 seconds even if no change
  
              UnifiedState.firebase.reportInterval = setInterval(async () => {
                  try {
                      const currentCount = getActualPlayerCount();
  
                      // Skip if we don't have valid data yet
                      if (currentCount === null) {
                          if (UnifiedState.data.settings.debugMode) {
                              console.log('[Room Status] Skipping report - no player data available yet');
                          }
                          return;
                      }
  
                      const now = Date.now();
                      const timeSinceLastReport = now - lastForceReportTime;
                      const shouldForceReport = timeSinceLastReport >= FORCE_REPORT_INTERVAL;
  
                      // Only report if count changed OR it's time for a forced update
                      if (currentCount === lastReportedCount && !shouldForceReport) {
                          return;
                      }
  
                      const previousCount = lastReportedCount;
                      lastReportedCount = currentCount;
                      lastForceReportTime = now;
  
                      await set(currentRoomRef, {
                          count: currentCount,
                          lastUpdate: now,
                          reporter: getReporterId()
                      });
  
                      // Update local state immediately
                      UnifiedState.data.roomStatus.counts[roomCode] = currentCount;
  
                      if (UnifiedState.data.settings.debugMode) {
                          console.log(`[Room Status] Reported count: ${currentCount} (changed from ${previousCount}, forced: ${shouldForceReport})`);
                      }
                  } catch (err) {
                      console.error('Failed to report room count:', err);
                  }
              }, REPORT_INTERVAL);
  
          } catch (err) {
              console.error('Failed to start room reporting:', err);
          }
      }
  
      // Listen to all room counts
      function startRoomListener(firebase) {
          if (!firebase) return;
  
          try {
              const { ref, onValue } = firebase;
              const allRoomsRef = ref(UnifiedState.firebase.database, 'roomCounts');
  
              UnifiedState.firebase.unsubscribe = onValue(allRoomsRef, (snapshot) => {
                  const roomData = snapshot.val() || {};
                  productionLog('[Room Status] Received update from Firebase:', roomData);
  
                  // Update room counts - use the highest count from fresh data to prevent flickering
                  const counts = {};
                  UnifiedState.data.customRooms.forEach(roomCode => {
                      if (roomData[roomCode]) {
                          const age = Date.now() - (roomData[roomCode].lastUpdate || 0);
                          const newCount = age < 30000 ? (roomData[roomCode].count || 0) : 0;
  
                          // Use the higher of the new count or existing count (prevents flickering from 6->0->6)
                          // Only accept decreases if the data is very fresh (< 3s old) - prevents stale 0 reports from overwriting real data
                          const existingCount = UnifiedState.data.roomStatus.counts[roomCode] || 0;
                          if (newCount >= existingCount || age < 3000) {
                              counts[roomCode] = newCount;
                          } else {
                              counts[roomCode] = existingCount;
                          }
  
                          productionLog(`[Room Status] ${roomCode}: ${counts[roomCode]} players (new: ${newCount}, existing: ${existingCount}, age: ${Math.round(age/1000)}s)`);
                      } else {
                          counts[roomCode] = 0;
                      }
                  });
  
                  UnifiedState.data.roomStatus.counts = counts;
                  productionLog('[Room Status] Updated counts:', counts);
  
                  // Update display if rooms tab is active
                  updateRoomStatusDisplay();
              });
  
              productionLog('‚úÖ Listening to all room counts');
          } catch (err) {
              console.error('Failed to start room listener:', err);
          }
      }
  
      // Update room status display
      function updateRoomStatusDisplay() {
          const roomList = document.getElementById('room-status-list');
          if (!roomList) return;
  
          const currentRoom = getCurrentRoomCode();
          const roomCounts = UnifiedState.data.roomStatus.counts;
  
          roomList.innerHTML = UnifiedState.data.customRooms.map(roomCode => {
              const count = roomCounts[roomCode] || 0;
              const displayCount = Math.min(count, 6);
              const isCurrentRoom = roomCode === currentRoom;
  
              let statusColor = '#94a3b8';
              if (count > 0) statusColor = '#4ade80';
              if (count >= 4) statusColor = '#fbbf24';
              if (count >= 6) statusColor = '#ef4444';
  
              const bgColor = isCurrentRoom ? 'rgba(59, 130, 246, 0.40)' : 'rgba(255, 255, 255, 0.03)';
              const borderColor = isCurrentRoom ? '#3b82f6' : 'rgba(255, 255, 255, 0.57)';
  
              return `
                  <div class="room-item room-status-item" draggable="true" data-room="${roomCode}" data-room-code="${roomCode}" style="display: flex; align-items: center; justify-content: space-between; padding: 12px; background: ${bgColor}; border: 1px solid ${borderColor}; border-radius: 6px; transition: all 0.2s; cursor: grab !important; user-select: none;">
                      <div style="display: flex; align-items: center; gap: 12px; flex: 1; cursor: grab !important;">
                          <span style="color: #666; font-size: 16px; cursor: grab !important;" title="Drag to reorder">‚ãÆ‚ãÆ</span>
                          <span class="room-code" style="font-weight: bold; color: ${isCurrentRoom ? '#60a5fa' : '#e5e7eb'}; font-size: 14px; min-width: 45px; cursor: grab !important;">${roomCode}</span>
                          <span style="font-weight: bold; color: ${statusColor}; font-size: 13px; min-width: 50px; cursor: grab !important;">${displayCount}/6 ${isCurrentRoom ? '(You)' : ''}</span>
                      </div>
                      <div style="display: flex; gap: 8px; align-items: center;">
                          <button class="mga-button room-join-btn" data-room="${roomCode}" style="padding: 6px 14px; font-size: 12px; background: ${isCurrentRoom ? '#666' : '#4a9eff'}; color: white; border: none; border-radius: 4px; cursor: ${isCurrentRoom ? 'not-allowed' : 'pointer'} !important; opacity: ${isCurrentRoom ? '0.5' : '1'};" ${isCurrentRoom ? 'disabled' : ''}>
                              ${isCurrentRoom ? 'Current' : 'Join'}
                          </button>
                          <button class="room-delete-btn" data-room="${roomCode}" style="padding: 6px 10px; font-size: 14px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer !important; opacity: 0.8; transition: opacity 0.2s;" title="Remove room from list">
                              ‚ùå
                          </button>
                      </div>
                  </div>
              `;
          }).join('');
  
          // Re-attach event listeners
          setupRoomJoinButtons();
  
          // Update popout window if it exists
          refreshSeparateWindowPopouts('rooms');
      }
  
      // Setup join button handlers
      function setupRoomJoinButtons() {
          document.querySelectorAll('.room-join-btn:not([data-handler-attached])').forEach(btn => {
              btn.setAttribute('data-handler-attached', 'true');
              btn.addEventListener('click', () => {
                  const roomCode = btn.getAttribute('data-room');
                  const host = window.location.host;
                  window.location.href = `https://${host}/r/${roomCode}`;
              });
          });
  
          // Setup room search input - aggressive event blocking
          const searchInput = document.getElementById('room-search-input');
          if (searchInput && !searchInput.hasAttribute('data-handler-attached')) {
              searchInput.setAttribute('data-handler-attached', 'true');

              // Prevent game from stealing focus on ANY key
              let isFocused = false;
              searchInput.addEventListener('focus', () => { isFocused = true; });
              searchInput.addEventListener('blur', (e) => {
                  // Re-focus immediately if we're supposed to be focused
                  if (isFocused && searchInput.value.length >= 0) {
                      e.preventDefault();
                      setTimeout(() => searchInput.focus(), 0);
                  } else {
                      isFocused = false;
                  }
              });

              // Block ALL key events from reaching game - document level capture
              ['keydown', 'keypress', 'keyup'].forEach(eventType => {
                  document.addEventListener(eventType, (e) => {
                      if (e.target === searchInput || document.activeElement === searchInput) {
                          e.stopPropagation();
                          e.stopImmediatePropagation();
                      }
                  }, true);
              });
  
              searchInput.addEventListener('input', (e) => {
                  const query = e.target.value.trim().toUpperCase();
                  const roomList = document.getElementById('room-status-list');

                  // NEVER call updateTabContent() during typing - it rebuilds everything!

                  if (!query) {
                      // Show all rooms without rebuilding
                      const allRooms = document.querySelectorAll('.room-status-item');
                      allRooms.forEach(room => room.style.display = 'flex');

                      // Hide search result div if it exists
                      const searchResult = document.getElementById('room-search-result');
                      if (searchResult) searchResult.style.display = 'none';
                      return;
                  }

                  // Check if this is a tracked room
                  const isTrackedRoom = UnifiedState.data.customRooms.includes(query);

                  if (isTrackedRoom) {
                      // Filter tracked rooms WITHOUT rebuilding
                      const roomItems = document.querySelectorAll('.room-status-item');
                      roomItems.forEach(item => {
                          const roomCode = item.dataset.roomCode || item.querySelector('.room-code')?.textContent;
                          if (roomCode && roomCode.includes(query)) {
                              item.style.display = 'flex';
                          } else {
                              item.style.display = 'none';
                          }
                      });

                      // Hide search result if showing
                      const searchResult = document.getElementById('room-search-result');
                      if (searchResult) searchResult.style.display = 'none';
                  } else {
                      // Show search UI for non-tracked rooms
                      let searchResultDiv = document.getElementById('room-search-result');
                      if (!searchResultDiv) {
                          // Create the search result div once
                          searchResultDiv = document.createElement('div');
                          searchResultDiv.id = 'room-search-result';
                          roomList.insertBefore(searchResultDiv, roomList.firstChild);
                      }

                      const currentRoom = getCurrentRoomCode();
                      const roomCounts = UnifiedState.data.roomStatus?.counts || {};
                      const count = roomCounts[query] || 0;

                      searchResultDiv.innerHTML = `
                          <div style="padding: 12px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255, 255, 255, 0.73); border-radius: 6px; margin-bottom: 8px;">
                              <div style="display: flex; align-items: center; justify-content: space-between;">
                                  <div style="display: flex; align-items: center; gap: 12px;">
                                      <span style="font-weight: bold; color: #e5e7eb; font-size: 14px;">${query}</span>
                                      <span style="color: ${count > 0 ? '#4ade80' : '#94a3b8'}; font-size: 13px;">${count > 0 ? `${count} online` : 'No data'}</span>
                                  </div>
                                  <button class="mga-button" onclick="window.location.href='https://${window.location.host}/r/${query}'"
                                      style="padding: 6px 14px; font-size: 12px; background: #4a9eff; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                      Join
                                  </button>
                              </div>
                              <div style="font-size: 10px; color: #888; margin-top: 4px;">
                                  ${count > 0 ? 'At least one MGTools user is in this room' : 'Room may be empty or no MGTools users reporting'}
                              </div>
                          </div>
                      `;
                      searchResultDiv.style.display = 'block';

                      // Hide all tracked rooms
                      const roomItems = document.querySelectorAll('.room-status-item');
                      roomItems.forEach(item => item.style.display = 'none');
                  }
              });
          }
  
          // Setup add room button handler
          const addRoomBtn = document.getElementById('add-room-btn');
          const addRoomInput = document.getElementById('add-room-input');

          if (addRoomBtn && addRoomInput && !addRoomBtn.hasAttribute('data-handler-attached')) {
              addRoomBtn.setAttribute('data-handler-attached', 'true');

              const handleAddRoom = () => {
                  const roomCode = addRoomInput.value.trim().toUpperCase();

                  // Validate room code
                  if (!roomCode) {
                      alert('Please enter a room code');
                      return;
                  }

                  // Check if already exists
                  if (UnifiedState.data.customRooms.includes(roomCode)) {
                      alert(`Room "${roomCode}" is already in your list`);
                      return;
                  }

                  // Add to custom rooms
                  UnifiedState.data.customRooms.push(roomCode);
                  MGA_saveJSON('MGA_data', UnifiedState.data);

                  // Clear input
                  addRoomInput.value = '';

                  // Refresh display
                  updateRoomStatusDisplay();

                  productionLog(`[Rooms] Added custom room: ${roomCode}`);
              };

              addRoomBtn.addEventListener('click', handleAddRoom);

              // Also add on Enter key
              addRoomInput.addEventListener('keypress', (e) => {
                  if (e.key === 'Enter') {
                      handleAddRoom();
                  }
              });

              // Stop hotkeys from triggering when typing in add room input
              addRoomInput.addEventListener('keydown', (e) => {
                  e.stopPropagation();
              });
              addRoomInput.addEventListener('keyup', (e) => {
                  e.stopPropagation();
              });
              addRoomInput.addEventListener('keypress', (e) => {
                  e.stopPropagation();
              });
          }

          // Setup delete room button handlers
          document.querySelectorAll('.room-delete-btn:not([data-handler-attached])').forEach(btn => {
              btn.setAttribute('data-handler-attached', 'true');
              btn.addEventListener('click', (e) => {
                  e.stopPropagation(); // Don't trigger parent clicks

                  const roomCode = btn.getAttribute('data-room');

                  // Confirm deletion
                  if (!confirm(`Remove "${roomCode}" from your tracked rooms?`)) {
                      return;
                  }

                  // Remove from custom rooms
                  UnifiedState.data.customRooms = UnifiedState.data.customRooms.filter(code => code !== roomCode);
                  MGA_saveJSON('MGA_data', UnifiedState.data);

                  // Refresh display
                  updateRoomStatusDisplay();

                  productionLog(`[Rooms] Removed custom room: ${roomCode}`);
              });
          });

          // Setup drag-and-drop reordering
          let draggedElement = null;
          let draggedRoomCode = null;

          document.querySelectorAll('.room-item').forEach(item => {
              // Dragstart
              item.addEventListener('dragstart', (e) => {
                  draggedElement = item;
                  draggedRoomCode = item.getAttribute('data-room');
                  item.style.opacity = '0.5';
                  item.style.cursor = 'grabbing';
                  e.dataTransfer.effectAllowed = 'move';

                  // Create transparent 1x1 canvas to completely hide drag image
                  const canvas = document.createElement('canvas');
                  canvas.width = 1;
                  canvas.height = 1;
                  const ctx = canvas.getContext('2d');
                  ctx.clearRect(0, 0, 1, 1); // Transparent pixel

                  // Set as drag image (offset by -10, -10 to hide completely)
                  e.dataTransfer.setDragImage(canvas, -10, -10);
              });

              // Dragend
              item.addEventListener('dragend', (e) => {
                  item.style.opacity = '1';
                  item.style.cursor = 'grab';
                  draggedElement = null;
                  draggedRoomCode = null;
              });

              // Dragover
              item.addEventListener('dragover', (e) => {
                  e.preventDefault();
                  e.dataTransfer.dropEffect = 'move';

                  if (draggedElement && draggedElement !== item) {
                      // Visual feedback
                      item.style.borderTop = '2px solid #4a9eff';
                  }
              });

              // Dragleave
              item.addEventListener('dragleave', (e) => {
                  item.style.borderTop = '';
              });

              // Drop
              item.addEventListener('drop', (e) => {
                  e.preventDefault();
                  item.style.borderTop = '';

                  if (!draggedRoomCode || !draggedElement) return;

                  const targetRoomCode = item.getAttribute('data-room');

                  if (draggedRoomCode === targetRoomCode) return;

                  // Reorder the customRooms array
                  const newOrder = [...UnifiedState.data.customRooms];
                  const draggedIndex = newOrder.indexOf(draggedRoomCode);
                  const targetIndex = newOrder.indexOf(targetRoomCode);

                  if (draggedIndex === -1 || targetIndex === -1) return;

                  // Remove dragged item
                  newOrder.splice(draggedIndex, 1);

                  // Insert at new position
                  const insertIndex = draggedIndex < targetIndex ? targetIndex : targetIndex;
                  newOrder.splice(insertIndex, 0, draggedRoomCode);

                  // Update state
                  UnifiedState.data.customRooms = newOrder;
                  MGA_saveJSON('MGA_data', UnifiedState.data);

                  // Refresh display
                  updateRoomStatusDisplay();

                  productionLog(`[Rooms] Reordered: moved ${draggedRoomCode} to position ${insertIndex + 1}`);
              });
          });
      }

      // ==================== SIMPLE PET DETECTION ====================
      function getActivePetsFromRoomState() {
          productionLog('üîß [DEBUG] getActivePetsFromRoomState() called - checking for pets...');
          try {
              // CORRECT path: Get the actual atom value that console shows
              const roomState = targetWindow.MagicCircle_RoomConnection?.lastRoomStateJsonable;
              // Reduced logging for performance
              // productionLog('üîß [DEBUG] roomState available:', !!roomState, roomState?.child?.data ? 'data exists' : 'no data');
              if (!roomState?.child?.data) {
                  productionLog('üêæ [SIMPLE-PETS] No room state data');
                  return [];
              }
  
              // Debug: Log the actual structure (disabled for performance)
              // productionLog('üêæ [DEBUG] Actual roomState.child.data structure:', JSON.stringify(roomState.child.data, null, 2).substring(0, 500));
              // productionLog('üêæ [DEBUG] roomState.child.data keys:', Object.keys(roomState.child.data || {}));
  
              // Try multiple data sources in priority order
              let petData = null;
  
              // Source 1: Check if pet data is directly in child.data (field1, field2, field3 format)
              if (roomState.child.data.field1 !== undefined) {
                  petData = roomState.child.data;
                  productionLog('üêæ [SIMPLE-PETS] Found pet data in child.data directly');
              }
  
              // Source 2: No longer needed - using myPetSlotsAtom instead
              // Room state userSlots doesn't contain species info
  
              if (!petData) {
                  if (UnifiedState.data.settings?.debugMode) {
                      productionLog('üêæ [SIMPLE-PETS] No pet data found in room state');
                  }
  
                  // FALLBACK: Use atom data if available
                  if (window.activePets && window.activePets.length > 0) {
                      if (UnifiedState.data.settings?.debugMode) {
                          productionLog('üêæ [FALLBACK] Using pets from myPetSlotsAtom:', window.activePets);
                      }
                      return window.activePets;
                  }
  
                  if (UnifiedState.data.settings?.debugMode) {
                      productionLog('üêæ [SIMPLE-PETS] No pet data found in room state or atoms');
                  }
                  return [];
              }
  
              // Extract pets from field1, field2, field3 format (the actual console format)
              const pets = [];
              const fields = [petData.field1, petData.field2, petData.field3];
              fields.forEach((species, index) => {
                  if (species && species !== '' && typeof species === 'string') {
                      pets.push({ petSpecies: species, slot: index + 1 });
                  }
              });
  
              productionLog('üêæ [SIMPLE-PETS] Extracted pets:', pets);
              return pets;
          } catch (error) {
              productionLog('üêæ [SIMPLE-PETS] Error:', error.message);
              return [];
          }
      }
  
      function updateActivePetsFromRoomState() {
          // Removed excessive debug logging to improve performance
          // productionLog('üîß [DEBUG] updateActivePetsFromRoomState() called');
          const roomPets = getActivePetsFromRoomState();
          const previousCount = UnifiedState.atoms.activePets?.length || 0;
  
          // CRITICAL BUGFIX: Don't overwrite if we already have better data from atom hook
          // The atom gives us FULL pet data with hunger, abilities, etc.
          // Room state only gives us petSpecies and slot - incomplete data!
          if (window.activePets && window.activePets.length > 0 &&
              window.activePets[0] && window.activePets[0].hunger !== undefined) {
              // We have full atom data with hunger - preserve it!
              productionLog('üêæ [SIMPLE-PETS] Preserving existing full pet data from atom (has hunger)');
  
              // Only update species info if it's missing
              roomPets.forEach((roomPet, index) => {
                  if (window.activePets[index] && !window.activePets[index].petSpecies && roomPet.petSpecies) {
                      window.activePets[index].petSpecies = roomPet.petSpecies;
                      productionLog(`üêæ [SIMPLE-PETS] Added missing species ${roomPet.petSpecies} to slot ${index + 1}`);
                  }
              });
  
              UnifiedState.atoms.activePets = window.activePets;
              return window.activePets; // Return the good data
          }
  
          // Only use room state data if we have NO atom data or it's incomplete
          UnifiedState.atoms.activePets = roomPets;
          window.activePets = roomPets; // Expose globally for debugging (use window to avoid modifying page)
  
          const newCount = roomPets.length;
          if (newCount !== previousCount) {
              productionLog(`üêæ [SIMPLE-PETS] Pet count changed: ${previousCount} ‚Üí ${newCount}`);
  
              // Update UI if pets tab is active
              if (UnifiedState.activeTab === 'pets') {
                  const context = document.getElementById('mga-tab-content');
                  if (context && typeof updateActivePetsDisplay === 'function') {
                      updateActivePetsDisplay(context);
                  }
              }
          }
  
          return roomPets;
      }
  
      // ==================== INTERVAL MANAGEMENT ====================
      function setManagedInterval(name, callback, delay) {
          // Clear existing interval if it exists
          if (UnifiedState.intervals[name]) {
              clearInterval(UnifiedState.intervals[name]);
          }
  
          // Set new interval and store reference
          UnifiedState.intervals[name] = setInterval(callback, delay);
          debugLog('PERFORMANCE', `Created managed interval: ${name} (${delay}ms)`);
          return UnifiedState.intervals[name];
      }
  
      function clearManagedInterval(name) {
          if (UnifiedState.intervals[name]) {
              clearInterval(UnifiedState.intervals[name]);
              UnifiedState.intervals[name] = null;
              debugLog('PERFORMANCE', `Cleared managed interval: ${name}`);
          }
      }
  
      function clearAllManagedIntervals() {
          Object.keys(UnifiedState.intervals).forEach(name => {
              clearManagedInterval(name);
          });
          debugLog('PERFORMANCE', 'Cleared all managed intervals');
      }
  
      function trackPopoutWindow(popoutWindow) {
          UnifiedState.popoutWindows.add(popoutWindow);
  
          // Add cleanup listener
          popoutWindow.addEventListener('beforeunload', () => {
              UnifiedState.popoutWindows.delete(popoutWindow);
          });
      }
  
      function closeAllPopoutWindows() {
          UnifiedState.popoutWindows.forEach(window => {
              try {
                  window.close();
              } catch (e) {
                  debugError('PERFORMANCE', 'Error closing popout window', e);
              }
          });
          UnifiedState.popoutWindows.clear();
      }
  
      /* CHECKPOINT removed: INTERVAL_MANAGEMENT_COMPLETE */
  
      // ==================== ENVIRONMENT DETECTION ====================
      function detectEnvironment() {
          const environment = {
              isGameEnvironment: false,
              isStandalone: false,
              isDiscordEmbed: false,
              gameReady: false,
              url: targetWindow.location.href,
              hasJotaiAtoms: !!((targetWindow.jotaiAtomCache?.cache || targetWindow.jotaiAtomCache)?.size > 0),
              hasMagicCircleConnection: !!(targetWindow.MagicCircle_RoomConnection && typeof targetWindow.MagicCircle_RoomConnection === 'object'),
              domain: targetWindow.location.hostname,
              readyState: document.readyState
          };
  
          // DEBUG: Log environment details at start
          productionLog('üîç [ENV-DEBUG] Detecting environment:', {
              domain: environment.domain,
              pathname: targetWindow.location.pathname,
              url: environment.url,
              hasAtoms: environment.hasJotaiAtoms,
              hasConnection: environment.hasMagicCircleConnection
          });
  
          // PRIORITY FIX: Check for game environment FIRST (before Discord check)
          // This ensures that when running inside game iframe in Discord, we detect game mode
          const gameHosts = ['magiccircle.gg', 'magicgarden.gg', 'starweaver.org', 'discordsays.com'];
          const isGameDomain = gameHosts.some(host => environment.domain.includes(host));
          const hasGamePath = targetWindow.location.pathname.includes('/r/');
          const isDiscordActivity = environment.domain.includes('discordsays.com');
  
          productionLog('üîç [ENV-DEBUG] Game checks:', {
              isGameDomain,
              hasGamePath,
              isDiscordActivity,
              willEnterGameMode: isGameDomain && (hasGamePath || isDiscordActivity)
          });

          // Game environment: Regular game domains with /r/ path OR Discord Activities (no /r/ needed)
          if (isGameDomain && (hasGamePath || isDiscordActivity)) {
              // We're in the game environment (works in Discord iframes, standalone, and everywhere)
              const isInIframe = window.location !== window.parent.location;
              const isDiscordDesktopApp = window.DiscordNative !== undefined;

              productionLog('üéÆ [ENV] Running in game environment:', environment.domain);
              if (isDiscordActivity) {
                  productionLog('üéÆ [DISCORD-ACTIVITY] Detected Discord Activity iframe!');
              }
              productionLog('üéÆ [ENV] IsIframe:', isInIframe, '| DiscordNative:', isDiscordDesktopApp);
              environment.isGameEnvironment = true;
              environment.isStandalone = false;
              environment.gameReady = environment.hasJotaiAtoms && environment.hasMagicCircleConnection && document.readyState === 'complete';
  
              // Determine initialization strategy
              let initStrategy = 'unknown';
              if (environment.gameReady) {
                  initStrategy = 'game-ready';
              } else {
                  initStrategy = 'game-wait';
              }
              environment.initStrategy = initStrategy;
  
              return environment;
          }
  
          // Check if we're on Discord page (not in game iframe)
          const isDiscordDomain = environment.domain.includes('discord.com');
          if (isDiscordDomain) {
              environment.isDiscordEmbed = true;
              productionLog('üéÆ [DISCORD] Running on Discord page - looking for game iframe...');
  
              // Try to find the game iframe (gameHosts already includes discordsays.com)
              const gameIframes = document.querySelectorAll('iframe');
              let foundGameIframe = false;
              for (const iframe of gameIframes) {
                  try {
                      const iframeSrc = iframe.src || '';
                      // gameHosts includes all game domains plus discordsays.com
                      if (gameHosts.some(host => iframeSrc.includes(host))) {
                          productionLog('‚úÖ [DISCORD] Found game iframe:', iframeSrc);
                          productionLog('üí° [DISCORD] Script should be running inside that iframe');
                          foundGameIframe = true;
                      }
                  } catch (e) {
                      // Cross-origin iframe, can't access
                  }
              }
  
              if (foundGameIframe) {
                  productionLog('‚ö†Ô∏è [DISCORD] On Discord page - script will only run inside the game iframe, not on Discord page itself');
              } else {
                  productionLog('‚ö†Ô∏è [DISCORD] On Discord page but no game iframe found yet');
              }
  
              // Skip initialization on Discord page - only run inside the iframe
              environment.isStandalone = false;
              environment.initStrategy = 'skip';
              return environment;
          }
  
          // Not a game domain or Discord - standalone mode
          environment.isGameEnvironment = false;
          environment.isStandalone = true;
          environment.gameReady = false;
  
          // Determine initialization strategy
          let initStrategy = 'unknown';
          if (environment.gameReady) {
              initStrategy = 'game-ready';
          } else if (environment.isGameEnvironment) {
              initStrategy = 'game-wait';
          } else {
              initStrategy = 'standalone';
          }
  
          environment.initStrategy = initStrategy;
  

        // ==================== PLATFORM & DEVICE DETECTION ====================
        window.MGA_Platform = {
            // Platform detection
            isDiscord: /discord|overlay|electron/i.test(navigator.userAgent) ||
                       !!(window.DiscordNative || window.__discordApp),

            isMobile: /Mobile|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) ||
                      window.matchMedia?.('(max-width: 768px)').matches,

            isIframe: window !== window.top,

            isTouch: ('ontouchstart' in window) || (navigator.maxTouchPoints > 0),

            // Get current layout mode
            getLayout() {
                if (this.isMobile) return 'mobile';
                if (this.isDiscord) return 'discord';
                return 'desktop';
            },

            // Get UI scale factor based on platform
            getScaleFactor() {
                if (this.isMobile) return 0.85; // Smaller UI for mobile
                if (this.isDiscord) return 0.95; // Slightly smaller for Discord
                return 1.0; // Full size for desktop
            },

            // Apply responsive styles based on platform
            applyResponsiveStyles() {
                const layout = this.getLayout();
                const scale = this.getScaleFactor();

                const root = document.documentElement;
                root.style.setProperty('--mga-scale', scale.toString());
                root.style.setProperty('--mga-layout', layout);
                root.setAttribute('data-mga-platform', layout);

                productionLog(`[Platform] Detected: ${layout} (scale: ${scale}, touch: ${this.isTouch})`);
            },

            // Get optimized fetch timeout based on platform
            getFetchTimeout() {
                if (this.isMobile) return 8000; // Longer timeout for mobile networks
                if (this.isDiscord) return 6000; // Medium timeout for Discord
                return 5000; // Fast timeout for desktop
            },

            // Get UI animation duration based on platform
            getAnimationDuration() {
                if (this.isMobile) return 200; // Faster animations on mobile
                return 300; // Standard animations on desktop
            }
        };

        // Initialize platform detection
        MGA_Platform.applyResponsiveStyles();

        // Re-apply on resize (debounced)
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                // Re-check mobile status (window size may have changed)
                MGA_Platform.isMobile = /Mobile|Android|iPhone|iPad|iPod/i.test(navigator.userAgent) ||
                                        window.matchMedia?.('(max-width: 768px)').matches;
                MGA_Platform.applyResponsiveStyles();
            }, 250);
        });

        // Platform-specific initialization
        if (MGA_Platform.isDiscord) {
            productionLog('[Platform] Discord mode: External resources restricted, using bundled assets');
        }

        if (MGA_Platform.isMobile) {
            productionLog('[Platform] Mobile mode: Touch-optimized UI enabled');
        }

        if (MGA_Platform.isTouch) {
            productionLog('[Platform] Touch device detected: Increasing button tap targets');
        }

          return environment;
      }
  
      function createDemoData() {
          // Create realistic demo data for standalone mode
          const demoData = {
              pets: [
                  { petSpecies: 'Bunny', level: 15, abilities: ['Harvesting', 'Selling'], rarity: 'Common' },
                  { petSpecies: 'Dragon', level: 32, abilities: ['Growth Speed', 'Special Mutations'], rarity: 'Legendary' },
                  { petSpecies: 'Phoenix', level: 28, abilities: ['Selling', 'Harvesting'], rarity: 'Epic' },
                  { petSpecies: 'Unicorn', level: 21, abilities: ['Growth Speed', 'Harvesting'], rarity: 'Rare' }
              ],
              inventory: {
                  items: [
                      { species: 'Carrot', quantity: 145, value: 20 },
                      { species: 'Apple', quantity: 82, value: 73 },
                      { species: 'Banana', quantity: 23, value: 1750 },
                  { species: 'Dragon Fruit', quantity: 7, value: 15000 },
                  { species: 'Magic Beans', quantity: 3, value: 50000 }
              ],
              totalValue: 285450
          },
          garden: [
              { species: 'Carrot', quantity: 25, value: 15 },
              { species: 'Apple', quantity: 12, value: 65 },
              { species: 'Banana', quantity: 8, value: 1200 }
          ],
          totalValue: 295875,
          abilityLogs: [
              { timestamp: Date.now() - 300000, pet: 'Dragon', ability: 'Growth Speed', description: 'Reduced growth time by 15%' },
              { timestamp: Date.now() - 240000, pet: 'Bunny', ability: 'Harvesting', description: 'Extra harvest yield +2 items' },
              { timestamp: Date.now() - 180000, pet: 'Phoenix', ability: 'Selling', description: 'Increased selling price by 8%' },
              { timestamp: Date.now() - 120000, pet: 'Unicorn', ability: 'Growth Speed', description: 'Reduced growth time by 12%' },
              { timestamp: Date.now() - 60000, pet: 'Dragon', ability: 'Special Mutations', description: 'Triggered rare mutation chance' }
          ]
      };
  
      return demoData;
  }
  
  /* CHECKPOINT removed: ENVIRONMENT_DETECTION_COMPLETE */
  
  // ==================== UTILITIES ====================
  // MGA-specific storage functions using GM_setValue/GM_getValue for reliable persistence
  
  // ==================== GM STORAGE SYSTEM ====================
  // Reliable storage using Tampermonkey's GM API instead of unreliable localStorage
  
  function MGA_loadJSON(key, fallback = null, autoRecover = true) {
      // Enforce MGA_ namespace
      if (key && !String(key).startsWith('MGA_')) {
          console.error(`‚ùå [MGA-ISOLATION] CRITICAL: Attempted to load with non-MGA key: ${key}`);
          try { console.trace(); } catch (_){}
          key = 'MGA_' + key;
      }
      try {
          const gmAvailable = (typeof GM_getValue === 'function') && (typeof GM_setValue === 'function');
  
          // Collect ALL accessible localStorage contexts
          const lsMain = (typeof window !== 'undefined' && window && window.localStorage) ? window.localStorage : null;
          const lsTarg = (typeof targetWindow !== 'undefined' && targetWindow && targetWindow.localStorage) ? targetWindow.localStorage : null;
  
          const readLS = (ls, k) => {
              if (!ls) return null;
              try { return ls.getItem(k); } catch (e) { return null; }
          };
          const writeLS = (ls, k, v) => { try { if (ls) ls.setItem(k, v); } catch (e) {} };
  
          const toStr = (val) => (val == null ? null : (typeof val === 'string' ? val : JSON.stringify(val)));
          const tryParseDeep = (val) => {
              if (val == null) return null;
              if (typeof val === 'string') {
                  const s = val;
                  if (s === '' || s === 'null' || s === 'undefined') return null;
                  try {
                      let first = JSON.parse(s);
                      if (typeof first === 'string') {
                          try { first = JSON.parse(first); } catch (e) { /* keep as string */ }
                      }
                      return first;
                  } catch (e) { return null; }
              }
              if (typeof val === 'object') return val;
              return null;
          };
          const score = (obj) => {
              if (!obj) return -1;
              if (Array.isArray(obj)) return obj.length;
              if (typeof obj === 'object') return Object.keys(obj).length;
              return 0;
          };
  
          // Read raw values
          let gmRaw = null;
          try { gmRaw = gmAvailable ? GM_getValue(key, null) : null; } catch (e) {}
  
          const mainRaw = readLS(lsMain, key);
          const targRaw = readLS(lsTarg, key);
  
          // Parse candidates
          const gmParsed   = (typeof gmRaw === 'string' ? tryParseDeep(gmRaw) : tryParseDeep(toStr(gmRaw))) || null;
          const mainParsed = tryParseDeep(mainRaw) || tryParseDeep(toStr(mainRaw)) || null;
          const targParsed = tryParseDeep(targRaw) || tryParseDeep(toStr(targRaw)) || null;
  
          // Choose the best non-empty candidate
          const gmScore = score(gmParsed);
          const mnScore = score(mainParsed);
          const tgScore = score(targParsed);
  
          let best = null;
          let bestSrc = 'none';
          if (gmScore >= mnScore && gmScore >= tgScore) { best = gmParsed; bestSrc = 'GM'; }
          else if (mnScore >= gmScore && mnScore >= tgScore) { best = mainParsed; bestSrc = 'WIN'; }
          else { best = targParsed; bestSrc = 'TGT'; }
  
          // Debug breadcrumb for tough environments (non-fatal)
          try { productionLog(`üì¶ [STORAGE-CHOICE] ${key}: gm=${gmScore} win=${mnScore} tgt=${tgScore} chosen=${bestSrc}`); } catch (_){}
  
          if (best && (typeof best === 'object' || Array.isArray(best))) {
              const stable = JSON.stringify(best);
              try { if (gmAvailable) GM_setValue(key, stable); } catch (e) {}
              writeLS(lsMain, key, stable);
              writeLS(lsTarg, key, stable);
              return best;
          }
  
          // Nothing usable -> honor fallback
          return (typeof fallback === 'undefined') ? null : fallback;
      } catch (err) {
          console.error('‚ùå [MGA_loadJSON] Unexpected failure for key', key, err);
          return (typeof fallback === 'undefined') ? null : fallback;
      }
  }
  
  /* ==================== STORAGE SYNC (GM <-> localStorage) ==================== */
  /* ==================== STORAGE SYNC (GM <-> localStorage (both contexts)) ==================== */
  function MGA_syncStorageBothWays() {
      try {
          const keys = [
              'MGA_data',
              'MGA_petPresets',
              'MGA_petPresetsOrder',
              'MGA_petAbilityLogs',
              'MGA_petAbilityLogs_archive',
              'MGA_seedsToDelete',
              'MGA_autoDeleteEnabled',
              'MGA_filterMode',
              'MGA_abilityFilters',
              'MGA_customMode',
              'MGA_petFilters',
              'MGA_petPresetHotkeys',
              'MGA_hotkeys'
          ];
  
          const gmAvailable = (typeof GM_getValue === 'function') && (typeof GM_setValue === 'function');
  
          const lsMain = (typeof window !== 'undefined' && window && window.localStorage) ? window.localStorage : null;
          const lsTarg = (typeof targetWindow !== 'undefined' && targetWindow && targetWindow.localStorage) ? targetWindow.localStorage : null;
  
          const readLS = (ls, k) => { if (!ls) return null; try { return ls.getItem(k); } catch (e) { return null; } };
          const writeLS = (ls, k, v) => { try { if (ls) ls.setItem(k, v); } catch (e) {} };
  
          const toStr = (val) => (val == null ? null : (typeof val === 'string' ? val : JSON.stringify(val)));
          const tryParse = (s) => {
              if (s == null) return null;
              try {
                  const first = JSON.parse(s);
                  if (typeof first === 'string') {
                      try { return JSON.parse(first); } catch (e) { return first; }
                  }
                  return first;
              } catch (e) { return null; }
          };
          const score = (obj) => {
              if (!obj) return -1;
              if (Array.isArray(obj)) return obj.length;
              if (typeof obj === 'object') return Object.keys(obj).length;
              return 0;
          };
  
          keys.forEach((key) => {
              try {
                  const gmRaw   = gmAvailable ? GM_getValue(key, null) : null;
                  const mainRaw = readLS(lsMain, key);
                  const targRaw = readLS(lsTarg, key);
  
                  const gmParsed   = (typeof gmRaw === 'string' ? tryParse(gmRaw) : gmRaw) || tryParse(toStr(gmRaw));
                  const mainParsed = tryParse(mainRaw) || tryParse(toStr(mainRaw));
                  const targParsed = tryParse(targRaw) || tryParse(toStr(targRaw));
  
                  const gmScore = score(gmParsed);
                  const mnScore = score(mainParsed);
                  const tgScore = score(targParsed);
  
                  let best = null;
                  if (gmScore >= mnScore && gmScore >= tgScore) best = gmParsed;
                  else if (mnScore >= gmScore && mnScore >= tgScore) best = mainParsed;
                  else best = targParsed;
  
                  if (best && (typeof best === 'object' || Array.isArray(best))) {
                      const stable = JSON.stringify(best);
                      try { if (gmAvailable) GM_setValue(key, stable); } catch (e) {}
                      writeLS(lsMain, key, stable);
                      writeLS(lsTarg, key, stable);
                      productionLog(`üîÅ [STORAGE-SYNC] ${key}: canonicalized across GM/WIN/TGT`);
                  }
              } catch (innerErr) {
                  console.error('‚ùå [STORAGE-SYNC] Error while syncing key', key, innerErr);
              }
          });
      } catch (err) {
          console.error('‚ùå [STORAGE-SYNC] Sync failed:', err);
      }
  }
  
  
  
  function MGA_saveJSON(key, value, retryCount = 0) {
  // Dedupe guard for ability logs (same pet, ability, timestamp)
  try{
    if (key === 'MGA_petAbilityLogs' && Array.isArray(value)){
      const fp = (l)=>{
        const t=(l&&l.abilityType)||'', p=(l&&l.petName)||'', ts=(l&&l.timestamp)||0;
        return t+'|'+p+'|'+String(ts);
      };
      const map = new Map();
      for (const l of value){
        const id = l.id || fp(l);
        if (!map.has(id)) map.set(id, Object.assign({id}, l));
      }
      value = Array.from(map.values()).sort((a,b)=> (b.timestamp||0)-(a.timestamp||0));
    }
  }catch{}

      // CRITICAL: Ensure we never use MainScript keys
      if (key && !key.startsWith('MGA_')) {
          console.error(`‚ùå [MGA-ISOLATION] CRITICAL: Attempted to save with non-MGA key: ${key}`);
          console.error(`‚ùå [MGA-ISOLATION] This would conflict with MainScript! Adding MGA_ prefix.`);
          console.trace();
          key = 'MGA_' + key;
      }

      // PERSISTENCE GUARD v3.6.6: Warn if saving during initialization (prevents data loss from premature saves)
      if (window.MGA_PERSISTENCE_GUARD?.initializationSavesBlocked && key === 'MGA_data') {
          const stack = new Error().stack;
          if (stack && stack.includes('loadSavedData')) {
              console.warn('‚ö†Ô∏è [PERSISTENCE-GUARD] Premature save during initialization detected!');
              console.warn('‚ö†Ô∏è Only the final save at line ~23480 should execute during initialization.');
              console.warn('‚ö†Ô∏è Premature saves can overwrite complete user data with partial initialization data.');
              console.trace('Save attempted from within loadSavedData:');
          }
      }

      const MAX_RETRIES = 3;
      const RETRY_DELAY = 100;
  
      try {
          // Enhanced GM API availability check
          if (!isGMApiAvailable()) {
              // Warning already shown by isGMApiAvailable(), just use fallback silently
              return MGA_saveJSON_localStorage_fallback(key, value);
          }
  
          // Enhanced logging for critical operations
          if (key === 'MGA_petPresets' || key === 'MGA_seedsToDelete') {
              productionLog(`üíæ [GM-STORAGE] Attempting to save critical data: ${key} (attempt ${retryCount + 1}/${MAX_RETRIES})`);
              productionLog(`üíæ [GM-STORAGE] Data type:`, typeof value);
              productionLog(`üíæ [GM-STORAGE] Data content:`, value);
          }
  
          // GM can store objects directly, but let's use JSON for consistency and debugging
          const jsonString = JSON.stringify(value);
  
          // Save using GM_setValue for reliable persistence
          GM_setValue(key, jsonString);
          productionLog(`üíæ [GM-STORAGE] GM_setValue executed for ${key}`);
  
          // Enhanced verification with deep check
          const verification = GM_getValue(key, null);
          if (!verification) {
              console.error(`‚ùå [GM-STORAGE] Save verification failed for ${key} - no data retrieved!`);
  
              // Retry logic
              if (retryCount < MAX_RETRIES - 1) {
                  productionLog(`üîÑ [GM-STORAGE] Retrying save for ${key} in ${RETRY_DELAY}ms...`);
                  return new Promise((resolve) => {
                      setTimeout(() => {
                          resolve(MGA_saveJSON(key, value, retryCount + 1));
                      }, RETRY_DELAY);
                  });
              }
  
              // Final attempt failed - show user alert
              console.error(`‚ùå [GM-STORAGE] All retry attempts failed for ${key}`);
              if (key === 'MGA_petPresets' || key === 'MGA_seedsToDelete') {
                  alert(`‚ö†Ô∏è Failed to save ${key.replace('MGA_', '')}! Your changes may not persist.`);
              }
              return false;
          }
  
          // Deep verification for critical data
          if (key === 'MGA_petPresets' || key === 'MGA_seedsToDelete') {
              try {
                  const parsedVerification = JSON.parse(verification);
                  const originalKeys = Object.keys(value || {}).sort();
                  const savedKeys = Object.keys(parsedVerification || {}).sort();
  
                  if (JSON.stringify(originalKeys) !== JSON.stringify(savedKeys)) {
                      productionWarn(`‚ö†Ô∏è [GM-STORAGE] Data structure mismatch for ${key}, but save likely succeeded`);
                  }
  
                  productionLog(`‚úÖ [GM-STORAGE] Critical data verification passed for ${key}`);
              } catch (e) {
                  productionWarn(`‚ö†Ô∏è [GM-STORAGE] Could not deep verify ${key}, but data exists`);
              }
          }
  
          // Success logging
          if (key === 'MGA_petPresets') {
              productionLog('üíæ [GM-STORAGE] ‚úÖ Pet presets saved successfully');
          } else if (key.startsWith('MGA_')) {
              productionLog(`üíæ [GM-STORAGE] ‚úÖ Saved ${key}`);
          }
  
          return true;
  
      } catch (error) {
          console.error(`‚ùå [GM-STORAGE] Failed to save ${key}:`, error);
          console.error(`‚ùå [GM-STORAGE] Error details:`, {
              name: error.name,
              message: error.message,
              gmApiAvailable: typeof GM_setValue !== 'undefined',
              retryCount: retryCount
          });
  
          // BUGFIX: Auto-cleanup on storage quota errors (from v1.11.3)
          const errorString = ('' + error).toLowerCase();
          if (errorString.indexOf('quota') >= 0 || errorString.indexOf('exceeded') >= 0) {
              productionLog('üßπ [STORAGE-CLEANUP] Quota exceeded - auto-cleaning debug caches...');
              const dropKeys = ['console-history', 'mga-debug-cache', 'mga-temp-cache'];
              for (let i = 0; i < dropKeys.length; i++) {
                  try {
                      localStorage.removeItem(dropKeys[i]);
                      productionLog(`üßπ [STORAGE-CLEANUP] Removed: ${dropKeys[i]}`);
                  } catch (_e) {}
              }
              // Retry save after cleanup (one time only)
              if (retryCount === 0) {
                  productionLog(`üîÑ [STORAGE-CLEANUP] Retrying save after cleanup...`);
                  return MGA_saveJSON(key, value, 1);
              }
          }
  
          // Retry on error
          if (retryCount < MAX_RETRIES - 1) {
              productionLog(`üîÑ [GM-STORAGE] Retrying save for ${key} after error...`);
              return new Promise((resolve) => {
                  setTimeout(() => {
                      resolve(MGA_saveJSON(key, value, retryCount + 1));
                  }, RETRY_DELAY);
              });
          }
  
          return false;
      }
  }
  
  // Fallback function for when GM API is not available
  function MGA_saveJSON_localStorage_fallback(key, value) {
  // Dedupe for ability logs in fallback path too
  try{
    if (key === 'MGA_petAbilityLogs' && Array.isArray(value)){
      const fp = (l)=>{
        const t=(l&&l.abilityType)||'', p=(l&&l.petName)||'', ts=(l&&l.timestamp)||0;
        return t+'|'+p+'|'+String(ts);
      };
      const map = new Map();
      for (const l of value){ const id = l.id || fp(l); if (!map.has(id)) map.set(id, Object.assign({id}, l)); }
      value = Array.from(map.values()).sort((a,b)=> (b.timestamp||0)-(a.timestamp||0));
    }
  }catch{}

      try {
          const jsonString = JSON.stringify(value);
          localStorage.setItem(key, jsonString);
  
          // Simple verification
          const verification = localStorage.getItem(key);
          if (verification === jsonString) {
              productionLog(`üíæ [FALLBACK] Successfully saved ${key} to localStorage`);
              return true;
          } else {
              console.error(`‚ùå [FALLBACK] localStorage save verification failed for ${key}`);
              return false;
          }
      } catch (error) {
          // Check if it's a quota exceeded error
          const isQuotaError = error.name === 'QuotaExceededError' ||
                             error.message.includes('quota') ||
                             error.message.includes('exceeded');
  
          if (isQuotaError) {
              console.error(`‚ùå [FALLBACK] localStorage quota exceeded for ${key}!`);
              console.error(`üí° [FALLBACK] Try clearing browser console history or other localStorage data`);
              console.error(`üí° [FALLBACK] In Chrome DevTools: Application > Storage > Clear site data`);
  
              // Alert user for critical data
              if (key === 'MGA_petPresets' || key === 'MGA_seedsToDelete' || key === 'MGA_data') {
                  alert(`‚ö†Ô∏è localStorage quota exceeded!\n\nYour ${key.replace('MGA_', '')} cannot be saved.\n\nFix:\n1. Open DevTools (F12)\n2. Go to Application tab\n3. Click "Clear site data"\n4. Reload the page`);
              }
          } else {
              console.error(`‚ùå [FALLBACK] localStorage save failed for ${key}:`, error);
          }
          return false;
      }
  }
  
  // ==================== ABILITY NAME NORMALIZATION ====================
  // Fix malformed ability names (e.g., "Seed FinderII" ‚Üí "Seed Finder II")
  
  function normalizeAbilityName(name) {
      if (!name || typeof name !== 'string') return name;
  
      // Fix missing spaces before roman numerals
      let normalized = name
          .replace(/([a-z])III$/i, '$1 III')   // "FinderIII" ‚Üí "Finder III"
          .replace(/([a-z])II$/i, '$1 II')     // "FinderII" ‚Üí "Finder II"
          .replace(/([a-z])I$/i, '$1 I')       // "FinderI" ‚Üí "Finder I"
          .trim();
  
      // Log normalization if name was changed
      if (normalized !== name && UnifiedState.data.settings?.debugMode) {
          logDebug('ABILITY-LOGS', `üìù Normalized ability name: "${name}" ‚Üí "${normalized}"`);
      }
  
      return normalized;
  }
  
  // List of all known ability types for validation
  const KNOWN_ABILITY_TYPES = [
      // XP Boosts
      'XP Boost I', 'XP Boost II', 'XP Boost III',
      'Hatch XP Boost I', 'Hatch XP Boost II',
  
      // Crop Size Boosts
      'Crop Size Boost I', 'Crop Size Boost II',
  
      // Selling
      'Sell Boost I', 'Sell Boost II', 'Sell Boost III',
      'Coin Finder I', 'Coin Finder II',
  
      // Harvesting
      'Harvesting', 'Auto Harvest',
  
      // Growth Speed
      'Plant Growth Boost I', 'Plant Growth Boost II', 'Plant Growth Boost III',
      'Egg Growth Boost I', 'Egg Growth Boost II',
  
      // Seeds
      'Seed Finder I', 'Seed Finder II',
      'Special Mutations',
  
      // Other
      'Hunger Boost I', 'Hunger Boost II',
      'Max Strength Boost I', 'Max Strength Boost II'
  ];
  
  function isKnownAbilityType(abilityType) {
      if (!abilityType) return false;
      return KNOWN_ABILITY_TYPES.includes(abilityType);
  }
  
  // ==================== ABILITY LOGS DIAGNOSTIC SYSTEM ====================
  // Comprehensive diagnostic function to identify persistent ability log sources
  
  function MGA_diagnoseAbilityLogStorage() {
      logDebug('ABILITY-LOGS', 'üîç Starting comprehensive ability log storage diagnostic...');
  
      const report = {
          timestamp: new Date().toISOString(),
          sources: {}
      };
  
      // Helper to safely get storage
      const safeGet = (fn, label) => {
          try {
              return fn();
          } catch (e) {
              logDebug('ABILITY-LOGS', `  ‚ùå ${label}: Error - ${e.message}`);
              return null;
          }
      };
  
      // Helper to parse and count logs with detailed fingerprinting
      const parseAndCount = (raw, label) => {
          if (!raw) return { exists: false, count: 0, logs: [] };
          try {
              const parsed = typeof raw === 'string' ? JSON.parse(raw) : raw;
              const count = Array.isArray(parsed) ? parsed.length : 0;
  
              if (Array.isArray(parsed)) {
                  // Create detailed log fingerprints for identification
                  const logs = parsed.map(l => {
                      const abilityType = l.abilityType || 'unknown';
                      const normalizedAbility = normalizeAbilityName(abilityType);
                      const isKnown = isKnownAbilityType(normalizedAbility);
                      const isMalformed = abilityType !== normalizedAbility;
  
                      return {
                          ability: abilityType,
                          normalizedAbility: isMalformed ? normalizedAbility : null,
                          isKnown,
                          isMalformed,
                          pet: l.petName || l.petSpecies || 'unknown',
                          timestamp: l.timestamp,
                          time: new Date(l.timestamp).toLocaleString(),
                          // Create a unique fingerprint for this log
                          fingerprint: `${abilityType}_${l.petName}_${l.timestamp}`.substring(0, 50)
                      };
                  });
  
                  const malformedCount = logs.filter(l => l.isMalformed).length;
                  const unknownCount = logs.filter(l => !l.isKnown).length;
  
                  return {
                      exists: true,
                      count,
                      logs,
                      malformedCount,
                      unknownCount
                  };
              } else {
                  return { exists: true, count: 'not-an-array', logs: [] };
              }
          } catch (e) {
              return { exists: true, count: 'parse-error', logs: [], error: e.message };
          }
      };
  
      // 1. GM Storage (Tampermonkey)
      const gmMain = safeGet(() => GM_getValue('MGA_petAbilityLogs', null), 'GM Main');
      const gmArchive = safeGet(() => GM_getValue('MGA_petAbilityLogs_archive', null), 'GM Archive');
      report.sources.gmStorage = {
          main: parseAndCount(gmMain, 'GM Main'),
          archive: parseAndCount(gmArchive, 'GM Archive')
      };
  
      // 2. Window localStorage
      const lsMain = safeGet(() => window.localStorage?.getItem('MGA_petAbilityLogs'), 'LS Main');
      const lsArchive = safeGet(() => window.localStorage?.getItem('MGA_petAbilityLogs_archive'), 'LS Archive');
      const lsClearFlag = safeGet(() => window.localStorage?.getItem('MGA_logs_manually_cleared'), 'LS Clear Flag');
      report.sources.windowLocalStorage = {
          main: parseAndCount(lsMain, 'LS Main'),
          archive: parseAndCount(lsArchive, 'LS Archive'),
          clearFlag: lsClearFlag
      };
  
      // 3. TargetWindow localStorage (if different from window)
      if (typeof targetWindow !== 'undefined' && targetWindow && targetWindow !== window) {
          const tgMain = safeGet(() => targetWindow.localStorage?.getItem('MGA_petAbilityLogs'), 'TG Main');
          const tgArchive = safeGet(() => targetWindow.localStorage?.getItem('MGA_petAbilityLogs_archive'), 'TG Archive');
          report.sources.targetWindowLocalStorage = {
              main: parseAndCount(tgMain, 'TG Main'),
              archive: parseAndCount(tgArchive, 'TG Archive')
          };
      }
  
      // 4. MGA_data nested logs
      const mgaData = safeGet(() => GM_getValue('MGA_data', null), 'MGA_data');
      if (mgaData) {
          try {
              const parsed = typeof mgaData === 'string' ? JSON.parse(mgaData) : mgaData;
              const nestedLogs = parsed?.petAbilityLogs;
              report.sources.mgaDataNested = {
                  logs: parseAndCount(nestedLogs, 'MGA_data nested')
              };
          } catch (e) {
              report.sources.mgaDataNested = { error: e.message };
          }
      }
  
      // 5. Window compatibility array (old mainscript.txt)
      if (typeof window.petAbilityLogs !== 'undefined') {
          report.sources.compatibilityArray = {
              count: Array.isArray(window.petAbilityLogs) ? window.petAbilityLogs.length : 'not-an-array',
              sample: Array.isArray(window.petAbilityLogs) ? window.petAbilityLogs.slice(0, 3) : null
          };
      }
  
      // 6. Current memory state
      const memoryLogs = (UnifiedState.data?.petAbilityLogs || []).map(l => {
          const abilityType = l.abilityType || 'unknown';
          const normalizedAbility = normalizeAbilityName(abilityType);
          const isKnown = isKnownAbilityType(normalizedAbility);
          const isMalformed = abilityType !== normalizedAbility;
  
          return {
              ability: abilityType,
              normalizedAbility: isMalformed ? normalizedAbility : null,
              isKnown,
              isMalformed,
              pet: l.petName || l.petSpecies || 'unknown',
              timestamp: l.timestamp,
              time: new Date(l.timestamp).toLocaleString(),
              fingerprint: `${abilityType}_${l.petName}_${l.timestamp}`.substring(0, 50)
          };
      });
  
      report.sources.memory = {
          unifiedState: {
              count: memoryLogs.length,
              sample: memoryLogs  // Now includes all logs with fingerprints
          }
      };
  
      // Calculate total across all sources
      const totals = {
          gmMain: report.sources.gmStorage.main.count || 0,
          gmArchive: report.sources.gmStorage.archive.count || 0,
          lsMain: report.sources.windowLocalStorage.main.count || 0,
          lsArchive: report.sources.windowLocalStorage.archive.count || 0,
          memory: report.sources.memory.unifiedState.count
      };
  
      report.summary = {
          totalLocationsWithLogs: Object.values(totals).filter(c => c > 0).length,
          totals,
          suspectSources: Object.entries(totals).filter(([k, v]) => v > 0).map(([k]) => k)
      };
  
      // Output report
      console.log('üîç ========== ABILITY LOGS STORAGE DIAGNOSTIC ==========');
      console.log('üìä Summary:', report.summary);
      console.log('');
  
      // Show counts for each storage location
      console.log('üìÅ GM Storage:');
      console.log('  Main:', report.sources.gmStorage.main.count, 'logs');
      console.log('  Archive:', report.sources.gmStorage.archive.count, 'logs');
  
      console.log('üìÅ Window localStorage:');
      console.log('  Main:', report.sources.windowLocalStorage.main.count, 'logs');
      console.log('  Archive:', report.sources.windowLocalStorage.archive.count, 'logs');
      console.log('  Clear flag:', report.sources.windowLocalStorage.clearFlag);
  
      if (report.sources.targetWindowLocalStorage) {
          console.log('üìÅ Target Window localStorage:');
          console.log('  Main:', report.sources.targetWindowLocalStorage.main.count, 'logs');
          console.log('  Archive:', report.sources.targetWindowLocalStorage.archive.count, 'logs');
      }
  
      if (report.sources.mgaDataNested) {
          console.log('üìÅ MGA_data nested:', report.sources.mgaDataNested);
      }
  
      if (report.sources.compatibilityArray) {
          console.log('üìÅ Compatibility array:', report.sources.compatibilityArray);
      }
  
      console.log('üíæ Memory:', report.sources.memory.unifiedState.count, 'logs');
      console.log('');
  
      // DETAILED LOG LISTING - Show individual logs from each source
      console.log('üìã ========== DETAILED LOG LISTING ==========');
  
      const showLogs = (title, logs) => {
          if (logs && logs.length > 0) {
              console.log(`\n${title}:`);
              logs.forEach((log, i) => {
                  const prefix = log.isMalformed ? '‚ö†Ô∏è MALFORMED' : (log.isKnown ? '‚úÖ' : '‚ùì UNKNOWN');
                  console.log(`  ${i + 1}. ${prefix} [${log.fingerprint}]`);
                  console.log(`     ${log.ability} - ${log.pet}`);
                  if (log.isMalformed) {
                      console.log(`     ‚Üí Should be: "${log.normalizedAbility}"`);
                  }
                  console.log(`     ${log.time}`);
              });
          }
      };
  
      showLogs('GM Storage (Main)', report.sources.gmStorage.main.logs);
      showLogs('GM Storage (Archive)', report.sources.gmStorage.archive.logs);
      showLogs('Window localStorage (Main)', report.sources.windowLocalStorage.main.logs);
      showLogs('Window localStorage (Archive)', report.sources.windowLocalStorage.archive.logs);
      if (report.sources.targetWindowLocalStorage) {
          showLogs('TargetWindow localStorage (Main)', report.sources.targetWindowLocalStorage.main.logs);
          showLogs('TargetWindow localStorage (Archive)', report.sources.targetWindowLocalStorage.archive.logs);
      }
      if (report.sources.mgaDataNested?.logs?.logs) {
          showLogs('MGA_data nested', report.sources.mgaDataNested.logs.logs);
      }
      showLogs('Memory (UnifiedState)', report.sources.memory.unifiedState.sample);
  
      // Count total malformed and unknown logs
      const allSources = [
          report.sources.gmStorage.main,
          report.sources.gmStorage.archive,
          report.sources.windowLocalStorage.main,
          report.sources.windowLocalStorage.archive
      ];
      if (report.sources.targetWindowLocalStorage) {
          allSources.push(report.sources.targetWindowLocalStorage.main);
          allSources.push(report.sources.targetWindowLocalStorage.archive);
      }
  
      const totalMalformed = allSources.reduce((sum, src) => sum + (src.malformedCount || 0), 0);
      const totalUnknown = allSources.reduce((sum, src) => sum + (src.unknownCount || 0), 0);
  
      console.log('\n=======================================================');
      console.log('üí° TIPS:');
      console.log('  ‚Ä¢ Look for logs with identical fingerprints across multiple storage locations');
      console.log('  ‚Ä¢ If a log persists after clear, check which storage still contains it');
      if (totalMalformed > 0) {
          console.log(`  ‚Ä¢ ‚ö†Ô∏è Found ${totalMalformed} MALFORMED ability name(s) - missing spaces before roman numerals`);
          console.log('  ‚Ä¢ Malformed logs may not clear properly. Enable Debug Mode and click "Clear Logs".');
      }
      if (totalUnknown > 0) {
          console.log(`  ‚Ä¢ ‚ùì Found ${totalUnknown} UNKNOWN ability type(s) - not in known abilities list`);
      }
      console.log('=======================================================');
  
      logDebug('ABILITY-LOGS', '‚úÖ Diagnostic complete - see console for full report');
  
      return report;
  }
  
  // ==================== DATA MIGRATION SYSTEM ====================
  // Migrate existing localStorage data to GM storage for better reliability
  
  function MGA_migrateFromLocalStorage() {
      try {
          productionLog('üîÑ [MIGRATION] Starting data migration from localStorage to GM storage...');
  
          // Check if migration has already been completed (handle both boolean and string values)
          const migrationComplete = GM_getValue('MGA_migration_completed', false);
          if (migrationComplete === true || migrationComplete === 'true') {
              productionLog('‚úÖ [MIGRATION] Migration already completed, skipping...');
              return;
          }
  
          // List of keys to migrate
          const keysToMigrate = [
              'MGA_petPresets',
              'MGA_seedsToDelete',
              'MGA_autoDeleteEnabled',
              'MGA_petAbilityLogs',
              'MGA_settings',
              'MGA_mainHUDPosition',
              'MGA_toggleButtonPosition',
              'MGA_overlayDimensions',
              'MGA_overlayPositions',
              'MGA_overlayStates',
              'MGA_abilityFilters',
              'MGA_petFilters',
              'MGA_customMode',
              'MGA_filterMode',
              'MGA_timerStates'
          ];
  
          let migratedCount = 0;
          let totalDataSize = 0;
  
          // Use requestIdleCallback to avoid blocking the main thread during migration
          const migrateKeys = (keyIndex = 0) => {
              if (keyIndex >= keysToMigrate.length) {
                  // Migration complete
                  GM_setValue('MGA_migration_completed', true);
                  GM_setValue('MGA_migration_timestamp', Date.now());
                  GM_setValue('MGA_migration_stats', {
                      migratedCount,
                      totalDataSize,
                      timestamp: Date.now()
                  });
  
                  productionLog(`‚úÖ [MIGRATION] Data migration completed!`);
                  productionLog(`üìä [MIGRATION] Statistics:`, {
                      migratedKeys: migratedCount,
                      totalDataSize: totalDataSize + ' chars',
                      timestamp: new Date().toISOString()
                  });
                  return;
              }
  
              const key = keysToMigrate[keyIndex];
              try {
                  const localStorageData = localStorage.getItem(key);
                  if (localStorageData) {
                      // Data exists in localStorage, migrate it
                      GM_setValue(key, localStorageData);
                      migratedCount++;
                      totalDataSize += localStorageData.length;
  
                      productionLog(`üì¶ [MIGRATION] Migrated ${key} (${localStorageData.length} chars)`);
  
                      // Verify the migration worked
                      const verification = GM_getValue(key, null);
                      if (verification === localStorageData) {
                          productionLog(`‚úÖ [MIGRATION] Successfully verified ${key}`);
  
                          // Only remove from localStorage after successful verification
                          localStorage.removeItem(key);
                          productionLog(`üóëÔ∏è [MIGRATION] Removed ${key} from localStorage`);
                      } else {
                          console.error(`‚ùå [MIGRATION] Verification failed for ${key} - keeping localStorage version`);
                      }
                  } else {
                      // No data in localStorage for this key
                      productionLog(`üìù [MIGRATION] No data found for ${key} in localStorage`);
                  }
              } catch (error) {
                  console.error(`‚ùå [MIGRATION] Failed to migrate ${key}:`, error);
              }
  
              // Process next key with a small delay to avoid blocking
              if (typeof requestIdleCallback !== 'undefined') {
                  requestIdleCallback(() => migrateKeys(keyIndex + 1));
              } else {
                  setTimeout(() => migrateKeys(keyIndex + 1), 0);
              }
          };
  
          // Start migration
          migrateKeys();
  
          return { success: true, migratedCount, totalDataSize };
  
      } catch (error) {
          console.error(`‚ùå [MIGRATION] Migration process failed:`, error);
          return { success: false, error: error.message };
      }
  }
  
  // Function to check migration status for debugging
  function MGA_getMigrationStatus() {
      const migrationComplete = GM_getValue('MGA_migration_completed', false);
      const migrationStats = GM_getValue('MGA_migration_stats', null);
      const migrationTimestamp = GM_getValue('MGA_migration_timestamp', null);
  
      return {
          completed: migrationComplete,
          stats: migrationStats,
          timestamp: migrationTimestamp ? new Date(migrationTimestamp).toISOString() : null
      };
  }
  
  // Export migration functions for debugging
  targetWindow.MGA_migrateFromLocalStorage = MGA_migrateFromLocalStorage;
  targetWindow.MGA_getMigrationStatus = MGA_getMigrationStatus;
  targetWindow.MGA_saveJSON = MGA_saveJSON;
  targetWindow.MGA_loadJSON = MGA_loadJSON;
  
  // Export startIntervals for debugging and emergency use
  targetWindow.startIntervals = startIntervals;
  
  // ==================== COMPREHENSIVE DEBUG COLLECTION ====================
  targetWindow.collectMGADebug = function() {
      productionLog('üîç Starting comprehensive MGA debug collection...');
  
      const debugData = {
          timestamp: new Date().toISOString(),
          version: typeof GM_info !== 'undefined' ? (GM_info?.script?.version || 'Unknown') : 'Unknown',
          userAgent: navigator.userAgent,
  
          // Script State
          scriptState: {
              mainScriptDetected: (typeof MGAIsolationSystem !== 'undefined' ? MGAIsolationSystem?.mainScriptDetected : false) || false,
              protectedGlobals: (typeof MGAIsolationSystem !== 'undefined' ? MGAIsolationSystem?.protectedGlobals : []) || [],
              globalFunctions: {
                  hasLoadJSON: typeof targetWindow.loadJSON !== 'undefined',
                  hasSaveJSON: typeof targetWindow.saveJSON !== 'undefined',
                  loadJSONOwner: (typeof targetWindow.loadJSON !== 'undefined' && targetWindow.loadJSON === MGA_loadJSON) ? 'MGA' : 'Other',
                  saveJSONOwner: (typeof targetWindow.saveJSON !== 'undefined' && targetWindow.saveJSON === MGA_saveJSON) ? 'MGA' : 'Other'
              }
          },
  
          // Pet Hunger System
          petHungerSystem: {
              enabled: UnifiedState?.data?.settings?.notifications?.petHungerEnabled || false,
              threshold: UnifiedState?.data?.settings?.notifications?.petHungerThreshold || 25,
              activePets: UnifiedState?.atoms?.activePets?.map(pet => ({
                  id: pet?.id,
                  species: pet?.petSpecies,
                  hunger: pet?.hunger,
                  health: pet?.health,
                  slot: pet?.slot
              })) || [],
              lastStates: (typeof lastPetHungerStates !== 'undefined') ? Object.keys(lastPetHungerStates || {}).map(id => ({
                  petId: id,
                  lastHunger: lastPetHungerStates[id]
              })) : []
          },
  
          // Shop System
          shopSystem: {
              firebaseEnabled: UnifiedState?.data?.settings?.notifications?.shopFirebaseEnabled || false,
              watchedSeeds: UnifiedState?.data?.settings?.notifications?.watchedSeeds || [],
              watchedEggs: UnifiedState?.data?.settings?.notifications?.watchedEggs || [],
              shopData: {
                  globalShop: typeof targetWindow.globalShop !== 'undefined' ? 'Present' : 'Missing',
                  quinoaData: UnifiedState?.atoms?.quinoaData ? 'Present' : 'Missing',
                  seedTimer: UnifiedState?.data?.timers?.seed,
                  eggTimer: UnifiedState?.data?.timers?.egg,
                  toolTimer: UnifiedState?.data?.timers?.tool
              },
              lastCheck: new Date().toISOString()
          },
  
          // Weather System
          weatherSystem: {
              enabled: UnifiedState?.data?.settings?.notifications?.weatherNotificationsEnabled || false,
              watchedEvents: UnifiedState?.data?.settings?.notifications?.watchedWeatherEvents || [],
              currentWeather: targetWindow.roomState?.child?.data?.weather || targetWindow.roomState?.weather || 'Unknown',
              lastWeatherState: (typeof lastWeatherState !== 'undefined') ? lastWeatherState : null
          },
  
          // Performance Metrics
          performance: {
              memoryUsage: performance?.memory ? {
                  usedJSHeapSize: (performance.memory.usedJSHeapSize / 1048576).toFixed(2) + ' MB',
                  totalJSHeapSize: (performance.memory.totalJSHeapSize / 1048576).toFixed(2) + ' MB',
                  jsHeapSizeLimit: (performance.memory.jsHeapSizeLimit / 1048576).toFixed(2) + ' MB'
              } : 'Not available',
              intervals: {
                  notificationInterval: (typeof notificationInterval !== 'undefined') ? 'Active' : 'Inactive',
                  firebaseInterval: UnifiedState?.firebase?.reportInterval ? 'Active' : 'Inactive',
                  timerManagerActive: (typeof timerManager !== 'undefined') ? (timerManager?.isRunning || false) : false,
                  activeTimers: (typeof timerManager !== 'undefined') ? (timerManager?.activeTimers?.size || 0) : 0
              }
          },
  
          // Storage Status
          storageStatus: {
              gmApiAvailable: (typeof isGMApiAvailable !== 'undefined') ? isGMApiAvailable() : false,
              migrationStatus: (typeof MGA_getMigrationStatus !== 'undefined') ? MGA_getMigrationStatus() : 'N/A',
              storedData: (typeof GM_getValue !== 'undefined') ? {
                  petPresets: GM_getValue('MGA_petPresets') ? 'Present' : 'Missing',
                  seedsToDelete: GM_getValue('MGA_seedsToDelete') ? 'Present' : 'Missing',
                  settings: GM_getValue('MGA_data') ? 'Present' : 'Missing'
              } : 'GM API not available'
          },
  
          // AutoFeed Protection
          autoFeedStatus: {
              autoFeedEnabled: targetWindow.autoFeedEnabled,
              autoFeedState: targetWindow.autoFeedState,
              autoFeedSkipFavorited: targetWindow.autoFeedSkipFavorited,
              protection: (typeof MGAIsolationSystem !== 'undefined') ? (MGAIsolationSystem?.isAutofeedProtected || false) : false
          },
  
          // Errors and Warnings
          recentErrors: []
      };
  
      productionLog('üìä Collecting performance data for 10 seconds...');
      productionLog('‚è≥ Monitoring for errors and performance issues...');
  
      // Note: Error capturing disabled due to browser security restrictions
      const errors = [];
  
      // Create performance monitor
      let frameCount = 0;
      let lastFrameTime = performance.now();
      const fpsData = [];
  
      function measureFPS() {
          const currentTime = performance.now();
          const delta = currentTime - lastFrameTime;
          if (delta > 0) {
              const fps = 1000 / delta;
              fpsData.push({
                  time: new Date().toISOString(),
                  fps: Math.round(fps),
                  weather: window.roomState?.child?.data?.weather || window.roomState?.weather || 'None'
              });
          }
          lastFrameTime = currentTime;
          frameCount++;
  
          if (frameCount < 600) { // Run for ~10 seconds at 60fps
              requestAnimationFrame(measureFPS);
          } else {
              finishDebugCollection();
          }
      }
  
      requestAnimationFrame(measureFPS);
  
      function finishDebugCollection() {
          // Add collected data
          debugData.recentErrors = errors;
          debugData.performance.fpsAnalysis = {
              samples: fpsData.length,
              averageFPS: Math.round(fpsData.reduce((a, b) => a + b.fps, 0) / fpsData.length),
              minFPS: Math.min(...fpsData.map(d => d.fps)),
              maxFPS: Math.max(...fpsData.map(d => d.fps)),
              weatherDuringTest: [...new Set(fpsData.map(d => d.weather))]
          };
  
          // Create downloadable file
          const debugText = JSON.stringify(debugData, null, 2);
          const blob = new Blob([debugText], { type: 'text/plain' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `mga-debug-${Date.now()}.json`;
          a.click();
          URL.revokeObjectURL(url);
  
          productionLog('‚úÖ Debug collection complete!');
          productionLog('üìÅ Debug file downloaded');
          productionLog('üìä Debug Summary:', {
              petHungerEnabled: debugData.petHungerSystem.enabled,
              activePets: debugData.petHungerSystem.activePets.length,
              weatherEnabled: debugData.weatherSystem.enabled,
              currentWeather: debugData.weatherSystem.currentWeather,
              averageFPS: debugData.performance.fpsAnalysis?.averageFPS,
              errors: debugData.recentErrors.length
          });
  
          // Also log to console for immediate viewing
          productionLog('üîç Full Debug Data:', debugData);
  
          return debugData;
      }
  
      // Also set a timeout in case FPS monitoring doesn't complete
      setTimeout(() => {
          if (frameCount < 600) {
              productionLog('‚è±Ô∏è Timeout reached, finishing collection early...');
              finishDebugCollection();
          }
      }, 12000);
  
      return 'Debug collection started... Will complete in 10 seconds.';
  };
  
  // ==================== MEMORY MANAGEMENT SYSTEM ====================
  // Prevent memory leaks and accumulation that requires tab restarts
  
  let mgaCleanupHandlers = [];
  let mgaIntervals = [];
  let mgaTimeouts = [];
  
  // Register cleanup handler
  function MGA_addCleanupHandler(handler) {
      if (typeof handler === 'function') {
          mgaCleanupHandlers.push(handler);
      }
  }
  
  // Register interval for automatic cleanup
  function MGA_addInterval(interval) {
      mgaIntervals.push(interval);
      return interval;
  }
  
  // Register timeout for automatic cleanup
  function MGA_addTimeout(timeout) {
      mgaTimeouts.push(timeout);
      return timeout;
  }
  
  // Clean up all MGA resources
  function MGA_cleanup() {
      productionLog('üßπ [MEMORY] Starting MGA cleanup...');
  
      try {
          // Clear all intervals
          mgaIntervals.forEach(interval => {
              if (interval) {
                  clearInterval(interval);
              }
          });
          productionLog(`üßπ [MEMORY] Cleared ${mgaIntervals.length} intervals`);
          mgaIntervals = [];
  
          // Clear all timeouts
          mgaTimeouts.forEach(timeout => {
              if (timeout) {
                  clearTimeout(timeout);
              }
          });
          productionLog(`üßπ [MEMORY] Cleared ${mgaTimeouts.length} timeouts`);
          mgaTimeouts = [];
  
          // Run custom cleanup handlers
          mgaCleanupHandlers.forEach((handler, index) => {
              try {
                  handler();
                  productionLog(`üßπ [MEMORY] Executed cleanup handler ${index + 1}`);
              } catch (error) {
                  console.error(`‚ùå [MEMORY] Cleanup handler ${index + 1} failed:`, error);
              }
          });
  
          // Clear event listeners
          if (window.MGA_Internal && window.MGA_Internal.eventListeners) {
              window.MGA_Internal.eventListeners.forEach(({ element, event, handler }) => {
                  try {
                      element.removeEventListener(event, handler);
                  } catch (error) {
                      productionWarn(`‚ö†Ô∏è [MEMORY] Failed to remove event listener:`, error);
                  }
              });
              productionLog(`üßπ [MEMORY] Removed ${window.MGA_Internal.eventListeners.length} event listeners`);
              window.MGA_Internal.eventListeners = [];
          }
  
          // Clear large data structures
          if (window.UnifiedState) {
              // Save critical data before cleanup
              const criticalData = {
                  petPresets: window.UnifiedState.data?.petPresets,
                  seedsToDelete: window.UnifiedState.data?.seedsToDelete,
                  settings: window.UnifiedState.data?.settings
              };
  
              // Save critical data
              Object.keys(criticalData).forEach(key => {
                  if (criticalData[key] !== undefined) {
                      MGA_saveJSON(`MGA_${key}`, criticalData[key]);
                  }
              });
  
              // Clear large arrays
              if (window.UnifiedState.data?.petAbilityLogs) {
                  productionLog(`üßπ [MEMORY] Clearing ${window.UnifiedState.data.petAbilityLogs.length} pet ability logs from memory`);
                  window.UnifiedState.data.petAbilityLogs = [];
              }
          }
  
          productionLog('‚úÖ [MEMORY] MGA cleanup completed successfully');
  
      } catch (error) {
          console.error('‚ùå [MEMORY] MGA cleanup failed:', error);
      }
  }
  
  // Set up automatic cleanup on page unload
  window.addEventListener('beforeunload', () => {
      productionLog('üîÑ [MEMORY] Page unloading, starting cleanup...');
      MGA_cleanup();
  });
  
  // Set up cleanup on page hide (for mobile/tab switching)
  window.addEventListener('pagehide', () => {
      productionLog('üîÑ [MEMORY] Page hiding, starting cleanup...');
      MGA_cleanup();
  });
  
  // Export memory management functions
  window.MGA_cleanup = MGA_cleanup;
  window.MGA_addCleanupHandler = MGA_addCleanupHandler;
  window.MGA_addInterval = MGA_addInterval;
  window.MGA_addTimeout = MGA_addTimeout;
  
  // ==================== MEMORY OPTIMIZATION SYSTEM ====================
  // Smart memory management to reduce footprint while preserving user data
  
  // Configuration for memory limits
  const MGA_MemoryConfig = {
      maxLogsInMemory: 1000,        // Keep latest 1000 logs in memory
      maxLogsInStorage: 10000,      // Archive up to 10000 logs in storage
      saveDebounceMs: 2000,         // Debounce saves by 2 seconds
      domPoolSize: 50               // Pool size for DOM elements
  };
  
  // Debounced save system to reduce I/O operations
  let saveTimeouts = new Map();
  function MGA_debouncedSave(key, data) {
      // Clear existing timeout for this key
      if (saveTimeouts.has(key)) {
          clearTimeout(saveTimeouts.get(key));
      }
  
      // Set new debounced timeout
      const timeout = setTimeout(() => {
          try {
              MGA_saveJSON(key, data);
              productionLog(`üíæ [MEMORY] Debounced save completed for ${key}`);
          } catch (error) {
              console.error(`‚ùå [MEMORY] Debounced save failed for ${key}:`, error);
          }
          saveTimeouts.delete(key);
      }, MGA_MemoryConfig.saveDebounceMs);
  
      saveTimeouts.set(key, timeout);
  }
  
  // Smart log management system
  function MGA_manageLogMemory(logs) {
      if (!Array.isArray(logs) || logs.length <= MGA_MemoryConfig.maxLogsInMemory) {
          return logs; // No management needed
      }
  
      productionLog(`üß† [MEMORY] Managing log memory: ${logs.length} logs, keeping ${MGA_MemoryConfig.maxLogsInMemory} in memory`);
  
      // Keep the most recent logs in memory
      const recentLogs = logs.slice(0, MGA_MemoryConfig.maxLogsInMemory);
  
      // Archive older logs to separate storage
      const archivedLogs = logs.slice(MGA_MemoryConfig.maxLogsInMemory);
      if (archivedLogs.length > 0) {
          // Save archived logs to separate storage key
          const existingArchive = MGA_loadJSON('MGA_petAbilityLogs_archive', []);
          const combinedArchive = [...archivedLogs, ...existingArchive].slice(0, MGA_MemoryConfig.maxLogsInStorage);
          MGA_debouncedSave('MGA_petAbilityLogs_archive', combinedArchive);
          productionLog(`üì¶ [MEMORY] Archived ${archivedLogs.length} logs to storage`);
      }
  
      return (typeof wrapLogsArray==='function') ? wrapLogsArray(recentLogs) : recentLogs;
  }
  
  // DOM element pooling for performance
  const MGA_DOMPool = {
      pools: new Map(),
  
      getElement: function(tagName, className = '') {
          const key = `${tagName}:${className}`;
          if (!this.pools.has(key)) {
              this.pools.set(key, []);
          }
  
          const pool = this.pools.get(key);
          if (pool.length > 0) {
              const element = pool.pop();
              // Reset element state
              element.innerHTML = '';
              element.removeAttribute('style');
              element.className = className;
              return element;
          }
  
          // Create new element if pool is empty (using target context)
          const element = targetDocument.createElement(tagName);
          if (className) element.className = className;
          return element;
      },
  
      returnElement: function(element) {
          if (!element || !element.tagName) return;
  
          const key = `${element.tagName.toLowerCase()}:${element.className || ''}`;
          if (!this.pools.has(key)) {
              this.pools.set(key, []);
          }
  
          const pool = this.pools.get(key);
          if (pool.length < MGA_MemoryConfig.domPoolSize) {
              // Clean element before returning to pool
              element.innerHTML = '';
              element.removeAttribute('style');
              element.onclick = null;
              element.onmouseover = null;
              element.onmouseout = null;
              pool.push(element);
          }
      },
  
      cleanup: function() {
          productionLog('üßπ [MEMORY] Cleaning DOM element pools');
          this.pools.clear();
      }
  };
  
  // Add DOM pool cleanup to main cleanup handler
  MGA_addCleanupHandler(() => {
      MGA_DOMPool.cleanup();
      // Clear save timeouts
      saveTimeouts.forEach(timeout => clearTimeout(timeout));
      saveTimeouts.clear();
  });
  
  // Function to retrieve all logs (memory + archived) when needed
  function MGA_getAllLogs() {
      const memoryLogs = UnifiedState.data?.petAbilityLogs || [];
      const archivedLogs = MGA_loadJSON('MGA_petAbilityLogs_archive', []);
  
      // Combine and sort by timestamp (newest first)
      const allLogs = [...memoryLogs, ...archivedLogs];
      allLogs.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));
  
      productionLog(`üìú [MEMORY] Retrieved ${memoryLogs.length} memory logs + ${archivedLogs.length} archived logs = ${allLogs.length} total`);
      return allLogs;
  }
  
  // Export memory optimization functions
  window.MGA_debouncedSave = MGA_debouncedSave;
  window.MGA_manageLogMemory = MGA_manageLogMemory;
  window.MGA_getAllLogs = MGA_getAllLogs;
  window.MGA_DOMPool = MGA_DOMPool;
  
  // ==================== DOM QUERY CACHE SYSTEM ====================
  // Performance optimization: Cache frequently accessed DOM queries
  const elementCache = new WeakMap();
  const CACHE_DURATION = 1000; // 1 second cache
  
  function getCachedElement(selector, context = document) {
      const now = Date.now();
      const key = `${selector}_${context.id || 'document'}`;
  
      let cached = elementCache.get(context);
      if (cached && cached[key] && now - cached[key].time < CACHE_DURATION) {
          return cached[key].element;
      }
  
      const element = context.querySelector(selector);
      if (!cached) cached = {};
      cached[key] = { element, time: now };
      elementCache.set(context, cached);
  
      return element;
  }
  
  function getCachedElements(selector, context = document) {
      const now = Date.now();
      const key = `${selector}_all_${context.id || 'document'}`;
  
      let cached = elementCache.get(context);
      if (cached && cached[key] && now - cached[key].time < CACHE_DURATION) {
          return cached[key].elements;
      }
  
      const elements = context.querySelectorAll(selector);
      if (!cached) cached = {};
      cached[key] = { elements, time: now };
      elementCache.set(context, cached);
  
      return elements;
  }
  
  // Invalidate cache for a specific context (useful after DOM changes)
  function invalidateCache(context = document) {
      elementCache.delete(context);
  }
  
  window.MGA_DOMCache = { getCachedElement, getCachedElements, invalidateCache };
  
  // ==================== NAMESPACE ISOLATION ====================
  // Keep MGA functions completely isolated to prevent conflicts with MainScript.txt
  
  // Export MGA functions to global scope for direct access (MGA_ prefix prevents conflicts)
  window.MGA_loadJSON = MGA_loadJSON;
  window.MGA_saveJSON = MGA_saveJSON;
  
  // MainScript Conflict Detection and Protection
  window.MGA_ConflictDetection = {
      mainScriptDetected: false,
      protectedGlobals: ['autoFeedEnabled', 'autoFeedState', 'autoFeedSkipFavorited', 'petAbilityLogs'],
  
      // Ensure MGA never accesses MainScript globals
      preventAccess: function() {
          if (!this.mainScriptDetected) return;
  
          // Create safe accessors that prevent MGA from accidentally touching MainScript variables
          this.protectedGlobals.forEach(globalVar => {
              if (window[globalVar] !== undefined) {
                  productionLog(`üîí [MGA-ISOLATION] Ensuring MGA cannot access MainScript global: ${globalVar}`);
  
                  // Define a read-only accessor for debugging
                  Object.defineProperty(window, `MGA_SAFE_${globalVar}`, {
                      get: function() {
                          productionWarn(`‚ö†Ô∏è [MGA-ISOLATION] MGA attempted to access MainScript global: ${globalVar}`);
                          productionWarn(`‚ö†Ô∏è [MGA-ISOLATION] This access was blocked to prevent interference`);
                          console.trace();
                          return undefined; // Always return undefined to MGA
                      },
                      configurable: false,
                      enumerable: false
                  });
              }
          });
  
          // Specifically protect autofeed variables
          productionLog(`üîí [MGA-ISOLATION] MainScript autofeed protection active`);
          productionLog(`üîí [MGA-ISOLATION] MGA will not interfere with autofeed functionality`);
      },
  
      detectMainScript: function() {
          const hasMainScriptFunctions = typeof window.loadJSON === 'function' || typeof window.saveJSON === 'function';
          const hasMainScriptVars = typeof window.petAbilityLogs !== 'undefined' || typeof window.autoFeedEnabled !== 'undefined';
          const hasVisibilityOverride = document.hidden === false && typeof Object.getOwnPropertyDescriptor === 'function';
  
          this.mainScriptDetected = hasMainScriptFunctions || hasMainScriptVars || hasVisibilityOverride;
  
          if (this.mainScriptDetected) {
              // productionLog('üîç [MGA-ISOLATION] MainScript.txt detected - enabling full isolation mode');
              productionLog('üîí [MGA-ISOLATION] MGA will NOT modify global functions or MainScript variables');
              productionLog('üìù [MGA-ISOLATION] Protected variables:', this.protectedGlobals);
          } else {
              productionLog('üìù [MGA-ISOLATION] No MainScript detected - running in standalone mode');
          }
  
          return this.mainScriptDetected;
      },
  
      checkGlobalIntegrity: function() {
          if (!this.mainScriptDetected) return true;
  
          const violations = [];
  
          // Check if we accidentally modified protected globals
          this.protectedGlobals.forEach(globalVar => {
              if (window[globalVar] !== undefined) {
                  // MainScript global exists - make sure we don't interfere
                  // productionLog(`üîç [MGA-ISOLATION] MainScript global '${globalVar}' is active - ensuring no interference`);
              }
          });
  
          // Check if global loadJSON/saveJSON are MainScript's versions
          if (window.loadJSON && window.loadJSON !== MGA_loadJSON) {
              productionLog('üîí [MGA-ISOLATION] Global loadJSON belongs to MainScript - MGA using isolated MGA_loadJSON');
          }
          if (window.saveJSON && window.saveJSON !== MGA_saveJSON) {
              productionLog('üîí [MGA-ISOLATION] Global saveJSON belongs to MainScript - MGA using isolated MGA_saveJSON');
          }
  
          return violations.length === 0;
      },
  
      createIsolationBarrier: function() {
          if (!this.mainScriptDetected) return;
  
          // Light protection - just store original values for monitoring
          this.protectedGlobals.forEach(globalVar => {
              if (window[globalVar] !== undefined) {
                  const originalValue = window[globalVar];
  
                  // Store original value for later comparison
                  try {
                      Object.defineProperty(window, `_MGA_ORIGINAL_${globalVar}`, {
                          value: originalValue,
                          writable: true,
                          configurable: true
                      });
                      productionLog(`üõ°Ô∏è [MGA-ISOLATION] Stored original value for MainScript global: ${globalVar}`);
                  } catch (protectionError) {
                      productionWarn(`‚ö†Ô∏è [MGA-ISOLATION] Could not store original value for ${globalVar}:`, protectionError.message);
                  }
              }
          });
  
          // Simple function protection - just save references without modifying
          if (window.loadJSON && window.loadJSON !== window.MGA_loadJSON) {
              productionLog(`üîí [MGA-ISOLATION] MainScript loadJSON detected - storing reference`);
              window._MGA_MAINSCRIPT_loadJSON = window.loadJSON;
          }
          if (window.saveJSON && window.saveJSON !== window.MGA_saveJSON) {
              productionLog(`üîí [MGA-ISOLATION] MainScript saveJSON detected - storing reference`);
              window._MGA_MAINSCRIPT_saveJSON = window.saveJSON;
          }
      },
  
      // New method to verify isolation integrity
      validateIsolation: function() {
          let violations = [];
  
          // Check that MGA never modified protected globals
          this.protectedGlobals.forEach(globalVar => {
              const original = window[`_MGA_ORIGINAL_${globalVar}`];
              const current = window[globalVar];
  
              if (original !== undefined && current !== original) {
                  violations.push({
                      global: globalVar,
                      expected: original,
                      actual: current,
                      type: 'global_modification'
                  });
              }
          });
  
          // Check that MGA uses its own storage functions
          if (window.MGA_loadJSON && window.loadJSON && window.MGA_loadJSON === window.loadJSON) {
              violations.push({
                  issue: 'MGA_loadJSON is assigned to global loadJSON',
                  type: 'function_collision'
              });
          }
          if (window.MGA_saveJSON && window.saveJSON && window.MGA_saveJSON === window.saveJSON) {
              violations.push({
                  issue: 'MGA_saveJSON is assigned to global saveJSON',
                  type: 'function_collision'
              });
          }
  
          if (violations.length > 0) {
              console.error(`‚ùå [MGA-ISOLATION] Isolation violations detected:`, violations);
              return false;
          }
  
          productionLog(`‚úÖ [MGA-ISOLATION] Isolation validation passed - no violations detected`);
          return true;
      }
  };
  
  // NEVER set global window.loadJSON or window.saveJSON - this prevents conflicts
  // MGA ALWAYS uses MGA_loadJSON and MGA_saveJSON exclusively
  
  // ==================== SAVE OPERATION WRAPPER ====================
  // Wrapper function to handle new MGA_saveJSON return format and provide user feedback
  
  window.MGA_safeSave = function(key, value, options = {}) {
      const {
          showUserAlert = true,
          criticalData = false,
          description = key,
          silent = false
      } = options;
  
      // CRITICAL: Ensure we never use MainScript keys
      if (key && !key.startsWith('MGA_')) {
          console.error(`‚ùå [MGA-ISOLATION] CRITICAL: Attempted to save with non-MGA key: ${key}`);
          console.error(`‚ùå [MGA-ISOLATION] This would conflict with MainScript! Adding MGA_ prefix.`);
          console.trace();
          key = 'MGA_' + key;
      }
  
      try {
          // Simple synchronous save
          const success = MGA_saveJSON(key, value);
  
          if (success) {
              if (!silent) {
                  productionLog(`‚úÖ [MGA-SAFE-SAVE] Successfully saved ${description}`);
              }
              return { success: true };
          } else {
              // Save failed
              const errorMsg = `Failed to save ${description}`;
              console.error(`‚ùå [MGA-SAFE-SAVE] ${errorMsg}`);
  
              // REMOVED: Alert on save failure - causes modal spam
              // Save failures are logged to console instead
  
              return { success: false, error: 'save_failed' };
          }
      } catch (error) {
          console.error(`‚ùå [MGA-SAFE-SAVE] Exception during save of ${description}:`, error);
          return { success: false, error: error.message, exception: true };
      }
  };
  
  // Helper function for backward compatibility with legacy save calls
  window.MGA_legacySave = function(key, value, description) {
      const result = MGA_safeSave(key, value, {
          description: description || key,
          showUserAlert: true,
          criticalData: key.includes('petPresets') || key.includes('seedsToDelete')
      });
      return result.success;
  };
  
  // Validation helper for critical data types
  window.MGA_validateSaveData = function(key, value) {
      if (key === 'MGA_petPresets') {
          if (!value || typeof value !== 'object') {
              return { valid: false, error: 'Pet presets must be an object' };
          }
          for (const [presetName, preset] of Object.entries(value)) {
              if (!Array.isArray(preset)) {
                  return { valid: false, error: `Preset '${presetName}' must be an array` };
              }
              if (!preset.every(pet => pet && pet.id && pet.petSpecies)) {
                  return { valid: false, error: `Preset '${presetName}' contains invalid pet data` };
              }
          }
          return { valid: true };
      }
  
      if (key === 'MGA_seedsToDelete') {
          if (!Array.isArray(value)) {
              return { valid: false, error: 'Seeds to delete must be an array' };
          }
          if (!value.every(seed => typeof seed === 'string' && seed.trim())) {
              return { valid: false, error: 'All seeds must be non-empty strings' };
          }
          return { valid: true };
      }
  
      return { valid: true }; // Default: assume valid for other data types
  };
  
  // Diagnostic function for localStorage issues
  window.MGA_debugStorage = function() {
      productionLog('üîç [MGA-STORAGE] localStorage Diagnostic Report');
      productionLog('=====================================');
  
      try {
          // Check basic availability
          productionLog('üìä Basic Info:');
          productionLog('  localStorage available:', typeof localStorage !== 'undefined');
          productionLog('  Total items in localStorage:', localStorage.length);
  
          // Check MGA-specific keys
          const mgaKeys = Object.keys(localStorage).filter(k => k.startsWith('MGA_'));
          productionLog('  MGA-specific keys found:', mgaKeys.length);
          productionLog('  MGA keys:', mgaKeys);
  
          // Check each MGA key
          productionLog('\nüìù MGA Data Status:');
          mgaKeys.forEach(key => {
              try {
                  const value = localStorage.getItem(key);
                  const parsed = JSON.parse(value);
                  productionLog(`  ${key}:`, {
                      exists: true,
                      size: value.length + ' chars',
                      type: typeof parsed,
                      itemCount: Array.isArray(parsed) ? parsed.length : Object.keys(parsed || {}).length
                  });
              } catch (e) {
                  productionLog(`  ${key}: ‚ùå Invalid JSON - ${e.message}`);
              }
          });
  
          // Check conflicts
          productionLog('\n‚ö†Ô∏è Potential Conflicts:');
          productionLog('  window.loadJSON defined by:', window.loadJSON === MGA_loadJSON ? 'MGA' : 'Other script');
          productionLog('  window.saveJSON defined by:', window.saveJSON === MGA_saveJSON ? 'MGA' : 'Other script');
  
          // Storage space test
          productionLog('\nüíæ Storage Test:');
          const testKey = 'MGA_storageTest';
          const testData = { test: true, timestamp: Date.now() };
          try {
              MGA_saveJSON(testKey, testData);
              const retrieved = MGA_loadJSON(testKey, null);
              productionLog('  Storage test result:', retrieved && retrieved.test === true ? '‚úÖ PASSED' : '‚ùå FAILED');
              localStorage.removeItem(testKey);
          } catch (e) {
              productionLog('  Storage test result: ‚ùå FAILED -', e.message);
          }
  
      } catch (error) {
          console.error('‚ùå [MGA-STORAGE] Diagnostic failed:', error);
      }
  };
  
      function safeSendMessage(message) {
          try {
              // Check for connection availability
              if (!targetWindow.MagicCircle_RoomConnection) {
                  productionWarn('‚ö†Ô∏è MagicCircle_RoomConnection not available');
                  return false;
              }
  
              // Validate that sendMessage exists and is a function
              if (typeof targetWindow.MagicCircle_RoomConnection.sendMessage !== 'function') {
                  productionWarn('‚ö†Ô∏è sendMessage is not a function or not available');
                  return false;
              }
  
              // Send the message
              targetWindow.MagicCircle_RoomConnection.sendMessage(message);
              return true;
          } catch (error) {
              console.error('‚ùå Error sending message:', error);
              return false;
          }
      }
  
      // ==================== PROPER GAME MESSAGE SENDER ====================
      function sendToGame(payloadObj) {
          const msg = { scopePath: ["Room", "Quinoa"], ...payloadObj };
          try {
              if (!targetWindow.MagicCircle_RoomConnection || !targetWindow.MagicCircle_RoomConnection.sendMessage) {
                  productionWarn('‚ö†Ô∏è MagicCircle_RoomConnection not available for sendToGame');
                  return false;
              }
  
              productionLog('üéÆ sendToGame:', msg);
              targetWindow.MagicCircle_RoomConnection.sendMessage(msg);
              return true;
          } catch (error) {
              console.error('‚ùå sendToGame error:', error);
              return false;
          }
      }
  
      function hookAtom(atomPath, windowKey, callback, retryCount = 0) {
          const maxRetries = 20; // Max 10 seconds of retries
          const hookKey = `${atomPath}_${windowKey}`;
  
          // Prevent duplicate hooks - only check if retryCount is 0 (first attempt)
          if (retryCount === 0 && hookedAtoms.has(hookKey)) {
              productionLog(`[HOOK] Already hooked: ${windowKey} - skipping duplicate`);
              return;
          }
  
          // CRITICAL FIX: jotaiAtomCache is now an object with a .cache property
          const atomCache = targetWindow.jotaiAtomCache?.cache || targetWindow.jotaiAtomCache;
          if (!atomCache || !atomCache.get) {
              if (retryCount >= maxRetries) {
                  productionWarn(`‚ö†Ô∏è [ATOM-HOOK] Gave up waiting for jotaiAtomCache for ${windowKey} after ${maxRetries} retries`);
                  productionWarn(`‚ö†Ô∏è [ATOM-HOOK] Script will continue with reduced functionality`);
                  return;
              }
              productionLog(`‚è≥ Waiting for jotaiAtomCache for ${windowKey}... (${retryCount + 1}/${maxRetries})`);
              setTimeout(() => hookAtom(atomPath, windowKey, callback, retryCount + 1), 500);
              return;
          }
          productionLog(`üîó Attempting to hook atom: ${windowKey} at path: ${atomPath}`);
  
          try {
              const atom = atomCache.get(atomPath);
              if (!atom || !atom.read) {
                  productionWarn(`‚ùå Could not find atom for ${atomPath}`);
                  // List available atoms for debugging
                  const allAtoms = Array.from(atomCache.keys());
                  const petAtoms = allAtoms.filter(key => key.includes('Pet') || key.includes('pet') || key.includes('Slot'));
                  productionLog('üîç Pet-related atoms:', petAtoms);
                  productionLog('üîç All atoms (first 20):', allAtoms.slice(0, 20));
                  return;
              }
  
              const originalRead = atom.read;
              atom.read = function(get) {
                  const rawValue = originalRead.call(this, get);
  
                  // Enhanced debugging for activePets
                  if (windowKey === 'activePets' && UnifiedState.data.settings?.debugMode) {
                      productionLog(`üêæ [ATOM-DEBUG] ${windowKey} raw value:`, {
                          value: rawValue,
                          type: typeof rawValue,
                          isArray: Array.isArray(rawValue),
                          length: rawValue?.length,
                          firstItem: rawValue?.[0]
                      });
                  }
  
                  // Allow callback to transform the value before storing
                  let finalValue = rawValue;
                  if (callback) {
                      const callbackResult = callback(rawValue);
                      // If callback returns a value, use it; otherwise use raw value
                      if (callbackResult !== undefined) {
                          finalValue = callbackResult;
                          if (windowKey === 'activePets' && UnifiedState.data.settings?.debugMode) {
                              productionLog(`üêæ [ATOM-DEBUG] ${windowKey} transformed by callback:`, finalValue);
                          }
                      }
                  }
  
                  // Store the final (possibly transformed) value
                  UnifiedState.atoms[windowKey] = finalValue;
                  window[windowKey] = finalValue;
  
                  if (windowKey === 'activePets' && UnifiedState.data.settings?.debugMode) {
                      productionLog(`üêæ [ATOM-DEBUG] ${windowKey} stored in UnifiedState:`, {
                          count: finalValue?.length || 0,
                          value: finalValue
                      });
                  }
  
                  return rawValue; // Return raw value to game
              };
  
              productionLog(`‚úÖ hookAtom: Successfully hooked ${windowKey}`);
  
              // Mark this hook as successful to prevent duplicates
              hookedAtoms.add(hookKey);
  
              // Don't force an initial read - it might trigger game modals
              // Instead, wait for the game to naturally read the atom
              // Or use the periodic check in updateActivePetsFromRoomState
          } catch (error) {
              console.error(`‚ùå Error hooking ${atomPath}:`, error);
          }
      }

      // ==================== SLOT INDEX TRACKING - ADVANCED ====================
      // Hook directly into the atom cache to track slot changes
      function listenToSlotIndexAtom() {
          productionLog('üîç [SLOT-ATOM] Starting slot index atom listener...');

          // Initialize the slot index
          if (typeof window._mgtools_currentSlotIndex === 'undefined') {
              window._mgtools_currentSlotIndex = 0;
              console.log('üéØ [SLOT-ATOM] Initialized slot index to 0');
          }

          // Method 1: Try to hook via jotaiAtomCache
          const tryHookingViaCache = () => {
              const atomCache = targetWindow.jotaiAtomCache?.cache || targetWindow.jotaiAtomCache;
              if (!atomCache || !atomCache.get) {
                  productionLog('‚è≥ [SLOT-ATOM] Waiting for jotaiAtomCache...');
                  return false;
              }

              // Look for the slot index atom path
              const possiblePaths = [
                  '/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotIndexAtom',
                  'myCurrentGrowSlotIndexAtom',
                  'myCurrentGrowSlotIndex'
              ];

              for (const path of possiblePaths) {
                  const atom = atomCache.get(path);
                  if (atom && atom.read) {
                      productionLog(`‚úÖ [SLOT-ATOM] Found slot atom at: ${path}`);

                      // Hook the read function
                      const originalRead = atom.read;
                      atom.read = function(get) {
                          const value = originalRead.call(this, get);
                          const idx = Number.isFinite(value) ? value : 0;

                          // Only update if changed
                          if (window._mgtools_currentSlotIndex !== idx) {
                              window._mgtools_currentSlotIndex = idx;
                              console.log(`üéØ [SLOT-ATOM-CACHE] Slot index changed to: ${idx}`);

                              // Update display
                              if (typeof insertTurtleEstimate === 'function') {
                                  requestAnimationFrame(() => insertTurtleEstimate());
                              }
                          }

                          return value;
                      };

                      return true;
                  }
              }

              // List all atoms to find the right one
              const allAtoms = Array.from(atomCache.keys());
              const slotAtoms = allAtoms.filter(key =>
                  key.includes('Slot') ||
                  key.includes('slot') ||
                  key.includes('Index') ||
                  key.includes('index')
              );

              productionLog('üîç [SLOT-ATOM] Slot-related atoms found:', slotAtoms);

              // Try to find it in the list
              const slotIndexAtom = slotAtoms.find(key =>
                  key.includes('GrowSlotIndex') ||
                  key.includes('CurrentGrowSlotIndex')
              );

              if (slotIndexAtom) {
                  productionLog(`üéØ [SLOT-ATOM] Found potential slot atom: ${slotIndexAtom}`);
                  return tryHookingViaCache(); // Retry with the found path
              }

              return false;
          };

          // Method 2: Watch for X/C keypresses and arrow clicks
          const setupKeyWatcher = () => {
              productionLog('üéÆ [SLOT-ATOM] Setting up X/C key and arrow click watcher as fallback...');

              let lastCropCount = 0;
              let lastCropHash = '';

              // Helper to get crop hash for change detection
              const getCropHashSimple = (crops) => {
                  if (!crops || !crops.length) return '';
                  return crops.map(c => `${c.species}_${c.endTime}`).join('|');
              };

              // Update function
              const updateSlotIndex = (direction) => {
                  const currentCrop = UnifiedState.atoms.currentCrop || window.currentCrop || [];
                  const sortedIndices = UnifiedState.atoms.sortedSlotIndices || window.sortedSlotIndices;

                  if (!currentCrop || currentCrop.length <= 1) return;

                  // Get the max valid index based on sorted indices or crop length
                  const maxIndex = sortedIndices?.length || currentCrop.length;

                  if (direction === 'forward') {
                      window._mgtools_currentSlotIndex = (window._mgtools_currentSlotIndex + 1) % maxIndex;
                  } else if (direction === 'backward') {
                      window._mgtools_currentSlotIndex = (window._mgtools_currentSlotIndex - 1 + maxIndex) % maxIndex;
                  }

                  console.log(`üéØ [SLOT-KEY] Cycled ${direction} - slot index: ${window._mgtools_currentSlotIndex}/${maxIndex}`);

                  // Update display immediately
                  setTimeout(() => {
                      if (typeof insertTurtleEstimate === 'function') {
                          insertTurtleEstimate();
                      }
                  }, 100);
              };

              // Key listener
              targetDocument.addEventListener('keydown', (e) => {
                  // Skip if typing in input
                  const active = targetDocument.activeElement;
                  if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA')) return;

                  const currentCrop = UnifiedState.atoms.currentCrop || window.currentCrop || [];
                  if (!currentCrop || currentCrop.length <= 1) return;

                  // Check if crop changed (new tile)
                  const currentHash = getCropHashSimple(currentCrop);
                  if (currentHash !== lastCropHash) {
                      window._mgtools_currentSlotIndex = 0;
                      lastCropHash = currentHash;
                      lastCropCount = currentCrop.length;
                      console.log(`üîÑ [SLOT-KEY] New crop detected, reset index to 0`);
                  }

                  if (e.key.toLowerCase() === 'x') {
                      updateSlotIndex('forward');
                  } else if (e.key.toLowerCase() === 'c') {
                      updateSlotIndex('backward');
                  }
              }, true);

              // Arrow button click detection
              targetDocument.addEventListener('click', (e) => {
                  const target = e.target;
                  if (!target) return;

                  // Check for arrow buttons in the tooltip
                  const button = target.closest('button');
                  if (!button) return;

                  // Look for chevron icons or arrow text
                  const hasLeftArrow = button.querySelector('svg[data-icon="chevron-left"]') ||
                                       button.innerHTML.includes('chevron-left') ||
                                       button.getAttribute('aria-label')?.includes('Previous');

                  const hasRightArrow = button.querySelector('svg[data-icon="chevron-right"]') ||
                                        button.innerHTML.includes('chevron-right') ||
                                        button.getAttribute('aria-label')?.includes('Next');

                  if (hasLeftArrow) {
                      console.log('‚¨ÖÔ∏è [SLOT-ARROW] Left arrow clicked');
                      updateSlotIndex('backward');
                  } else if (hasRightArrow) {
                      console.log('‚û°Ô∏è [SLOT-ARROW] Right arrow clicked');
                      updateSlotIndex('forward');
                  }
              }, true);

              console.log('‚úÖ [SLOT-ATOM] Key and arrow watchers installed');
          };

          // Install key watcher immediately as backup
          setupKeyWatcher();

          // Also try cache hooking for better integration
          let attempts = 0;
          const checkInterval = setInterval(() => {
              attempts++;

              if (tryHookingViaCache()) {
                  clearInterval(checkInterval);
                  productionLog('‚úÖ [SLOT-ATOM] Successfully hooked slot index atom via cache!');
                  // Key watcher remains as backup
              } else if (attempts >= 10) {
                  clearInterval(checkInterval);
                  productionLog('‚ÑπÔ∏è [SLOT-ATOM] Using key watcher for slot tracking');
              }
          }, 1000);
      }

      // ==================== DRAGGABLE & RESIZABLE ====================
      // OPTIMIZED MAIN HUD DRAGGING SYSTEM - Professional and smooth
      function makeDraggable(element, handle) {
          let isDragging = false;
          let startX = 0;
          let startY = 0;
          let startLeft = 0;
          let startTop = 0;
          let animationFrame = null;
          let currentX = 0;
          let currentY = 0;
  
          handle.style.cursor = 'grab';
  
          // Shared drag start logic for both mouse and touch
          const startDrag = (clientX, clientY, event) => {
              if (event.target.tagName === 'BUTTON') return;
              // Don't start drag if clicking resize handle
              if (event.target.classList && event.target.classList.contains('mga-resize-handle')) return;
  
              event.preventDefault();
              event.stopPropagation();
  
              isDragging = true;
              startX = clientX;
              startY = clientY;
              currentX = startX;
              currentY = startY;
  
              const rect = element.getBoundingClientRect();
              startLeft = rect.left;
              startTop = rect.top;
  
              // Professional drag start effects with will-change for performance
              element.style.willChange = 'transform';
              element.style.transition = 'none';
              element.style.transform = 'scale(1.01)';
              element.style.boxShadow = '0 8px 32px rgba(0, 0, 0, 0.3)';
              element.style.zIndex = '999999';
              handle.style.cursor = 'grabbing';
  
              targetDocument.body.style.userSelect = 'none';
  
              debugLog('OVERLAY_LIFECYCLE', 'Started dragging main HUD', {
                  elementClass: element.className,
                  startPosition: { left: startLeft, top: startTop }
              });
          };
  
          // Shared drag move logic
          const handleDragMove = (clientX, clientY) => {
              if (!isDragging) return;
  
              const deltaX = clientX - startX;
              const deltaY = clientY - startY;
  
              // Enhanced boundary constraints with snap zones
              const snapZone = 15;
              let newLeft = startLeft + deltaX;
              let newTop = startTop + deltaY;
  
              // Viewport constraints
              newLeft = Math.max(0, Math.min(window.innerWidth - element.offsetWidth, newLeft));
              newTop = Math.max(0, Math.min(window.innerHeight - element.offsetHeight, newTop));
  
              // Snap to edges with visual feedback
              if (newLeft < snapZone) {
                  newLeft = 0;
                  element.style.borderLeft = '2px solid rgba(74, 158, 255, 0.5)';
              } else if (newLeft > window.innerWidth - element.offsetWidth - snapZone) {
                  newLeft = window.innerWidth - element.offsetWidth;
                  element.style.borderRight = '2px solid rgba(74, 158, 255, 0.5)';
              } else {
                  element.style.borderLeft = '';
                  element.style.borderRight = '';
              }
  
              if (newTop < snapZone) {
                  newTop = 0;
                  element.style.borderTop = '2px solid rgba(74, 158, 255, 0.5)';
              } else if (newTop > window.innerHeight - element.offsetHeight - snapZone) {
                  newTop = window.innerHeight - element.offsetHeight;
                  element.style.borderBottom = '2px solid rgba(74, 158, 255, 0.5)';
              } else {
                  element.style.borderTop = '';
                  element.style.borderBottom = '';
              }
  
              // Use direct positioning for more reliable movement
              element.style.left = `${newLeft}px`;
              element.style.top = `${newTop}px`;
          };
  
          // Shared drag end logic
          const endDrag = () => {
              if (isDragging) {
                  isDragging = false;
  
                  // Clean up styles
                  element.style.transition = 'all 0.2s ease';
                  element.style.transform = 'scale(1)';
                  element.style.boxShadow = 'var(--panel-shadow, 0 4px 12px rgba(0, 0, 0, 0.40))';
                  element.style.zIndex = '';
                  element.style.borderTop = '';
                  element.style.borderBottom = '';
                  element.style.borderLeft = '';
                  element.style.borderRight = '';
                  element.style.willChange = 'auto';
  
                  handle.style.cursor = 'grab';
                  targetDocument.body.style.userSelect = '';
  
                  // Save position
                  const finalPosition = {
                      left: element.style.left,
                      top: element.style.top
                  };
  
                  saveMainHUDPosition(finalPosition);
  
                  debugLog('OVERLAY_LIFECYCLE', 'Finished dragging main HUD', {
                      elementClass: element.className,
                      finalPosition
                  });
              }
          };
  
          // Mouse event handlers
          handle.addEventListener('mousedown', (e) => {
              startDrag(e.clientX, e.clientY, e);
          });
  
          document.addEventListener('mousemove', (e) => {
              handleDragMove(e.clientX, e.clientY);
          });
  
          document.addEventListener('mouseup', (e) => {
              endDrag();
          });
  
          // Touch event handlers
          handle.addEventListener('touchstart', (e) => {
              if (e.touches.length === 1) {
                  const touch = e.touches[0];
                  startDrag(touch.clientX, touch.clientY, e);
              }
          }, { passive: false });
  
          document.addEventListener('touchmove', (e) => {
              if (isDragging && e.touches.length === 1) {
                  const touch = e.touches[0];
                  handleDragMove(touch.clientX, touch.clientY);
                  e.preventDefault(); // Prevent scrolling while dragging
              }
          }, { passive: false });
  
          document.addEventListener('touchend', (e) => {
              endDrag();
          });
  
          document.addEventListener('touchcancel', (e) => {
              endDrag();
          });
      }
  
      // Save main HUD position
      function saveMainHUDPosition(position) {
          try {
              MGA_saveJSON('MGA_mainHUDPosition', position);
              debugLog('OVERLAY_LIFECYCLE', 'Saved main HUD position', { position });
          } catch (error) {
              debugError('OVERLAY_LIFECYCLE', 'Failed to save main HUD position', error, { position });
          }
      }
  
      // Load main HUD position on startup
      function loadMainHUDPosition(element) {
          try {
              const savedPosition = MGA_loadJSON('MGA_mainHUDPosition', null);
              if (savedPosition && savedPosition.left && savedPosition.top) {
                  const leftPx = parseInt(savedPosition.left);
                  const topPx = parseInt(savedPosition.top);
  
                  if (!isNaN(leftPx) && !isNaN(topPx) &&
                      leftPx >= 0 && topPx >= 0 &&
                      leftPx < window.innerWidth && topPx < window.innerHeight) {
  
                      element.style.left = savedPosition.left;
                      element.style.top = savedPosition.top;
  
                      debugLog('OVERLAY_LIFECYCLE', 'Restored main HUD position', { position: savedPosition });
                  }
              }
          } catch (error) {
              debugError('OVERLAY_LIFECYCLE', 'Failed to load main HUD position', error);
          }
      }
  
      // ==================== UNIFIED RESIZE SYSTEM ====================
      function makeElementResizable(element, options = {}) {
      const {
          minWidth = 300,
          minHeight = 250,
          maxWidth = window.innerWidth * 0.9,
          maxHeight = window.innerHeight * 0.9,
          handleSize = 12,
          showHandleOnHover = true
      } = options;
  
      // Check if element already has a resize handle - remove it to prevent duplicates
      const existingHandle = element.querySelector('.mga-resize-handle');
      if (existingHandle) {
          existingHandle.remove();
      }
  
      // Create resize handle
      const resizeHandle = document.createElement('div');
      resizeHandle.className = 'mga-resize-handle';
      resizeHandle.title = 'Drag to resize';
      resizeHandle.style.cssText = `
          position: absolute;
          bottom: 0;
          right: 0;
          width: ${handleSize}px;
          height: ${handleSize}px;
          cursor: se-resize;
          background: linear-gradient(-45deg, transparent 35%, rgba(74, 158, 255, 0.7) 45%, rgba(74, 158, 255, 0.9) 50%, rgba(74, 158, 255, 0.7) 55%, transparent 65%);
          border-radius: 0 0 4px 0;
          opacity: ${showHandleOnHover ? '0.5' : '0.7'};
          transition: opacity 0.2s ease, background 0.2s ease;
          z-index: 10;
          pointer-events: auto;
      `;
      element.appendChild(resizeHandle);
  
      if (showHandleOnHover) {
          element.addEventListener('mouseenter', () => { resizeHandle.style.opacity = '1.0'; });
          element.addEventListener('mouseleave', () => {
              if (!element.hasAttribute('data-resizing')) {
                  resizeHandle.style.opacity = '0.5';
              }
          });
      }
  
      let isResizing = false;
      let startX, startY, startWidth, startHeight;
      let rafId = null;
  
      const onMouseMove = (e) => {
          if (!isResizing) return;
  
          // Throttle with rAF for smoothness
          if (rafId) cancelAnimationFrame(rafId);
          rafId = requestAnimationFrame(() => {
              const newWidth = Math.max(minWidth, Math.min(maxWidth, startWidth + (e.clientX - startX)));
              const newHeight = Math.max(minHeight, Math.min(maxHeight, startHeight + (e.clientY - startY)));
              element.style.width = `${newWidth}px`;
              element.style.height = `${newHeight}px`;
          });
      };
  
      const stopResizing = () => {
          if (!isResizing) return;
          isResizing = false;
          element.removeAttribute('data-resizing');
          document.body.style.cursor = '';
          document.body.style.userSelect = '';
          resizeHandle.style.opacity = showHandleOnHover ? '0.5' : '0.7';
  
          // Unbind listeners safely
          document.removeEventListener('mousemove', onMouseMove);
          document.removeEventListener('mouseup', stopResizing);
      };
  
      resizeHandle.addEventListener('mousedown', (e) => {
          e.preventDefault();
          e.stopPropagation();
  
          isResizing = true;
          element.setAttribute('data-resizing', 'true');
  
          startX = e.clientX;
          startY = e.clientY;
          startWidth = element.offsetWidth;
          startHeight = element.offsetHeight;
  
          document.body.style.cursor = 'se-resize';
          document.body.style.userSelect = 'none';
  
          // Bind move/up only for duration of resize
          document.addEventListener('mousemove', onMouseMove);
          document.addEventListener('mouseup', stopResizing);
      });
  
      return resizeHandle;
  }
  
  
      // Legacy function for backward compatibility
      function makeResizable(element, handle) {
          // If a handle is provided, we're using the old system - just add simple resize
          if (handle) {
              return makeElementResizable(element, { showHandleOnHover: false });
          }
          return makeElementResizable(element);
      }
  
      // ==================== TOGGLE BUTTON DRAGGING ====================
      function makeToggleButtonDraggable(toggleBtn) {
          let isDragging = false;
          let startX = 0;
          let startY = 0;
          let startLeft = 0;
          let startTop = 0;
          let clickStarted = false;
          let animationFrame = null;
          let currentX = 0;
          let currentY = 0;
  
          toggleBtn.addEventListener('pointerdown', (e) => {
              e.preventDefault();
              e.stopPropagation();
  
              clickStarted = true;
              isDragging = false; // Don't start dragging immediately
              startX = e.clientX;
              startY = e.clientY;
              currentX = startX;
              currentY = startY;
  
              const rect = toggleBtn.getBoundingClientRect();
              startLeft = rect.left;
              startTop = rect.top;
  
              // Add will-change for better performance
              toggleBtn.style.willChange = 'transform';
              toggleBtn.style.cursor = 'grabbing';
          });
  
          document.addEventListener('pointermove', (e) => {
              if (!clickStarted) return;
  
              // Once dragging starts, don't check for MGA events to prevent dropping
              if (!isDragging) {
                  // Only check isMGAEvent before drag starts
                  if (!isMGAEvent(e)) {
                      return;
                  }
              }
  
              currentX = e.clientX;
              currentY = e.clientY;
  
              const deltaX = Math.abs(currentX - startX);
              const deltaY = Math.abs(currentY - startY);
  
              // Only start dragging if mouse moved more than 3px (more responsive)
              if (!isDragging && (deltaX > 3 || deltaY > 3)) {
                  isDragging = true;
                  toggleBtn.style.transition = 'none';
                  toggleBtn.style.boxShadow = '0 8px 32px rgba(74, 158, 255, 0.6)';
                  toggleBtn.style.zIndex = '999999';
                  // Capture pointer for reliable tracking
                  toggleBtn.setPointerCapture(e.pointerId);
              }
  
              if (isDragging) {
                  // Direct position update without transform
                  const moveX = currentX - startX;
                  const moveY = currentY - startY;
  
                  let newLeft = startLeft + moveX;
                  let newTop = startTop + moveY;
  
                  // Constrain within viewport with padding
                  const padding = 10;
                  newLeft = Math.max(padding, Math.min(window.innerWidth - toggleBtn.offsetWidth - padding, newLeft));
                  newTop = Math.max(padding, Math.min(window.innerHeight - toggleBtn.offsetHeight - padding, newTop));
  
                  // Use direct positioning instead of transform for more reliable movement
                  toggleBtn.style.right = '';
                  toggleBtn.style.bottom = '';
                  toggleBtn.style.left = `${newLeft}px`;
                  toggleBtn.style.top = `${newTop}px`;
              }
          });
  
          document.addEventListener('pointerup', (e) => {
              if (clickStarted) {
                  // Once drag is active, don't check MGA event
                  if (!isDragging && !isMGAEvent(e)) {
                      return;
                  }
  
                  if (isDragging) {
                      // Release pointer capture
                      toggleBtn.releasePointerCapture(e.pointerId);
  
                      // Finish dragging
                      isDragging = false;
                      toggleBtn.style.transition = 'all 0.2s ease';
                      toggleBtn.style.boxShadow = '0 4px 20px rgba(74, 158, 255, 0.4)';
                      toggleBtn.style.zIndex = '999998';
                      toggleBtn.style.cursor = 'grab';
                      toggleBtn.style.willChange = 'auto';
  
                      // Save position (already applied directly)
                      const finalPosition = {
                          left: toggleBtn.style.left,
                          top: toggleBtn.style.top,
                          right: '', // Clear right positioning
                          bottom: '' // Clear bottom positioning
                      };
                      saveToggleButtonPosition(finalPosition);
  
                      debugLog('OVERLAY_LIFECYCLE', 'Toggle button dragged to new position', finalPosition);
                  } else {
                      // This was a click, not a drag - trigger the toggle functionality
                      toggleBtn.style.willChange = 'auto';
                      toggleBtn.style.cursor = 'grab';
  
                      const panel = UnifiedState.panels.main;
                      const isCurrentlyVisible = panel.style.display !== 'none';
                      const newVisibility = !isCurrentlyVisible;
  
                      panel.style.display = newVisibility ? 'block' : 'none';
  
                      // Hide any stuck tooltips when panel is toggled
                      if (window.MGA_Tooltips && window.MGA_Tooltips.hide) {
                          window.MGA_Tooltips.hide();
                      }
  
                      // Save visibility state
                      UnifiedState.data.settings.panelVisible = newVisibility;
                      MGA_saveJSON('MGA_data', UnifiedState.data);
  
                      debugLog('OVERLAY_LIFECYCLE', `Panel toggled: ${newVisibility ? 'visible' : 'hidden'}`);
                  }
  
                  clickStarted = false;
              }
          });
      }
  
      // Save toggle button position
      function saveToggleButtonPosition(position) {
          try {
              MGA_saveJSON('MGA_toggleButtonPosition', position);
              debugLog('OVERLAY_LIFECYCLE', 'Saved toggle button position', { position });
          } catch (error) {
              debugError('OVERLAY_LIFECYCLE', 'Failed to save toggle button position', error, { position });
          }
      }
  
      // Load toggle button position on startup
      function loadToggleButtonPosition(toggleBtn) {
          try {
              const savedPosition = MGA_loadJSON('MGA_toggleButtonPosition', null);
              if (savedPosition) {
                  if (savedPosition.left && savedPosition.top) {
                      const leftPx = parseInt(savedPosition.left);
                      const topPx = parseInt(savedPosition.top);
  
                      if (!isNaN(leftPx) && !isNaN(topPx) &&
                          leftPx >= 0 && topPx >= 0 &&
                          leftPx < window.innerWidth && topPx < window.innerHeight) {
  
                          toggleBtn.style.right = '';
                          toggleBtn.style.bottom = '';
                          toggleBtn.style.left = savedPosition.left;
                          toggleBtn.style.top = savedPosition.top;
  
                          debugLog('OVERLAY_LIFECYCLE', 'Restored toggle button position', { position: savedPosition });
                      }
                  }
              }
          } catch (error) {
              debugError('OVERLAY_LIFECYCLE', 'Failed to load toggle button position', error);
          }
      }
  
      // ==================== VERSION CHECKER ====================
      async function checkVersion(indicatorElement) {
          // Skip version check on Discord to avoid CSP violations
          if (isDiscordPage) {
              const branchName = IS_LIVE_BETA ? 'Live Beta' : 'Stable';
              indicatorElement.style.color = IS_LIVE_BETA ? '#4a9eff' : '#888'; // Blue for beta, gray for stable
              indicatorElement.title = `v${CURRENT_VERSION} (${branchName}) - Version check disabled on Discord\nShift+Click: Stable ‚Ä¢ Shift+Alt+Click: Live Beta`;
              indicatorElement.style.cursor = 'pointer';

              indicatorElement.addEventListener('click', (e) => {
                  e.stopPropagation();
                  if (e.shiftKey && e.altKey) {
                      window.open(BETA_DOWNLOAD_URL, '_blank');
                  } else if (e.shiftKey) {
                      window.open(STABLE_DOWNLOAD_URL, '_blank');
                  }
              });
              return;
          }
  
          // Try multiple URLs in order
          // Add cache-busting timestamp to avoid GitHub CDN cache (updates every ~5 min)
          const cacheBust = `?t=${Date.now()}`;
          const branch = IS_LIVE_BETA ? 'Live-Beta' : 'main';
          const branchName = IS_LIVE_BETA ? 'Live Beta' : 'Stable';
          const urls = [
              `https://raw.githubusercontent.com/Myke247/MGTools/${branch}/MGTools.user.js${cacheBust}`,
              `https://raw.githubusercontent.com/Myke247/MGTools/master/MGTools.user.js${cacheBust}`, // fallback
              'https://api.github.com/repos/Myke247/MGTools/contents/MGTools.user.js' // API doesn't need cache-bust
          ];
  
          for (let i = 0; i < urls.length; i++) {
              try {
                  const url = urls[i];
                  const isGitHubAPI = url.includes('api.github.com');
                  const isJSON = url.includes('.json');
  
                  const response = await fetch(url, {
                      method: 'GET',
                      cache: 'no-cache',
                      headers: isGitHubAPI ? {
                          'Accept': 'application/vnd.github.v3.raw'
                      } : {}
                  });
  
                  if (!response.ok) {
                      if (i === urls.length - 1) {
                          throw new Error(`All URLs failed. Last: ${response.status}`);
                      }
                      continue; // Try next URL
                  }
  
                  const text = await response.text();
                  let latestVersion;
  
                  if (isJSON) {
                      // Parse version.json format: {"version": "2.0.0"}
                      try {
                          const data = JSON.parse(text);
                          latestVersion = data.version;
                      } catch (e) {
                          continue; // Try next URL
                      }
                  } else {
                      // Parse userscript @version tag
                      const match = text.match(/@version\s+([\d.]+)/);
                      if (match) {
                          latestVersion = match[1];
                      }
                  }
  
                  if (latestVersion) {
                      const versionComparison = compareVersions(CURRENT_VERSION, latestVersion);

                      if (versionComparison === 0) {
                          // Versions are equal - up to date
                          indicatorElement.style.color = IS_LIVE_BETA ? '#4a9eff' : '#00ff00'; // Blue for beta, green for stable
                          indicatorElement.title = `v${CURRENT_VERSION} (${branchName}) - Up to date! ‚úì\nClick: Recheck ‚Ä¢ Shift+Click: Stable ‚Ä¢ Shift+Alt+Click: Live Beta`;
                          indicatorElement.style.cursor = 'pointer';

                          // Add click handler for downloads
                          const newIndicator = indicatorElement.cloneNode(true);
                          indicatorElement.parentNode.replaceChild(newIndicator, indicatorElement);

                          newIndicator.addEventListener('click', (e) => {
                              e.stopPropagation();
                              if (e.shiftKey && e.altKey) {
                                  window.open(BETA_DOWNLOAD_URL, '_blank');
                              } else if (e.shiftKey) {
                                  window.open(STABLE_DOWNLOAD_URL, '_blank');
                              } else {
                                  newIndicator.style.color = '#888';
                                  newIndicator.title = `v${CURRENT_VERSION} - Checking for updates...`;
                                  checkVersion(newIndicator);
                              }
                          });
                      } else {
                          // Either development version (yellow) or update available (red)
                          if (versionComparison > 0) {
                              // Local version is newer - development version
                              indicatorElement.style.color = IS_LIVE_BETA ? '#06b6d4' : '#ffff00'; // Cyan for beta dev, yellow for stable dev
                              indicatorElement.title = `v${CURRENT_VERSION} (${branchName}) - Development version (${branchName}: v${latestVersion})\nClick: Recheck ‚Ä¢ Shift+Click: Stable ‚Ä¢ Shift+Alt+Click: Live Beta`;
                          } else {
                              // GitHub version is newer - update available
                              indicatorElement.style.color = IS_LIVE_BETA ? '#ff00ff' : '#ff0000'; // VIBRANT MAGENTA for outdated beta, red for stable update
                              indicatorElement.title = `v${CURRENT_VERSION} (${branchName}) - Update available: v${latestVersion}\nClick: Recheck ‚Ä¢ Shift+Click: Stable ‚Ä¢ Shift+Alt+Click: Live Beta`;
                          }
                          indicatorElement.style.cursor = 'pointer';

                          // Remove old listener to avoid duplicates
                          const newIndicator = indicatorElement.cloneNode(true);
                          indicatorElement.parentNode.replaceChild(newIndicator, indicatorElement);

                          newIndicator.addEventListener('click', (e) => {
                              e.stopPropagation();
                              if (e.shiftKey && e.altKey) {
                                  window.open(BETA_DOWNLOAD_URL, '_blank');
                              } else if (e.shiftKey) {
                                  window.open(STABLE_DOWNLOAD_URL, '_blank');
                              } else {
                                  newIndicator.style.color = '#888';
                                  newIndicator.title = `v${CURRENT_VERSION} - Checking for updates...`;
                                  checkVersion(newIndicator);
                              }
                          });
                      }
                      return; // Success, exit
                  } else {
                      throw new Error('Version not found in response');
                  }
              } catch (e) {
                  if (i === urls.length - 1) {
                      // All attempts failed
                      indicatorElement.style.color = IS_LIVE_BETA ? '#4a9eff' : '#ffa500'; // Blue for beta, orange for error
                      indicatorElement.title = `v${CURRENT_VERSION} (${branchName}) - Check failed\nClick: Retry ‚Ä¢ Shift+Click: Stable ‚Ä¢ Shift+Alt+Click: Live Beta`;
                      indicatorElement.style.cursor = 'pointer';

                      // Remove old listener to avoid duplicates
                      const newIndicator = indicatorElement.cloneNode(true);
                      indicatorElement.parentNode.replaceChild(newIndicator, indicatorElement);

                      newIndicator.addEventListener('click', (e) => {
                          e.stopPropagation();
                          if (e.shiftKey && e.altKey) {
                              window.open(BETA_DOWNLOAD_URL, '_blank');
                          } else if (e.shiftKey) {
                              window.open(STABLE_DOWNLOAD_URL, '_blank');
                          } else {
                              newIndicator.style.color = '#888';
                              newIndicator.title = `v${CURRENT_VERSION} - Checking for updates...`;
                              checkVersion(newIndicator);
                          }
                      });
                      console.log('[VERSION CHECK] All methods failed:', e);
                  }
              }
          }
      }
  
      // ==================== UI CREATION ====================
      function createUnifiedUI() {
          productionLog('üé® Creating Hybrid Dock UI...');
  
          // Add hybrid styles
          const styleSheet = targetDocument.createElement('style');
          styleSheet.textContent = UNIFIED_STYLES;
          targetDocument.head.appendChild(styleSheet);
  
          // Create hybrid dock
          const dock = targetDocument.createElement('div');
          dock.id = 'mgh-dock';
          dock.className = 'horizontal';
  
          // Primary tabs
          const primaryTabs = ['pets', 'abilities', 'seeds', 'values', 'timers', 'rooms', 'shop'];
  
          // Tail group tabs (Tools, Settings, Hotkeys, Protect, Notifications, Help)
          const tailTabs = ['tools', 'settings', 'hotkeys', 'protect', 'notifications', 'help'];
  
          // Icon mapping
          const icons = {
                  pets: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAANIAAADkCAMAAADaZIrAAAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAACXBIWXMAAC4jAAAuIwF4pT92AAAC/VBMVEVHcEz5nVv5jGPnqWjcqnb3nlf6tGXC1apD6bJE6878nV33Z+H6t1P9jIDuzW+9mdig4V261+D+hFvsnKHx0VO0PL7ygrJD7pFs7HyP8syy5kGkNaS0y1quMbLlski6TOHR6Gdc6UfSapulr+/iSvxJQy/+4X//yIH+1Hn+24D86XD+8H20NMr923j943f8+3j+z4H6+mn+1oH86mf88G7+6H/+zHr96nj+xXn98XbV+2f/uH7G+2fj+2jv+2fy/XbjUvwtad/9zHP/wID91m40SS8reN0s35Bk+rIsht7kW/1Q97Vk+sVm+6dQ+KZl+rvo/Xb88WVp+423+2Zj+tCq/GtP98QtV+As34JOtfYskt9jeO9qY+/8wFaB+Pwt4J2e+2RR1vemRu1i+tyxRe1P9fT/3cos33Jx+2d+5vxS+JAs315P99T84Gn9tVZPxvZ6M+Fi+por3raP+2Yw3jAs36na/Xb/fllBm+os38+7SOpl+3OA+2VO5vZ+1fz74VR17bRRjPjL/XVO9uT/rYCaSe0u394tRt8snt9S+Xgt30hh+un711Rg9/hvM+FBqupi+oNK4DAyNOHt2nj9qVf+jllqovNu/H5Rofgs3sP5zFFmjfEsqd9wtfaB/fLKXP1RcviA3SssyN9rSfHdS/jWVfx1xvhg+mX/18ksvd+HM+E/uellMuAstN9l3StUV/i/Yf1GMOHWyqqZ3SqHXe1ASS8t0+Cw3ixZ+FNAjeruTfxXMeCMRe7G3izWYv25/HWP/+D/4sr9m1hbSO/t03hBy+px+FL+zFeZ/HKDtv6I+VH861V6Re+q+VE/futf5flt+5t+dv1D6Zl27J/Z3SyB/ub0W/oveeKD/HHfzi1L8WBBbOyW8ElD4eeL/9KWNOFKRvD5+VSwZPx6mf7U+1RD6Hzo+1To2EPB+lO8OtpJWu0hLdOz6EVx6EUm2Kni50OyO9pYXjv/x6nM6UQfXNKQi1rJP+Zwc036d7TIsF7ox0VhtVmzqoypu5JHcExw1ESbAAAA/3RSTlMAnGIQIDx9/v7+vvzf/lv+/P7b+rp9uXxClpFP+bP3w/rC+7///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////wAoptLHAAAycklEQVR42uSbPWtbaRbHR7alwtghBBfLEoZpolfulaLEV/eOkhgkfQBv4dKQygwBp7SKXTAYNQIVU1jkI0RfIODORIVtZNwH4cZgggs31hLM7G5gz9vzduXpdB0vex4pyxZT/Pid8z/PlaWffvp/r/n03FwmlVpcXFpa2qd6jwX/b2llcSWVymQepdPz/yswc3OpJ/3+EAtI6J/3Upt8sOB/EXExBWwPGW2BaICHiYb7QzG0r4HsOt485tpcST1KP0CedIZwCGmKaD+m6ZiPhurBeyXzoLDmM0/a7Xa/3Xeo4pboX8uRxQRQvV7veOXRwgMRtMg8TDTsUA2FR0+S9N175hEkzQNECNXrPQQqAmozVGcy2NqC19bW58+T5v6+bcmZpmMZpc1pJqBKPwQgdLQ8ARrh+YxvoILKcVVyuSAMG2FjM9S9F+s7U0uPftwMpdqq+h3GISQCEiaFZFe+0Wg4imiSWvDPdm+3twv1o6DmDFC7PxEkzYNlHFU0VFVVvtXQioylXWI63V1a+FGKlvsIBMkwMIo01MRCqtC7yoerUC0UWq1jsYQ4CLS9S3W6m7n3xQq5vTwZDAYTirqOIH22q6LnqCKWDBDyUGULnlHU291VRLv3LQqJEAgLgDqdieo6Q5XLNZ2uqzpImgiPt01AoKgnQKdQvUf3S7Q8UDWhTbQVHyUh4nDIqUGyu46ZpDyS1LMsQWV+iCPFNHH7Duao6YyR03aaKEuWoFZXs/621XanVL17Y3KItgaDaaRKUzmq6ARnnoqtSHiACM/qKkG9QCBhui9PmbbVdrhglSatKGcRVawAryhFVYdIgFYFCrvu9PQ+mRYgvDsWEVyCOp16vT7YMj3nxLdF47RdVkvCvhOmosGBuji9yNxP27UHjqUt0FTvNAdiCIGasWC4O7+z2ZilErxe6LZDoouL5HMPLw3LjiQoIAJPkwHd6+yumyZSTNnYIBkomwnqdOE+JFnhsMXTVCeoZlMhNd27HRPpnVQlJJtJFWoqFU9tSxcr93GzmxhHrGkCjupNQKobSRU7HAxRQaedDgftiICgasJDRBdJj9OiiySXVUISS9aKtcPB5IOzklbtbCjhwdcL3XZU80nHnaTDlilCaqq2iydDZXrFWtlgtR0TUf0NeBjpK5xENaUMks4GuAU1se0cSZWcdbdTkqyNZHBcIsUkigAIanc+4XCQxnMk8RTZbWc981Xv7rmCy2TxlErlSJC4EtSU5me+ZafzPutwsPrOuYJLhBesJRtfSaVVNUdSuusQKcFpUo/mk4EOO7gt0CARU040WfegqqXJfqKI3YTctiuXys+NpcskNT1RHzWoB3NeSfXptrsjG8RS9k9myTKESGWL6PLrSsJ911/uyGMsANG9QUYppx05RJX4E8VdWVcyfYdAZdSkiKDSSe7Zdr9NN+/BZNLki5BO8Dvu3/ZDUvyyakHZ2VBmprULA3T59a+J7Vn+WLWjy+Kx8jt2Ac/Hn82nbkF2Liii8htNdHV5+UtCSKSo3R4qHiGqx8KOmAJhyss9KK9vqybrsvbVzooGqrU3ytJVcp2Xlk+4Ogapw0D2ljWSgmqAOzYPxwMejyR505fV0lQ0ABDUV1T0lSxdXWYSG6W+jJKxFJcU5IIKvAKRpNOOrt9efCXVdONpS5qJLBEQ1EpCW8kZpbpuPO0IcMBQIB8Uc9OBpIJX9Qp47OdYnxXV3FEqS9dhveZouOKaT2grIdHQnSSd3yEcajxUFCASNx1SqWck0ORlfSDyGaoWZ5JJAqD19deXBunsKp1MOtDfkGLZwIrCkHsOYIKKAOWrcgrsCHGo/KxWREA1J+sg7BAISvNAXWUSSYc+NZ4V39YzEjkKeJTgaKKqhAMgYdd5WZIEmuDQINWcjcRAFtIlKQKmJIZpTv5uqbJOgPCNikIGqkgy4CBVmIkniZuOFGV9miRkAiI8JEptJIAiop1fVdOhpZ+TSIc+//XS7ju9Z0MJO2g9ajzMhjx3HW8k6TuEAhY1SXBKq7U/syRI1Hhn/0rgY5XFvv5zrL4HkaYw5K4LFU/ATFVgYkVkCWk8kkRdR9EAeggogrOmk4GAdnZ2fjVAZ2f/TODTryfTfVdvhvBq8iShIcoHViTZIMlQEEXYdFmeI0SCzoOei8iQIVojInjptnsL7wSQzCjpJdskIJYUStzBKx9w1yFQHiXhW5JBDRIy0QyJpVLZpDe8EEiQoEYINfuba5q/etLXYYfXBgRqhjJF1HdqjJCImQoCxE2H+Y1dV6tRNpAjPDq/11Xb7ezsiaOzt6Pz0ehpEkjDPiMpS00CQkeh4qH8pnsDdp26NmQLNhEwUTDURFEpKlvJsG6I9l6dMdDobJQE0hxLGuqdFMIhKNizQMRUgWOpyj2n2466zpdR0gke6ZuQZtphplck6RyBRqPrhQQynDTpJYtMUE0KvEBdHYIgj4eBrHuD0uRj49XIEWritivrhSSSgGnPWDonS9fpJDIcvxuk0y7kLYtEgfSdclTJsyZsPCztCIlqPjLxPpJJKjv5TdGARHt7hHQ+YktzCSANqe+0IsIJOcADaDyGUjyUdXmPA9zHF7Uc84ikGgFFZXchGaJDdoR1NLrOJLCW8BtcVt9x2mHXqTlCnEAM5T0cJRojz/dYEEFJNMgURZG5fdthtydI5wrp6Do1+7XEX0rTY9TkORIazrt8gI7w7VHT8RQhTnyMSrUIHUU0SbKQ1kwwENDh4VuOhiOsx7NGWpCvQ3aYSBoPDQFUKFT5gByRJmw6GSTPtB2MUs0XRzVUFMWyzkg63EMkknSEUNdPZr2WBMmeJAk7BcRZx7OEQDRI0HQeOiKoGlgST6WINZXxqGtDnAiRjKVhApuWA09WkqQDAoVakYQDzRFfhejaAFAsqearYIBoQEtl7jtXEmWDIJ0rooOZI83J1zt120kJEGWd8GA48I7F8vFQ3/nsiNou4qwraUVmxTIQl3F0cHA9nPGuzchXpUmSpANupFClAzmivPP4yELyOBngXfN1eGPTUd2V3yobDg83BOkAiMDSjHdtSr6BK10XxizxGEnpZMAx4qbzfTLk63XEjmLPE3bYQZ1snLCkA6zr4dzMkYiJJIkjDWQpynMu5K2m84hn1bcMiaPoTxaSEB2enBxpIrA0Y6RF/lZxB4GUpkCnHUeDkaQ0EVNWSfKFyAHirltziIhpA4hORkcJIw3339OjrO46JGrACfINY8ltPNV1yOPbYSdQd2ykPZG0EbM04xvRkuo7siRAypIFRJ1nO/KsUVLBQJrKkfOhnbuQGAiQhGg8BqQZXx/k2+zv63XbUYiGGtR1DThQLSSy+k5LMqOkiKI7F9KhcoSjdMJEY2R6/POMkeQHBxZRA4gYiGiCeNxZhlTXFa1oIElrzvOE2UgbmHZQX8TRwbh7MJox0rxC0m1ngNiRKGoZItcSA9WiYjwa1uznCZUMBIRIRPRx3B13//F0th+4LsjPDTRQA4CQSRM1UBAOUsskg6fHqAiHiKwV+9y5NDgrVoC+fPlIcwRI3e5vjx/P9oonP6Gwl2yDw64hQC0n7Xy+r3IV/dhCeglA7seQ6qFPJG0IE1kiSQkg8U/GxFKDjgBZUNh54snXNwcEKvrgiTZS0Uo79aGdk3bYdRuupW5SlvDnVQKkJeVpJ03fhHxv24RDkTqvpoGi6LluPPsipAfp0G287scu1u+/z/YiLj9Hsiwhkeo7FMR+8qRoGyVtsyKSBK+oqIBQkhmk1/jpt7k1bIijL1gfPiIROuq+g/fMkfCnSKbtOOxEkM45AVJtV+R4QCIMPLT0svyS5+g5Eb1ej88R7aOTLyeCNCYgRprpHzcz8pMxC6gBhSPUaEl4S9S1fGo7LQlhipwLReuqyo5QETt6xUQm7ADow4e/j7np3r0DpPHCzJHEkjARVssMEjNty6O5SoYi53cRuq72kohQEipaW3+jPs4nR69U1m0opN8QidruHb7GCSBZlhgK56jR+HZ7c/Ps5vbbHwTEUKRoWzNFPEvRSzgqGd6gpV/wP/4E//HjvSlLHwhprC0lg7RpWyKiP26f3f4H6vbZs2c3AuVj72kgju+iCTs8/EDx9PbT7bfv379/u/n06ebfzkLSjcdA+Op2/zLTJ0CWtBmKov/Scj4hbadpHGeoU6el1IbuDivMYWAJDAFbQgLbBpOCJBAwMRqj0IPiIgVTjIMIUoiGUHvYxYqBLLrIxsMeLMvchCz0ZA6RmpOhIshCc5E9ziELQVxb2Off+yfRFqPd52eHYWBgPny+z/d9fz8YYaC8+8oNZ/3jNg1BnZSx6HrMIunoYTHgQ46ACELnbxSLHzt5TorF4sk9yxEqgslxMzyn+XP37zr+H0gMxZYe1TURjIiy65twXBqI6w5u3xi6H0HNJ6DZJibAC9XvWY6mECqek9TxRLO1zs7ur/R/qn7D/yup8Dzi0JXrTqch2v7oFKYUQrkEykWZ81I3uB8/lG4YDCBRQ3hw6qEQMCmgNDmKx+OaaAAmVuPJdn+FCN6e0cHj2FEvAMG2NQ1iKqt7HfKwpj94WRLeg+iMhdgBUbFTSwJNIWSa013XjPT++QBAhWs1RVXr7rg2Eg23nSCdAkDDRiJNzgYoQkkpJnJh0XE5uCl2kDqIXQOXp9OaT6EiMJ2pEwmh4lVAem4kaUu1Wgme7rtfx5KGCvbVL0ZynipLogl4vCDJy/fvJwQFsXMC0raVPCQKhRYsS/H1qgnec4WU0FT/eXX3upbGZrQjkXQhUuOBK0U8uEheF3ryEhD1Nx+xPxRbLXWGWJNFFK9W2dL7gRZLh/CUSg6Ho7PjWkhj8NNnoLDgnCcXIDnzapFcqhzwoaudEA2ipGK9OXg8R1NHU1PKUXWWBTFRf1anrlQ7LNE4bl714nenxVKwr4//822kulMlj4Co7bxeMsShkwMpMOgr0nyykE4EaWqK9wgcgaWqRTQwEBEkmsPDw81NYLqqqDv8uwCUIbjbnUrKWgqPkFx6jagYiEmA6Izl3DUlT0kKnaWnWNE6ALElAervj6lmEKbN0ubmeMnRfUUk/N0GGumnYFCQDJOKHfwjlTrvY5dX1khdVgODfv+8X5AM06e6RuI9IkXVahSB3gsRIpWUpFJpEy2N43RfJ3iSup+0JVinj82OECnlkvFai+RmRyBJI4XqlL1PjWLIIHHumCmqLfXDT0RtElsCpnFgKl2N6c4M/Waad48UlLaEp+vJSd3pdDZZQk/gCI4k9IRAfPsGS/P+eYVUDBXxXzZAYkkTRXXs2JJOXWmTkCB4MFASV7M0NjamyyEY7HN+dk5dtiS1SA+VJHhB+rGomWiKoWILkuQuqruhH5giliPKnSCNj2+3f0L9RX5RiADhm2z9s0hlDcSb5GZJAbyt4ib55n3KUaho0dCkDVA1i0hKUT8i2Y4sonHHdkf7SDR9GikYbHyOqC5Ej5GJTlncIzd3HTgCIt+JYQo1MdWx7YQoGo2GzSIhkjKEDW5LAqbbV0BqkgSWTr+cO7g2eHlIkUXkgxfzHxRPCxHkLm5Sl42GdehgRiMiaVMBaaJxh+Pu9S0FT74kyWugqBmoGAY5dS99L3uVppbYheJCFEVH0XBUYvcdEo1GzCF7eNgEND6eTN64EtI7vUkw5S+Wg5dWCXKHRxJKeoJIfogdEr28ZzTZUP9eN0zgKBsWSQNiSTInlsYNVDKZ7L6ypaDWdGH0GroZyBECud3q1oBEJKn35dlFjs40EUiqgqSwVQ6j/QkkqhHQoSFK8pN0dFwNSeHQND5HpNrO637sVmdsAMsONgkU9fbu9A6fsZ+WM0lOJExdNsyW+oVodDQBigyRKEIa+tPm4TSjgidIkLyeizwRkQceqQZd33zE+pjoZe/wzvDwWehcNZj+hmqAVYoR0ndCNBphoPNEMJmkw3GjXaT/jm3wKcueUsEHwVS5SdTJKcCQIyUJ5qE0A+2Rbx4y17uzM7wzMjJyr24D1c/Wc6bs0FIsFo5pR2TJ2qMWIgdAZW5ewRJdGyR1PSmgQqi6uhZxMXikGbi+n6CkQbysDvpYEoZuZxiIRvb2fj2xgPQaUX+HYQBKFzjM9EVIbChDf9luE2kDHrNHPcDTk0KsVOqUJkU4qEjFzo2WnrgDBISpm6diQKYRQprYmzv69QzmX2/S63zGxqW/wwAVi8XYEikavTU6qYlUM8hkECqT2f62XUsbTZYwekgUTLkAC4BSHrVHQGUsqSOJNoktce5GJvb25uaOjhamYNJ8syMiOZLCYYXElqZV8PQpmyQoxsG/2b7dFtIGIRkgQAFTKAq/CLn4fcJDufMYR243VoOfFolPJOAhIPyaT0BAlE4bIpKUjcZAEuQuxjicu+lJLcneIwTicWzfuEbwaJd6UjIufojIdIOXqoHLDm8NPqxvKjtK3QQiLRyRorQm4mrATYrp4DHRqIW02dR1zJPJVNrp8Rki2tCWUsF8GSePH1YJCX+QBxR5VNeBI0qdn652yINlx5L29phoQYhy8QOa7AEC4SKBpEhEeGCTpsmSytyKWqSMNRXH9+1a2tChK8vkAarJkT6RvOrSgEesz+8jR3AgkSJeozlZI/paLEQIZRzFDNK0QlreRJ7xZkVbgvSqoz1LuEs85bLFlMduYEm0SB52hHvEa+RXd1XsBSGamzOpA0XrBghHAYElVkRE08vmZpdskrQFTwXD9+rmFS3ZQIAEjedRkhBoSK7f7oAcSdR1WHW9vEdU3yIpDUy59fWDdYkdPVmOHQXP5G5p8tB03QoC7bMkRQSWbrdpSZDyZcsSMUnwPOqQHWJLTwL+gJQdWMJqkNhRM1i5yx0YS+yJLNViYmnaWFqmPVpJNm3S1hYxVRz37186eTOUu41352MHRPmUh0LnodQNAZA6YwN4xuIeoSSKHVTDxIghSjNRXCQx0IFCUsHj3C0tLQMQS6LcoaN9cgQ/SJSpdHX9ti0ktpRqBcrnH7g0knUgSdmZ2/fwsNS37jo8kdK67PQqMRIARRIqdEgESLBIK4ooqdcIJFWAqYLz+8sjbSiklm6gISBmGgIgr33EgiQKHaQOu2FCHUj6jIXLqtmkrIIiIkKC1N0ySOhoJbmPjnTocCoZeiqVG21b0gWe10B5ApJiGNJlR464vnvZEe/R3J5qBqpvvH43rRFNjYASCalvBFpaWtnERdJrJKFjR1tAg0Rdd9u3lLIUlRUStrdAqWsQNQPdvunS0Gs1wxwpombI8RuFqTs1SBQhpFsK6dkynUhJKTuJHU+hIsGrfNMmUsqyZHJnWTKSBglJrqpGkpxIU8pSLof3oHNECW2JJQHTsyUEWsE92qcjdkshgaKCsuS4f9mvrdYu5VuJ8maPRBKVHa2SlJ3V3wYJT6Qc3+3OBS8rSFzfSLT0DC3hgbRPTKBpX0kqbBUKytJla1yQ6PUo2FwN+bzXI5ZsSX4FJI7o2jAhRyxt0hvMHcZutjpbPbBxsgmyBESJiEX0bEXdGuiExcNINqlQKVTUXHaZBOk1vVTkRVG5OXbqQHIHFBItkhyxTDRBi3Q0JSdSjt9kgSnbnLtagokSquwECf0YQxkxBI4KlLxK5bhS+b4NpNcbQX7ps0OHqUMiCt2QKjvtyCKa0NWwoA8kdDQ7S18abE0KaHIyYYCeLS4u7u/v84G0r9sbiSpG0/FxV1tIFDyYpmrQ1wZT3wG7vrHr2NHchErdm7RKHcSOv6zaseO2QyRJHTAtPlv88OGfu7u7f9/d/fnnLQ0EWwR/1goFkVTputEG0uvXKYF6YCvyeIY8uhkuIrIOpAUpBnhH4j1CJHnpM4uUEEcwtqQPAARQv/A8fVqQZkBHawIElr69NNJrLnE18E6RQhxeJMCyLKnY2ZZU1yEUNoPKXZWDh58a4N08oiahLSHREiMh064wrdI8LdCsFY4pewB13HWzHUv8+QTHAzgp4tGWmuv7fHvTiaTO2HSOcjcLlvSbeVjdVTWQWBKixQ8G6JfVv62uvlh9AbMmTJVjIjruutxh+xuUBI92pJg8quyGdDfoakCm4V677ISI61v6e7ZqvgedJ7K7gZH+gUyrKOnFn5Do7du3f10rrK2Ro2NEun1ZJCIKniPykiOWFLDeY1nSsC67CdV1U28sIgG6gGgSkZaXJw3Rhz/+j7Jz+YkyS+NwWsVg04xJm7gbF67dTJxVhzZhU1JiY9AesKhKoMYYO4ABujWh0+1UjOOoILeFFR0wXkggXGNiRa2oLMbAAptiihAIt/QAJUVqQCaRBWE17+1cvg+V4i35A548v/N7zylsm7qBFPU1iaMoz9VwmHngZ//f0/vbKdwOxpJSpEKnibbcGTSR3Oyw7LAaKHb//q6GFeFBUkQntaP6+noiuoJIwSsmdTjoqKQ2WgJEsVisNcxAYCm9LyDE0m2No4D+TI4Eyd5IObiRTOjK3ESnNZHrHH1vAwESE81dCQaDdjFQ6FhSzAtIsavEg0gHMtJGMpKI6KKRVPiZjYSWfiqzz5FcVjF2NfpLO2TCLxv0RhImaQYgmgva1dBEjpAphpYmwdOiQkrrv7D7wgoeS7qoY3fULUnXt74HKUm/0kH6Ra8k4KlhSZ+zdIVPksMSl11UxS4Wm4nFFu8L0t40kW4nb98OaUnmJFHu3PVt97e77JioRkvSX9uxJAdSQ71UA1gaDA4qR7Vcd9Fajh1CzUzOsKb4/vRaXCyFeL0qHi67TxBR2ZX9ZcQmQkfNzY7UuapBA9WTpIYGWrGYOyUJ+7u2TSsiR5NINBNjpPj+gztDOnrRcY4U0bw7dbKQXPXdyTu2mYiAKe+jO/Z7Q0RIV+AcBeFipxZSE1cDHySKHQDBAA9+0kPai0RJtyXj6BgUuOP2fcZd33gN6vxBSaoRSS6gk3ohnWMgQKL6JiIYA1RLiqJedsSz2IpE8f0H0kYKMZK7GAqlGZak7PRCOkNEWpIcI9xIyKPLTjO5uo6ZsO0G8SBVVQ3K3dt3V/c3O4KTlAufFAK17gDpn4RkNcNRdlSoUgeaEt+KpGUiGrEdAVKntWSJyRBt3bFQDYKE/R2sUi+KKn7xhe/WMtGkil0xB29Hlm6HQiIppC05+vsbDF4iJ2dr7qz6lm6wLJn+Pumw1MBIQepvjF2wowoeEx33ZcLh8FXShN1QDFCgqDW+GEkP6Q+8lhCJePRJAqL5P0ns1FU1Zznn42XHRDWn7fZ21bfLUcMolR3GrqrHp958woM/4XDrVTpKKfhA6HAW0vpGhZDwf6xhYsdE8+xoSbVdQpfdiL2Qhri/f3E4KlC5c98azimiUUBiIrTUQ0BV9JQI32egcCt+/IBUnHroB0l+YNoBEp4lnrdc34VS31R2Cbu+y5zN0Gk2kiq7gjxrIxXZG8lyNDqqy87n8yFNhzz5wjKLQATj96dSKf9OLGVgOyTRUgh5jiqi+WOSuiWu74Q0w4i1kIZkITFSje5vfWsocixZ099INKoc9fh64GFepYAUEgItaqZ4/OHOkGAuHnXv2GPzsmLBkvProI9KKheiAqsYTjmfSA4iQArSQgJJPnWM7qtzFGZFrZA3vz+QClDsACmdq/gesRRSFztimuf6po30rUgiSyNnXDtWITWftiXl553Khw86KlJIFtMoBw8cDVb5IHg9JMlnSwIodsSWAvH0kTI22ZIEr5CBpL6XcCEluBqW3Tt2yC67Zoldgb2RKHjKUr2LaFSaocrX4/Pdd54jpQgktfrjHLw4UD1JBynj0CYWXlJJAqh57G9M3ZI8kRL6iTSi6nuY6nvIIJXrtsuzfmsubVdpCtzkbjSogXxNmL2wk4kcgSIK3n/YUlpIX20SUigEzfBWHSSOHRAtqbJb5tSp9wQSDUk13AIieU8U8EnKz4PQiaIix3vC8IwGCQlT52u6S5c7K3KiCc4RSgqkUm8IaWHhwPavi12bm5vJEDeeugfNq6/slvgVm8AFm0Ndx46Gf1LHqJMXEqSu3HrHkqST6hzJ90HO1AX/FuwAJB+2HTji66qzGVAPQAX8gUDqDSJFgOnw4W3ftV8CURItrfE5eltIF7t5KYYlCJ25BpXZ9W0VQ/lpdY7I0SmshpPqGFHq6reEDscnoburv+FyEXHqFFJ8Ib7w+/+ObFfjhwBpM7nGwUMg7Dp+9MlGovpePgO5GxGkYey6oU6LiRwV6IWUz/1dhJIq9auvwYEElmjHwtyVN0U0ykBh7jmBQktvUm/aUVK8sbq7+4/bNDgjJZOMJCvpGGpa4mtDIifBFzvZsWWYumFd37ea4SjVmLYrQEun8vJN2dGrz4qdOkhBYKLcqWdftNZjHSR/1G+QxFLkN0Q6nLFd3yUJKWlbkts31bdaSCOO3DkklTOTtpRnXxvOVTrKTuobT1JHkBxZ71iPLga/v9XKXeDNG7AUj7T39lZXVx85uM1S2tycmkrSmNSBIrkIJfTtmyUNYzUM/TCkHTkuQvkgCbsun2KHZVeJC+maq75ZEZaDz7xko15AatUHiYhmAgSESIH2SKS3t7exGpl2b4M0pZAQir9roPYmIGo7dOS8ffNCuiULiQ6SXrK8kIrk+i2Oztc3nNdlhx84SJA79Q0XKJr0eCY9UbVh/TEAgsz5FVN7exyJGpHpSMb2SJS85FpybW1tfl5dgxKq7Ggh0ROJHKGkTr2RoOykGgpoH+FJKqK6A0lUDddcGyk42iH9bb49iUa9HpjcqNwazCnSRI29hESWDh+EydjzKaSpKda0hj88S0vY3ujom2XrXkfHaFjq26SOX30F+tYgzVDJxXDt3DnXXXU0qHl06JjIsx5TkjB1aIigIoH29l5D1P37kwGciYO7PoNE0VtbCxHRB5pEIiE3O6rvET5I0gyYu1u4ZMvLtaTvyBG++qi/sb4r1Y49T18I8Tt2sKfH/M6lSRFB7nI961EhanVYAqSXLxVSt0Ha+NfXH4HaI0hTpEksrX0grJWVFfgZGTkzYiwN/2osYX1jN5TLQSpgSZC7IrkIIVM9Njj+Zgx/0Ue/ReoZNL/pk2ZAIgtJtR28KYgo8JKQGsXSX588GECqrOwD2V9vid9uhTQ1nnTwfEAcmtmVWZjV2dXh1SH9T9rhv3uC9V3Omgrg3gBlZ//1/KJ9Rftk5mTkV5eGiGPnVUS5jGS3t5b0EoFQUnf3q4UnOMiUtZF9Z8u35Ic00pRm4hGg2dmns49mHwESTMtq/4uWlrrp6emK6el30+9oxt6N6ckcy5TZlyk8++auwWdOObJ+jYSxi5Z4vZMeJspdv0qpU7FLCVGEcqccdS8wEqdvY2PDfZH9SoDG4c/4uFKkDIGip+RI5kXLi5bpOvq8q9BACinTABFRJhPtsx1ZoUMgLww1AwABkrkI6bYDIkDS1dDdfd2BhPFzMX2pJPG8HpfUCRQBPZplR6sI1IJM09qRTWRBKUcsyeWoCaHwe+ISIppkRYxk+jtlIaklW81ExDQgTBNZG87rxBcOIJ7nK6/NKcLYrT5SRCQJUlehUvfOmbkx4cn8NBB13c2SEgHyeD0KaX1d94LfAopEGo2khQUlCYgeDAycOHFiYiJr70eQpsQREb1+jvN05bnETkmC3JElPklbcjfmyp0wqYM0J9XQ1NZ28yYhIZPHayQVa0sPA6bA2ZIgEZHUA/QeDBBNTGTbZb7LtsSanjMRzSMYcaQl1QGRdZI0zpjBsWJHRwn/6snjrq6+vr42AkIiLxPJQfIgkbIEV2/d37al6wsLDkuEhJY2svc4kcSR5E5JQiBE6oc//f0tNJfqLrXUVVQ4meyzRFj38HPv3s8w/8B59uwxDBH1MdFNIfJ6uL9ZUvG65G7Gr1JHRICERK+uW46eDDyAYaQTJ7I2rL8QkeFyxEBPbaJ+RXQJpw6mAucCzFmc42ePHz9eery0tPTye/hc/hEGie4JEhF1IVGbcURAXt11CKSRLEkRgqomIlGESLhqVeNh8rI27uyykVjS661ENP02UZ2T6IImYqTSy6WXDRITPUOiri6VujZzjMRRrmG6UTxjVUNAgBDJEPGIIgDiw5SV/bV+ceyZcjSD6xgxEBJdalGK3I5okKcUDAnQj06ix13WOdJEVtcVk6Ti/xbfuEGCEOo34UGk6lecOh26gQcDShJ1HjDtNUifSx0ztfRL6owkdnTBILGk98R0z0gCIJLUx7G72eaI3aQED4jWwdH6DUBCqIDd4JHrkcgrGOsgPXBY4h7fuLPbiQQ842Tp9baWWFKFJjqrLL0vfY/DlojoZ5H02Ird/yk7n9eosiyOCzpDSZiZzcwoDs0g1DJ/RLkxxjhxI8aIELom4hCFsbUDSdEuglQSFCMWNERQjNYrZGK0OhjSplLOpmgXISpTCwMTJUWgGCoxsRYhuJzz69577nsvpr0VE5NVffie8z3nnXvrvVFPJBN0pNIIqjQ9MpKrnDuXP+dEmsmWPZUQh3USIEYyMu37n+d2LvCY6KHSyMXdhYtxiYRI/Zs27oYHOexmJeyeKmsQ/7aZRGE3wisHa1qJBCqVDRKr9OAnR0RMGHmffzQyMdLLl/GZ9DDW7IjojMokJNps20SiTbIGQhr2NHrqF6Sw2THR+sg0AsGachrNpAEom7WZ9IBV+nfBqMRIvzP1lpBeqhr73CXSM9++EeniDZNIvjls9pBEHHaGaNiPOp1GSGQrEiYSE+VAo2lCmp/PG41QJYeEeSTmcFyvlpYWafX2ffLtWxR6TkAPTYWNFKTYqEMeQzS7k9m1t4dKLEvESOtCNI9rjJlWZ7K40lyQeIFCBZLIqERO/nmfIPmNnfM6Y3Zx9h0m2uzvkagzZkfOYCrSPVeQ2Bhc2HVxQeIsIqRpQYImiDXKZsuEpMIOiQqeSIT0W4O0i9cxE/m3q0gXDBFXJKiw7Aymb5gVojiRTF/H1sBR10WJBEjTqNL8vFyZLyLUKgCteCoJkoo8kkm6or2fIp2dL9KvUglrLIukS5JtG7AgubbhqGtWPZVyOUICImCa4uvYMgkFKqVBpYwUpAcFDryISj9y5H2KdW9VkDz7thr5bUOP1zbMDg7vUJDavavYo557I9G6Czu5kAWaVUql1Z+sSBJ2hSgSe94fQ0i6V7Uaxfh3m0ICHkK6q1u7uO7bEZmCtGWYcusiEmnk5kEzHHbpXotUKBSO45evEpZbuWQ/FNJo1+5bVyTxOteret23JbIVSRH5BQmARCQkmldzyMlsGl9paYMKBRRJNEoJD/wsvSthbeJk+lmYqLUj9/5yQdJEbRJ0mgi8bjgadaOeNUiNtXGXQ7cTkeZlHIREkzQ/QaK0zSNcRJRiGn5JP87JdIi9LnI98WwHjZTZWWcQrxscvCvGoJwh1H4fPbolUdfljGGdiKYrzuvGZLI6ObmyAkAQdwYIjaEgLARDXylGkgbi0M/h/nvXa6QdkLTXhZBGVdvgdQ0Sd0hUq1Qq8/5gFddKOstIGUASlVIppw//gLgruSuM3z83K7b7/j7i3l6RDYedV5FUkeXAU0BWpHUKulqlhttIU04kISKZelmkBwbIEqVSrBar5EZ6v4m2DZ7ZWaawf/ebTPKv+rxrpNFw3+DCjpiIqFZDjSr5xZlFtoYxR9QEoowjCqnERClWST1u6+PHLySSfz0RLkhXlH3zBUWMfWtzIKItDyhniPLYrHpRhyvdS6kkRFadlHyn/5XA81rE8jifXr9+/dHG3DNtdhdDRGe8guSI7sYVJG3fEbPbYh4EwqCr5BFpcZGuzBlpxRCBSgVDVGASwRHBUmDiKYi8vQrp42uaFbv5lrXvuAvzNlOQrlyJK7GPIvZ9NnQZa3lGajVDRECwZsozZTE7irsmIFmJmAi+AlxOplSpVEqZZpwcgh+m+P7q+4WNZ4Jj/PuGH3Z+t2r9m+2b3O5fJNK9p9br9IQLNyhwrcNrZGStuFYzQWeZymVoGZBIVNIiARGtQJYieldKlT67bdx9rNLC+6sLCws/vNowKoXdTlekzRBRzNDunmqECGlLFuB0LU9MTBQFqaZEKgNTlqAIqMlxxyIFISLHBMl03EPag08lpWfAXTXPTHtx44a2B9V+94jbRQpS+KrPNatUYQ3P1pFlxEGiCULSIpVRJWhWgWlFRGqySjbwYpEw8ErvNNIhEmmBNHr1+BU+V+MxPuGgXr9gR0La8Xh2oseQgxZIDRpsw4BAcCm79ObN0NAEvogIFxMpkWh4gs13OmsyKcOpZAGCIMJUSkWQ0BwWNhZ+MM+uwq1LemoD7l5Wq231M24xVNumXeR4j+5Gymu7rLNn5wYGBoZ4TQwNWY2QyNj34mLeIwKmpthdL8VcUCjEEwWxKh2UJw8iEUtkn0JB+7F4e75EZ0eiM5Hgyz1LQ373aPARW52ZcD19cvse7fbhQS5aQ0PjQqSAkMlIlF8cY6CyAGWga8Cga2QyXiJFRUrGqbSXkHCD+R/mkTuoEGlE94zF/WW5C9fJ0x0nvPtP0KcU+RNjePb7n3QKlw4Pdo8z0NC4AJmoM0CVoou6sSmLRM03QGV6e5uZDCHh2w/w3Qc+EvwhiX9GlTx72HP4/YLbMn/8Xy0SHgPgG0Me6+g4JrfawWMNly65T5Leks/AGaRuOZimoITJijSBRPkiAWHMTbFKkkfp9B+gEwImINrmuCMeX6US0iSNTLouYTJh3G1I3Mkzd0Slzs7vSCcRCWQ6Qfc9OUV3ELp+8/otIDp//u01eBmRUKX78SrpsCsW80alsampy75KzdUMBJ7EXUBq8Ns3QEn4Tb6SKFLLZ31i6uDDBQKKiPQdZ9LfSKRj5lTD6VOXWKSbJuzeikYMdF9EkuU0MplUBKhaMZ8vchsERLgAhzKJoo7iDkTa3qawK1CI0dtPJQEnEHn4R4kDzzun8vDZxquNF3JQgx5R0ycaubt+cyYhEGQSQgHQzfM3z6NKIBGdSrMaEZEvkgECpDWWqCjOsDhG10gcdojUm0WkDBJh3IFIyWTKvggLCAP6L60S6vTnENIdIXrM7t3Hh0+QCLyh45g9eXJCrAET6aZ1hrfXnEbEc99EnRd0Q64gcRadozxiosuSSECUxhzKoDmASCrGEIRx+Hf0DPwLapSMIsGSiuSefcJ5JLcqPtlx+iTfdBCALl2/JFF36xqG3TVjDd2k0Xgc0ZA1BpKoiEB50Yi6b6NRL8VdBogaIBIEHSoSWKhApFE/KZe8Y1J7EQk6oDsvpMb26ccBkNWZPDol9v13Fgk/pvjWMztt3+NhY6AuCDUqUtDl/wNAY948CIkoiRCpsb29DW4nwRbwP4k5QeS4i3j4nj2C9P0N8xAhiTtUSe7rKyJZldC/b5FKEnemIt13TEOKidaaiFThRFqks3Zy1YcqpY1KHHeNTAOICMOmTZAM/RcAGck/InrYXcgilIm7Pu++vigT322HKpJkki1JWqSdEsmKxNaQVzMuTyXUCBbIFASBfeuOJPDZKO5CB3kPuUtzbFPrfSISxZ24g7vr4HV3bxrr36YgdWsDt/Yd6oPy+Kp4UzsgWmFvMEiN3kaDkUgJ+90Ti/8UTSUoTHfCs5N6Xd1pnm+RbTOJKpKzu2+/vSZu121E8ho7Z99rxu0qtWmZfavpCc3s0iaRms0Gxp0WQ2vkARJS6Lzh3jtxBzXaqlUbdifVLfrkHiH0CWbrDU6k8RCTuZ5Yk+Z72szzIzM7IeK4azRRJPvmAy/gAo+vFK5KlEyWiC6O4GrigplB4rG0Dtc1UEEyvaoH5Pd1LuaIZ3ltba1G28s5NypWJ+0o7qzZERKssEQRhxCR4Cty0vWgv+VC1+X10KABTz3t57s8qe7bMnXbj1EYojn8eCx+kvSI3UWSDWbeoRgLi9Sb7lVx1ySRVKCRUkEol1ikZEv0SPxhN+LCYw11udirtvEMsqc/Ed6g+DD8YRZvH6RPd44OnJ2DV/vS0hL+O7LknQLI5RyTiTs74iIkRYRI0UwKlVj+KsEvMTdu3CdEF0NDu542fTxID0/o9Mms2utTc0gCChMR07RWyc3zOZNs3DWbrZhKgcsiK1GgLcK6QyruLPyByPC7KiIZooSbNAz7AyE1h8QjuG8IaCm8jcQS2U1z4w1q9u28oRWhGpEQiy1QiBR/d80DanBSb9PH0szwG67L9wPTfo/oiZnaDQASAs21CxExLattJAk6tY9k8oh2XSTstjOZVkBqbbQ2tneIOr9IoYPv8BmMA26ab9NIT/OvXPGODs7+gkAYdLf9OeTSkhFp2R1scGnkiC57GxTW7DJNQSKmIBmXUEq6mJqkbI83Y+tq9l11m0iyPzEsU0j/pN0ARx1qpPJITjyNRIim5h0RzlXF6zDstjMN4IHVYCjdJqjUUi1RjIErnep2WoeJZOzbOzpoNHIiyRhyQER60x4i6oogeRVphZ3BqYREBIVM+B3a8WDnyrRTIlkmGtnV1ey7X29R7GeVPrjtyyeIdNsebJhbameiJYi6I13LXtyZE0IhpGxaVyQIu9YVC9QwXPATmoltvNyg1cAXrtbGN1++8+7hvmpVwk6JhESqItm4Y5Fuj4pIczaTwgXJqjQfbhu4V1V9Q7P16xYQ/eXLn3k8UO3rrFarMvvu10S+ff/idsZURdIl9ohvdjl3CsDsXdI8SBFtK412IzE/diUCJnzGWBWwiKiqpvn7vYLERGx2A741KLML2bfaYJ4s23GQ7u2+TqHWv/5pdyLoIw50JjoTHfBK4MA4oeybGyHSyE7Ab+v9WOffSqNciGhMDb/tlTmLBBpNfg3TN7+KiIRKEFVHArpvaFXVZqzbc3Fmd1bySJoG0siZ3f+rO2MUhGEoDBd0MAcQKyI9i5ewuIp71y4ORdDRtZu9RmdX8QLyoKs9gLPvf0lsIigWpOJrL/DxJ2leXt8fd193dOoTzXmQleh2uLbSaMpj7jMg+UKJSnM81m1ebbaKSBa7Zh+09/4e9HZ2s7iO4yqudrvKKTB7NZelIxKYri1xWl4KFo7BxBrpfjFOKAg5xVobKSa8AU+e3dIaS6TicingTlPzW+nQhbF3IkVfvQL6xZwamB44SKSQyhI8+ohglpYASVrn97A3yNM0L1NkSNk5Y6YzMwHIInnl2JN7+G2IoknQSbBULJDw0IaYiIHEog8mIabHnIFyJsrKEq8VSSyEak8jtxz7WL2XmmfYC7qL3mjMQEofCIlDH4lELNICJTFxoBCDA0liWaPCDDwAGSaHyAKZ+sQKPP2g8+iHI0Xi0CdjTuZRYjRqOn4fU+lZI3dl8FbvKBpOfoDzV3EHkd9/KKbWtFYAAAAASUVORK5CYII=',
              abilities: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23ffe59e"/><stop offset="1" stop-color="%23ffc75b"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><path d="M68 18 40 70h18l-6 38 38-58H74l6-32z" fill="%23fff7d6" stroke="%236b4b2a" stroke-width="6" stroke-linejoin="round"/></svg>',
              seeds: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23d3f8c6"/><stop offset="1" stop-color="%239be4a3"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><ellipse cx="64" cy="76" rx="20" ry="16" fill="%23a36b3a" stroke="%236b4b2a" stroke-width="6"/><path d="M64 60c0-12 10-22 22-22-3 12-11 20-22 22zM64 60c0-12-10-22-22-22 3 12 11 20 22 22z" fill="%239cd67f" stroke="%236b4b2a" stroke-width="6" stroke-linejoin="round"/></svg>',
              values: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23ffe59e"/><stop offset="1" stop-color="%23ffd24d"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><circle cx="64" cy="64" r="30" fill="%23ffd86a" stroke="%236b4b2a" stroke-width="6"/><path d="M64 44v40M52 54h24M52 74h24" stroke="%236b4b2a" stroke-width="8" stroke-linecap="round"/></svg>',
              timers: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23cde9ff"/><stop offset="1" stop-color="%2387d0ff"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><circle cx="64" cy="72" r="34" fill="%23fff" stroke="%236b4b2a" stroke-width="6"/><path d="M64 72V52M64 72l18 12" stroke="%236b4b2a" stroke-width="8" stroke-linecap="round"/><rect x="50" y="18" width="28" height="12" rx="6" fill="%23fff" stroke="%236b4b2a" stroke-width="6"/></svg>',
              rooms: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23ffe1f0"/><stop offset="1" stop-color="%23ffb6d9"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><path d="M28 70l36-26 36 26v30H28z" fill="%23fff" stroke="%236b4b2a" stroke-width="6" stroke-linejoin="round"/><rect x="54" y="74" width="20" height="26" rx="4" fill="%23ffd24d" stroke="%236b4b2a" stroke-width="6"/></svg>',
              shop: 'https://cdn.discordapp.com/emojis/1423011042744729700.webp',
              tools: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23e5e1ff"/><stop offset="1" stop-color="%23c7c2ff"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><path d="M46 86l36-36-8-8-36 36-2 14 10-6z" fill="%23fff" stroke="%236b4b2a" stroke-width="6" stroke-linejoin="round"/><rect x="68" y="34" width="14" height="14" rx="3" fill="%23ffd24d" stroke="%236b4b2a" stroke-width="6"/></svg>',
              settings: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23dff3ff"/><stop offset="1" stop-color="%23bfe6ff"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><circle cx="64" cy="64" r="20" fill="%23fff" stroke="%236b4b2a" stroke-width="6"/><path d="M64 30v12M64 86v12M30 64h12M86 64h12M42 42l8 8M78 78l8 8M86 42l-8 8M50 78l-8 8" stroke="%236b4b2a" stroke-width="6" stroke-linecap="round"/></svg>',
              hotkeys: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23fff2c4"/><stop offset="1" stop-color="%23ffd889"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><rect x="30" y="44" width="68" height="40" rx="10" fill="%23fff" stroke="%236b4b2a" stroke-width="6"/><text x="64" y="70" font-family="Arial,Helvetica,sans-serif" font-size="28" text-anchor="middle" fill="%236b4b2a">F</text></svg>',
              protect: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23e2ffe7"/><stop offset="1" stop-color="%23b7f5c3"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><path d="M64 26l32 10v22c0 24-16 36-32 44-16-8-32-20-32-44V36z" fill="%23fff" stroke="%236b4b2a" stroke-width="6" stroke-linejoin="round"/><path d="M46 62l12 12 24-24" fill="none" stroke="%2394d36b" stroke-width="8" stroke-linecap="round" stroke-linejoin="round"/></svg>',
              notifications: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23e3f0ff"/><stop offset="1" stop-color="%23c7dbff"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><path d="M40 82h48l-6-10V58a18 18 0 10-36 0v14z" fill="%23fff" stroke="%236b4b2a" stroke-width="6" stroke-linejoin="round"/><circle cx="84" cy="44" r="10" fill="%23ff6464" stroke="%236b4b2a" stroke-width="6"/></svg>',
              help: 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128"><defs><linearGradient id="g" x1="0" y1="0" x2="0" y2="1"><stop offset="0" stop-color="%23f1e7ff"/><stop offset="1" stop-color="%23d9ccff"/></linearGradient></defs><rect x="12" y="12" width="104" height="104" rx="22" fill="url(%23g)" stroke="%236b4b2a" stroke-width="6"/><circle cx="64" cy="88" r="6" fill="%236b4b2a"/><path d="M48 54a16 16 0 1132 0c0 10-8 10-10 16" fill="none" stroke="%236b4b2a" stroke-width="8" stroke-linecap="round"/></svg>'
          };
  
          // Tooltip text with hotkey info
          const tooltipText = {
              pets: 'Pets ‚Ä¢ Alt+P ‚Ä¢ Shift+Click for widget',
              abilities: 'Abilities ‚Ä¢ Alt+A ‚Ä¢ Shift+Click for widget',
              seeds: 'Seeds ‚Ä¢ Alt+S ‚Ä¢ Shift+Click for widget',
              values: 'Values ‚Ä¢ Alt+V ‚Ä¢ Shift+Click for widget',
              timers: 'Timers ‚Ä¢ Shift+Click for widget',
              rooms: 'Rooms ‚Ä¢ Shift+Click for widget',
              shop: 'Shop ‚Ä¢ Alt+B',
              tools: 'Tools',
              settings: 'Settings ‚Ä¢ Alt+G',
              hotkeys: 'Hotkeys',
              protect: 'Crop Protection ‚Ä¢ Lock/unlock crops',
              notifications: 'Notifications',
              help: 'Help'
          };
  
          // Create primary dock items
          primaryTabs.forEach(tabName => {
              const item = targetDocument.createElement('div');
              item.className = 'mgh-dock-item';
              item.dataset.tab = tabName;
  
              const img = document.createElement('img');
              img.src = icons[tabName];
              // FIX: Match scriptwithicons sizing exactly
              img.style.height = '70%';

              // Add fallback for failed icon loads (especially shop icon)
              img.onerror = () => {
                  img.style.display = 'none';
                  const fallbackEmoji = targetDocument.createElement('span');
                  const emojiMap = {
                      pets: 'üêæ', abilities: '‚ö°', seeds: 'üå±', values: 'üíé',
                      timers: '‚è±Ô∏è', rooms: 'üè†', shop: 'üõí', tools: 'üîß',
                      settings: '‚öôÔ∏è', hotkeys: '‚å®Ô∏è', protect: 'üîí',
                      notifications: 'üîî', help: '‚ùì'
                  };
                  fallbackEmoji.textContent = emojiMap[tabName] || 'üìã';
                  fallbackEmoji.style.fontSize = '24px';
                  item.insertBefore(fallbackEmoji, item.firstChild);
              };

              item.appendChild(img);
  
              const tooltip = targetDocument.createElement('div');
              tooltip.className = 'mgh-tooltip';
              tooltip.innerHTML = tooltipText[tabName] || tabName.charAt(0).toUpperCase() + tabName.slice(1);
  
              item.appendChild(tooltip);
  
              item.addEventListener('click', (e) => {
                  if (e.shiftKey) {
                      openPopoutWidget(tabName);
                  } else {
                      // Special handling for shop - open slide-out windows instead of sidebar
                      if (tabName === 'shop') {
                          toggleShopWindows();
                      } else {
                          openSidebarTab(tabName);
                      }
                  }
              });
  
              dock.appendChild(item);
          });
  
          // Create tail group container
          const tailGroup = targetDocument.createElement('div');
          tailGroup.className = 'mgh-tail-group';
          tailGroup.style.display = 'none';
  
          tailTabs.forEach(tabName => {
              const item = targetDocument.createElement('div');
              item.className = 'mgh-dock-item';
              item.dataset.tab = tabName;
  
              const img = document.createElement('img');
              img.src = icons[tabName];
              // FIX: Match scriptwithicons sizing exactly
              img.style.height = '70%';

              // Add fallback for failed icon loads (especially shop icon)
              img.onerror = () => {
                  img.style.display = 'none';
                  const fallbackEmoji = targetDocument.createElement('span');
                  const emojiMap = {
                      pets: 'üêæ', abilities: '‚ö°', seeds: 'üå±', values: 'üíé',
                      timers: '‚è±Ô∏è', rooms: 'üè†', shop: 'üõí', tools: 'üîß',
                      settings: '‚öôÔ∏è', hotkeys: '‚å®Ô∏è', protect: 'üîí',
                      notifications: 'üîî', help: '‚ùì'
                  };
                  fallbackEmoji.textContent = emojiMap[tabName] || 'üìã';
                  fallbackEmoji.style.fontSize = '24px';
                  item.insertBefore(fallbackEmoji, item.firstChild);
              };

              item.appendChild(img);
  
              const tooltip = targetDocument.createElement('div');
              tooltip.className = 'mgh-tooltip';
              tooltip.innerHTML = tooltipText[tabName] || tabName.charAt(0).toUpperCase() + tabName.slice(1);
  
              item.appendChild(tooltip);
  
              item.addEventListener('click', (e) => {
                  if (e.shiftKey) {
                      openPopoutWidget(tabName);
                  } else {
                      openSidebarTab(tabName);
                  }
              });
  
              tailGroup.appendChild(item);
          });
  
          // Version indicator (added to tail group)
          const versionIndicator = targetDocument.createElement('div');
          versionIndicator.className = 'mgh-dock-item version-indicator';
          versionIndicator.innerHTML = '‚óè';
          versionIndicator.style.fontSize = '12px';
          versionIndicator.style.color = '#888'; // Gray while checking
          versionIndicator.style.cursor = 'pointer';
          versionIndicator.title = `v${CURRENT_VERSION} - Checking for updates... (click to refresh)`;
  
          // Click to manually refresh version check
          versionIndicator.addEventListener('click', (e) => {
              e.stopPropagation();
              versionIndicator.style.color = '#888';
              versionIndicator.title = `v${CURRENT_VERSION} - Checking for updates...`;
              checkVersion(versionIndicator);
          });
  
          tailGroup.appendChild(versionIndicator);
  
          // Tail trigger
          const tailTrigger = targetDocument.createElement('div');
          tailTrigger.className = 'mgh-dock-item tail-trigger';
          tailTrigger.innerHTML = '‚ãØ';
          tailTrigger.addEventListener('mouseenter', () => tailGroup.style.display = 'flex');
  
          // Close tail group when mouse leaves the dock entirely
          dock.addEventListener('mouseleave', () => {
              tailGroup.style.display = 'none';
          });
  
          // Orientation toggle
          const flipToggle = targetDocument.createElement('div');
          flipToggle.className = 'mgh-dock-item flip-toggle';
          flipToggle.innerHTML = '‚Üî';
          flipToggle.title = 'Toggle orientation';
          flipToggle.addEventListener('click', (e) => {
              e.stopPropagation();
              if (dock.classList.contains('horizontal')) {
                  dock.classList.remove('horizontal');
                  dock.classList.add('vertical');
                  // In vertical mode: flip toggle at top, then tabs, tail trigger at bottom
                  dock.insertBefore(flipToggle, dock.firstChild);
                  saveDockOrientation('vertical');
              } else {
                  dock.classList.remove('vertical');
                  dock.classList.add('horizontal');
                  // In horizontal mode: tabs first, tail trigger, then flip toggle at end
                  dock.appendChild(flipToggle);
                  saveDockOrientation('horizontal');
              }
          });
  
          // Add in horizontal order: tabs -> tailTrigger -> tailGroup -> flipToggle
          dock.appendChild(tailTrigger);
          dock.appendChild(tailGroup);
          dock.appendChild(flipToggle);
  
          // Check version after UI is created
          checkVersion(versionIndicator);
  
          // Make entire dock draggable (except when clicking icons)
          makeDockDraggable(dock);
  
          // Create sidebar
          const sidebar = targetDocument.createElement('div');
          sidebar.id = 'mgh-sidebar';
  
          const sidebarHeader = targetDocument.createElement('div');
          sidebarHeader.className = 'mgh-sidebar-header';
  
          const sidebarTitle = targetDocument.createElement('div');
          sidebarTitle.className = 'mgh-sidebar-title';
          sidebarTitle.textContent = 'MGTools';
  
          const sidebarClose = targetDocument.createElement('div');
          sidebarClose.className = 'mgh-sidebar-close';
          sidebarClose.innerHTML = '√ó';
          sidebarClose.addEventListener('click', () => {
              sidebar.classList.remove('open');
              targetDocument.querySelectorAll('.mgh-dock-item').forEach(item => {
                  item.classList.remove('active');
              });
          });
  
          sidebarHeader.appendChild(sidebarTitle);
          sidebarHeader.appendChild(sidebarClose);
  
          const sidebarBody = targetDocument.createElement('div');
          sidebarBody.className = 'mgh-sidebar-body';
  
          sidebar.appendChild(sidebarHeader);
          sidebar.appendChild(sidebarBody);
  
          // Append to DOM
          targetDocument.body.appendChild(dock);
          targetDocument.body.appendChild(sidebar);

          // Discord Fix: Add MutationObserver to detect when React purges UI
          if (isDiscordEnv) {
              let uiRemovalCount = 0;
              const maxReinjections = 10; // Prevent infinite loops

              const observer = new MutationObserver((mutations) => {
                  const dockMissing = !targetDocument.body.contains(dock);
                  const sidebarMissing = !targetDocument.body.contains(sidebar);

                  if ((dockMissing || sidebarMissing) && uiRemovalCount < maxReinjections) {
                      uiRemovalCount++;
                      productionLog(`üîÑ [DISCORD] UI purged by React (${uiRemovalCount}/${maxReinjections}), re-injecting...`);

                      // Re-inject missing elements
                      if (dockMissing && dock.parentNode !== targetDocument.body) {
                          targetDocument.body.appendChild(dock);
                      }
                      if (sidebarMissing && sidebar.parentNode !== targetDocument.body) {
                          targetDocument.body.appendChild(sidebar);
                      }
                  }
              });

              // Watch for removals in body
              observer.observe(targetDocument.body, {
                  childList: true,
                  subtree: false
              });

              productionLog('‚úÖ [DISCORD] MutationObserver active for UI persistence');
          }

          // Restore saved orientation
          const savedOrientation = loadDockOrientation();
          if (savedOrientation === 'vertical') {
              dock.classList.remove('horizontal');
              dock.classList.add('vertical');
              dock.insertBefore(flipToggle, dock.firstChild);
          }
  
          // Restore saved position
          const savedPosition = loadDockPosition();
          if (savedPosition) {
              dock.style.left = savedPosition.left + 'px';
              dock.style.top = savedPosition.top + 'px';
              dock.style.transform = 'none';
              dock.style.bottom = 'auto';
              dock.style.right = 'auto';
          }
  
          // Store references
          UnifiedState.panels.dock = dock;
          UnifiedState.panels.sidebar = sidebar;
          UnifiedState.panels.sidebarBody = sidebarBody;
  
          // Apply theme to dock and sidebar immediately after creation
          setTimeout(() => {
              const currentTheme = generateThemeStyles();
              const isBlackTheme = currentTheme.gradientStyle && currentTheme.gradientStyle.startsWith('black-');
              if (isBlackTheme && currentTheme.accentColor) {
                  applyAccentToDock(currentTheme);
                  applyAccentToSidebar(currentTheme);
              } else {
                  // Apply gradient theme for non-black themes
                  applyThemeToDock(currentTheme);
                  applyThemeToSidebar(currentTheme);
              }
          }, 100);
  
          productionLog('‚úÖ Hybrid Dock UI created successfully');
      }
  
      function saveDockPosition(position) {
          try {
              localStorage.setItem('mgh_dock_position', JSON.stringify(position));
          } catch (e) {
              console.warn('[DOCK] Failed to save position:', e);
          }
      }
  
      function loadDockPosition() {
          try {
              const saved = localStorage.getItem('mgh_dock_position');
              return saved ? JSON.parse(saved) : null;
          } catch (e) {
              console.warn('[DOCK] Failed to load position:', e);
              return null;
          }
      }
  
      function saveDockOrientation(orientation) {
          try {
              localStorage.setItem('mgh_dock_orientation', orientation);
          } catch (e) {
              console.warn('[DOCK] Failed to save orientation:', e);
          }
      }
  
      function loadDockOrientation() {
          try {
              return localStorage.getItem('mgh_dock_orientation') || 'horizontal';
          } catch (e) {
              console.warn('[DOCK] Failed to load orientation:', e);
              return 'horizontal';
          }
      }
  
      function makeDockDraggable(dock) {
          let isDragging = false;
          let startX, startY, startLeft, startTop;
  
          // Show grab cursor on edges (mouse only)
          dock.addEventListener('mousemove', (e) => {
              if (isDragging) return;
  
              // Don't show grab cursor on dock items
              if (e.target.classList.contains('mgh-dock-item') ||
                  e.target.closest('.mgh-dock-item')) {
                  dock.style.cursor = '';
                  return;
              }
  
              const rect = dock.getBoundingClientRect();
              const x = e.clientX - rect.left;
              const y = e.clientY - rect.top;
              const edgeThreshold = 12;
  
              // Check if near edges
              const nearEdge = x < edgeThreshold || x > rect.width - edgeThreshold ||
                             y < edgeThreshold || y > rect.height - edgeThreshold;
  
              dock.style.cursor = nearEdge ? 'grab' : '';
          });
  
          // Shared drag start logic
          const startDrag = (clientX, clientY, event) => {
              // Don't start drag if clicking/touching on a dock item
              if (event.target.classList.contains('mgh-dock-item') ||
                  event.target.closest('.mgh-dock-item')) {
                  return;
              }
  
              event.preventDefault();
              event.stopPropagation();
              isDragging = true;
              startX = clientX;
              startY = clientY;
              const rect = dock.getBoundingClientRect();
              startLeft = rect.left;
              startTop = rect.top;
              dock.style.cursor = 'grabbing';

              // Disable transitions during drag to prevent blinking
              dock.style.transition = 'none';
              dock.querySelectorAll('*').forEach(child => {
                  child.style.transition = 'none';
                  child.style.pointerEvents = 'none';
              });
          };
  
          // Shared drag move logic
          const handleDragMove = (clientX, clientY, event) => {
              if (!isDragging) return;
              event.preventDefault();
              const deltaX = clientX - startX;
              const deltaY = clientY - startY;
              dock.style.left = (startLeft + deltaX) + 'px';
              dock.style.top = (startTop + deltaY) + 'px';
              dock.style.transform = 'none';
              dock.style.bottom = 'auto';
              dock.style.right = 'auto';
          };
  
          // Shared drag end logic
          const endDrag = () => {
              if (isDragging) {
                  isDragging = false;
                  dock.style.cursor = '';
  
                  // Re-enable transitions after drag
                  dock.style.transition = '';
                  dock.querySelectorAll('*').forEach(child => {
                      child.style.transition = '';
                      child.style.pointerEvents = '';
                  });

                  // Save dock position to localStorage
                  const rect = dock.getBoundingClientRect();
                  saveDockPosition({
                      left: rect.left,
                      top: rect.top
                  });
              }
          };
  
          // Mouse event handlers
          dock.addEventListener('mousedown', (e) => {
              startDrag(e.clientX, e.clientY, e);
          });
  
          targetDocument.addEventListener('mousemove', (e) => {
              handleDragMove(e.clientX, e.clientY, e);
          });
  
          targetDocument.addEventListener('mouseup', () => {
              endDrag();
          });
  
          // Touch event handlers
          dock.addEventListener('touchstart', (e) => {
              if (e.touches.length === 1) {
                  const touch = e.touches[0];
                  startDrag(touch.clientX, touch.clientY, e);
              }
          }, { passive: false });
  
          targetDocument.addEventListener('touchmove', (e) => {
              if (isDragging && e.touches.length === 1) {
                  const touch = e.touches[0];
                  handleDragMove(touch.clientX, touch.clientY, e);
              }
          }, { passive: false });
  
          targetDocument.addEventListener('touchend', () => {
              endDrag();
          });
  
          targetDocument.addEventListener('touchcancel', () => {
              endDrag();
          });
      }
  
      function openSidebarTab(tabName) {
          const sidebar = UnifiedState.panels.sidebar;
          const sidebarBody = UnifiedState.panels.sidebarBody;
  
          // Check if clicking the same tab that's already open
          const isAlreadyOpen = sidebar.classList.contains('open') && UnifiedState.activeTab === tabName;
  
          if (isAlreadyOpen) {
              // Close sidebar
              sidebar.classList.remove('open');
              targetDocument.querySelectorAll('.mgh-dock-item').forEach(item => {
                  item.classList.remove('active');
              });
              return;
          }
  
          // Update title
          sidebar.querySelector('.mgh-sidebar-title').textContent = tabName.charAt(0).toUpperCase() + tabName.slice(1);
  
          // Update UnifiedState FIRST (required for updateTabContent)
          UnifiedState.activeTab = tabName;
  
          // Create content container if it doesn't exist
          let contentEl = sidebarBody.querySelector('#mga-tab-content');
          if (!contentEl) {
              contentEl = targetDocument.createElement('div');
              contentEl.id = 'mga-tab-content';
              sidebarBody.innerHTML = '';
              sidebarBody.appendChild(contentEl);
          }
  
          // Call existing updateTabContent which handles all rendering
          updateTabContent();
  
          // Reset scroll position to top when opening a tab
          sidebarBody.scrollTop = 0;
  
          // Show sidebar
          sidebar.classList.add('open');
  
          // Update active state on dock items
          targetDocument.querySelectorAll('.mgh-dock-item').forEach(item => {
              item.classList.toggle('active', item.dataset.tab === tabName);
          });
  
          // Mark shift hint as shown
          localStorage.setItem('mga_shift_hint_shown', 'true');
      }
  
      function openPopoutWidget(tabName) {
          // Check if this widget is already open - if so, close it
          const existingPopout = targetDocument.querySelector(`.mgh-popout[data-tab="${tabName}"]`);
          if (existingPopout) {
              UnifiedState.data.popouts.widgets.delete(tabName); // Clean up tracking
              existingPopout.remove();
              return;
          }
  
          const popout = targetDocument.createElement('div');
          popout.className = 'mgh-popout';
          popout.dataset.tab = tabName; // Store tab name for toggle detection
          popout.style.top = '100px';
          popout.style.left = '100px';
  
          const header = targetDocument.createElement('div');
          header.className = 'mgh-popout-header';
          header.innerHTML = `
              <span>${tabName.charAt(0).toUpperCase() + tabName.slice(1)}</span>
              <span style="cursor: pointer; margin-left: auto; padding: 0 8px; font-size: 20px;">√ó</span>
          `;
  
          const closeBtn = header.querySelector('span:last-child');
          closeBtn.addEventListener('click', () => {
              UnifiedState.data.popouts.widgets.delete(tabName); // Clean up tracking
              popout.remove();
          });
  
          const body = targetDocument.createElement('div');
          body.className = 'mgh-popout-body';
  
          // Create content container
          const contentEl = targetDocument.createElement('div');
          contentEl.id = 'mga-tab-content';
          body.appendChild(contentEl);
  
          popout.appendChild(header);
          popout.appendChild(body);
  
          // Make draggable
          makePopoutDraggable(popout, header);
  
          // Render content BEFORE appending (so theme can see it)
          const prevTab = UnifiedState.activeTab;
          UnifiedState.activeTab = tabName;
  
          // Get the content element we just created
          const popoutContent = popout.querySelector('#mga-tab-content');
  
          // Generate content based on tab
          switch(tabName) {
              case 'pets':
                  popoutContent.innerHTML = getPetsTabContent();
                  setupPetsTabHandlers(popout); // Pass popout context
                  break;
              case 'abilities':
                  popoutContent.innerHTML = getAbilitiesTabContent();
                  setupAbilitiesTabHandlers(popout);
                  updateAbilityLogDisplay(popout);
                  break;
              case 'seeds':
                  popoutContent.innerHTML = getSeedsTabContent();
                  setupSeedsTabHandlers(popout); // Pass popout context
                  break;
              case 'shop':
                  popoutContent.innerHTML = getShopTabContent();
                  setupShopTabHandlers(popout); // Pass popout context
                  break;
              case 'values':
                  popoutContent.innerHTML = getValuesTabContent();
                  setupValuesTabHandlers(popout); // Pass popout context
                  break;
              case 'timers':
                  popoutContent.innerHTML = getTimersTabContent();
                  break;
              case 'rooms':
                  popoutContent.innerHTML = getRoomStatusTabContent();
                  setupRoomJoinButtons(popout); // Pass popout context
                  break;
              case 'tools':
                  popoutContent.innerHTML = getCachedTabContent('tools', getToolsTabContent);
                  break;
              case 'settings':
                  popoutContent.innerHTML = getCachedTabContent('settings', getSettingsTabContent);
                  setupSettingsTabHandlers(popout); // Pass popout context
                  break;
              case 'hotkeys':
                  popoutContent.innerHTML = getCachedTabContent('hotkeys', getHotkeysTabContent);
                  setupHotkeysTabHandlers(popout); // Pass popout context
                  break;
              case 'notifications':
                  popoutContent.innerHTML = getCachedTabContent('notifications', getNotificationsTabContent);
                  setupNotificationsTabHandlers(popout); // Pass popout context
                  break;
              case 'help':
                  popoutContent.innerHTML = getCachedTabContent('help', getHelpTabContent);
                  break;
          }
  
          UnifiedState.activeTab = prevTab; // Restore previous tab
  
          // NOW append to DOM
          targetDocument.body.appendChild(popout);
  
          // Apply theme to widget AFTER content is rendered
          const popoutThemeStyles = generateThemeStyles(UnifiedState.data.settings, true);
          if (popoutThemeStyles) {
              applyThemeToPopoutWidget(popout, popoutThemeStyles);
          }
  
          // Make resizable LAST
          makeElementResizable(popout, {
              minWidth: 320,
              minHeight: 200,
              maxWidth: 800,
              maxHeight: 900,
              handleSize: 14,
              showHandleOnHover: true
          });
  
          // Track widget for theme updates
          UnifiedState.data.popouts.widgets.set(tabName, popout);
      }
  
      function makePopoutDraggable(popout, handle) {
          let isDragging = false;
          let startX, startY, startLeft, startTop;
  
          // Shared drag start logic
          const startDrag = (clientX, clientY, event) => {
              isDragging = true;
              startX = clientX;
              startY = clientY;
              const rect = popout.getBoundingClientRect();
              startLeft = rect.left;
              startTop = rect.top;
              handle.style.cursor = 'grabbing';
              event.preventDefault(); // Prevent text selection during drag
          };
  
          // Shared drag move logic
          const handleDragMove = (clientX, clientY) => {
              if (!isDragging) return;
              const deltaX = clientX - startX;
              const deltaY = clientY - startY;
              popout.style.left = (startLeft + deltaX) + 'px';
              popout.style.top = (startTop + deltaY) + 'px';
          };
  
          // Shared drag end logic
          const endDrag = () => {
              if (isDragging) {
                  isDragging = false;
                  handle.style.cursor = 'grab';
              }
          };
  
          // Mouse event handlers
          handle.addEventListener('mousedown', (e) => {
              startDrag(e.clientX, e.clientY, e);
          });
  
          document.addEventListener('mousemove', (e) => {
              handleDragMove(e.clientX, e.clientY);
          });
  
          document.addEventListener('mouseup', () => {
              endDrag();
          });
  
          // Touch event handlers
          handle.addEventListener('touchstart', (e) => {
              if (e.touches.length === 1) {
                  const touch = e.touches[0];
                  startDrag(touch.clientX, touch.clientY, e);
              }
          }, { passive: false });
  
          document.addEventListener('touchmove', (e) => {
              if (isDragging && e.touches.length === 1) {
                  const touch = e.touches[0];
                  handleDragMove(touch.clientX, touch.clientY);
                  e.preventDefault(); // Prevent scrolling while dragging
              }
          }, { passive: false });
  
          document.addEventListener('touchend', () => {
              endDrag();
          });
  
          document.addEventListener('touchcancel', () => {
              endDrag();
          });
      }
  
      // ==================== WEATHER TOGGLE FUNCTIONS ====================
      let weatherCheckInterval = null;
  
      function hideWeatherCanvases() {
          const canvases = document.querySelectorAll('canvas.WeatherCanvas');
          productionLog(`üåßÔ∏è [WEATHER] Hiding ${canvases.length} weather canvas(es)`);
          canvases.forEach(canvas => {
              canvas.style.display = 'none';
          });
      }
  
      function showWeatherCanvases() {
          const canvases = document.querySelectorAll('canvas.WeatherCanvas');
          productionLog(`üåßÔ∏è [WEATHER] Showing ${canvases.length} weather canvas(es)`);
          canvases.forEach(canvas => {
              canvas.style.display = '';
          });
      }
  
      function applyWeatherSetting() {
          productionLog(`üåßÔ∏è [WEATHER] Applying weather setting: hideWeather=${UnifiedState.data.settings.hideWeather}`);
  
          // Clear any existing interval
          if (weatherCheckInterval) {
              clearInterval(weatherCheckInterval);
              weatherCheckInterval = null;
          }
  
          if (UnifiedState.data.settings.hideWeather) {
              // Hide weather canvases immediately
              hideWeatherCanvases();
  
              // Set up interval to catch dynamically added weather canvases
              weatherCheckInterval = setInterval(() => {
                  const canvases = document.querySelectorAll('canvas.WeatherCanvas');
                  canvases.forEach(canvas => {
                      if (canvas.style.display !== 'none') {
                          canvas.style.display = 'none';
                      }
                  });
              }, 500); // Check every 500ms
          } else {
              showWeatherCanvases();
          }
      }
  
      // ==================== HOTKEY HELPER FUNCTIONS ====================
      function formatHotkey(event) {
          const parts = [];
          if (event.ctrlKey) parts.push('Ctrl');
          if (event.altKey) parts.push('Alt');
          if (event.shiftKey) parts.push('Shift');
  
          let key = event.key;
          if (key === ' ') key = 'Space';
          else if (key.length === 1) key = key.toUpperCase();
  
          parts.push(key);
          return parts.join('+');
      }
  
      function matchesHotkey(event, hotkeyString) {
          if (!hotkeyString) return false;
          const formatted = formatHotkey(event);
          return formatted.toLowerCase() === hotkeyString.toLowerCase();
      }
  
      function showHotkeyRecordingModal(presetName, context) {
          // Create modal overlay
          const modal = targetDocument.createElement('div');
          modal.id = 'hotkey-recording-modal';
          modal.style.cssText = `
              position: fixed;
              top: 0; left: 0; right: 0; bottom: 0;
              background: rgba(0, 0, 0, 0.8);
              display: flex;
              align-items: center;
              justify-content: center;
              z-index: 9999999;
          `;
  
          const modalContent = targetDocument.createElement('div');
          modalContent.style.cssText = `
              background: #1a1a1a;
              padding: 24px;
              border-radius: 8px;
              border: 1px solid rgba(255, 255, 255, 0.73);
              text-align: center;
              min-width: 300px;
          `;
  
          modalContent.innerHTML = `
              <h3 style="color: white; margin-bottom: 16px;">Set Hotkey for "${presetName}"</h3>
              <p style="color: #aaa; margin-bottom: 16px; font-size: 13px;">Press any key combination...</p>
              <div id="hotkey-display" style="
                  background: rgba(74, 158, 255, 0.48);
                  border: 1px solid #4a9eff;
                  padding: 12px;
                  border-radius: 4px;
                  color: white;
                  font-size: 16px;
                  margin-bottom: 16px;
                  min-height: 40px;
                  display: flex;
                  align-items: center;
                  justify-content: center;
              ">Waiting...</div>
              <div style="display: flex; gap: 8px;">
                  <button id="hotkey-save" class="mga-btn" disabled style="flex: 1;">Save</button>
                  <button id="hotkey-clear" class="mga-btn" style="flex: 1; background: rgba(255, 100, 100, 0.48); border-color: #ff6464;">Clear</button>
                  <button id="hotkey-cancel" class="mga-btn" style="flex: 1;">Cancel</button>
              </div>
          `;
  
          modal.appendChild(modalContent);
          targetDocument.body.appendChild(modal);
  
          const display = modal.querySelector('#hotkey-display');
          const saveBtn = modal.querySelector('#hotkey-save');
          const clearBtn = modal.querySelector('#hotkey-clear');
          const cancelBtn = modal.querySelector('#hotkey-cancel');
  
          let capturedHotkey = null;
  
          const handleKeyDown = (e) => {
              if (e.key === 'Escape') {
                  modal.remove();
                  return;
              }
  
              e.preventDefault();
              e.stopPropagation();
  
              capturedHotkey = formatHotkey(e);
              display.textContent = capturedHotkey;
              saveBtn.disabled = false;
          };
  
          targetDocument.addEventListener('keydown', handleKeyDown, true);
  
          saveBtn.addEventListener('click', () => {
              if (capturedHotkey) {
                  UnifiedState.data.petPresetHotkeys[presetName] = capturedHotkey;
                  MGA_saveJSON('MGA_petPresetHotkeys', UnifiedState.data.petPresetHotkeys);
                  refreshPresetsList(context);
              }
              targetDocument.removeEventListener('keydown', handleKeyDown, true);
              modal.remove();
          });
  
          clearBtn.addEventListener('click', () => {
              delete UnifiedState.data.petPresetHotkeys[presetName];
              MGA_saveJSON('MGA_petPresetHotkeys', UnifiedState.data.petPresetHotkeys);
              refreshPresetsList(context);
              targetDocument.removeEventListener('keydown', handleKeyDown, true);
              modal.remove();
          });
  
          cancelBtn.addEventListener('click', () => {
              targetDocument.removeEventListener('keydown', handleKeyDown, true);
              modal.remove();
          });
      }
  
      // Register Alt+B hotkey to toggle shop windows
      // Use capture phase (true) to intercept before game handlers
      targetDocument.addEventListener('keydown', (e) => {
          // Alt+B for shop
          if (e.altKey && e.key.toLowerCase() === 'b') {
              e.preventDefault();
              e.stopPropagation();
              toggleShopWindows();
              return;
          }
  
          // Check pet preset hotkeys
          for (const [presetName, hotkey] of Object.entries(UnifiedState.data.petPresetHotkeys)) {
              if (hotkey && matchesHotkey(e, hotkey)) {
                  e.preventDefault();
                  e.stopPropagation();
                  const preset = UnifiedState.data.petPresets[presetName];
                  if (preset) {
                      loadPetPreset(preset);
  
                      // Refresh active pets display after loading
                      setTimeout(() => {
                          updateActivePetsFromRoomState();
                          const sidebar = document.querySelector('#mgh-sidebar-body');
                          if (sidebar) updateActivePetsDisplay(sidebar);
  
                          // Also refresh any open popouts
                          refreshSeparateWindowPopouts('pets');
                      }, 800);
                  }
                  return;
              }
          }
  
          // Check MGTools navigation hotkeys
          const mgToolsKeys = UnifiedState.data.hotkeys.mgToolsKeys;
          const tabMap = {
              openPets: 'pets',
              openAbilities: 'abilities',
              openSeeds: 'seeds',
              openValues: 'values',
              openTimers: 'timers',
              openRooms: 'rooms',
              openShop: 'shop'
          };
  
          for (const [action, config] of Object.entries(mgToolsKeys)) {
              if (config.custom && matchesHotkey(e, config.custom)) {
                  e.preventDefault();
                  e.stopPropagation();
                  const tabName = tabMap[action];
                  if (tabName === 'shop') {
                      toggleShopWindows();
                  } else {
                      openSidebarTab(tabName);
                  }
                  return;
              }
          }
      }, true); // Use capture phase to intercept before game handlers
  
      // Pop-out window functionality
      function openTabInPopout(tabName) {
          productionLog(`üîó Opening ${tabName} tab in pop-out window...`);
  
          const tabTitles = {
              pets: 'üêæ Pet Loadouts',
              abilities: '‚ö° Abilities',
              seeds: 'üå± Seeds',
              values: 'üí∞ Values',
              timers: '‚è∞ Timers',
              rooms: 'üéÆ Rooms',
              settings: '‚öôÔ∏è Settings'
          };
  
          const title = `MGTools - ${tabTitles[tabName] || tabName}`;
  
          // Calculate window size based on tab content
          const windowFeatures = 'width=450,height=550,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=no,status=no';
  
          const popoutWindow = window.open('', `mga_popout_${tabName}`, windowFeatures);
  
          if (!popoutWindow) {
              productionWarn('‚ö†Ô∏è Pop-out blocked! Please allow popups for this site.');
              return;
          }
  
          // Track the popout window for cleanup
          trackPopoutWindow(popoutWindow);
  
          // BUGFIX: Store window reference in Map for real-time updates
          UnifiedState.data.popouts.windows.set(tabName, popoutWindow);
  
          // Add cleanup listener to remove from Map when window closes
          popoutWindow.addEventListener('beforeunload', () => {
              UnifiedState.data.popouts.windows.delete(tabName);
              debugLog('POPOUT_LIFECYCLE', `Removed ${tabName} from windows Map`);
          });
  
          // Get tab content based on tab name
          let content = '';
          switch(tabName) {
              case 'pets':
                  content = getPetsPopoutContent();
                  break;
              case 'abilities':
                  content = getAbilitiesTabContent();
                  break;
              case 'seeds':
                  content = getSeedsTabContent();
                  break;
              case 'shop':
                  content = getShopTabContent();
                  break;
              case 'values':
                  content = getValuesTabContent();
                  break;
              case 'timers':
                  content = getTimersTabContent();
                  break;
              case 'tools':
                  content = getToolsTabContent();
                  break;
              case 'rooms':
                  content = getRoomStatusTabContent();
                  break;
              case 'settings':
                  content = getSettingsTabContent();
                  break;
              case 'help':
                  content = getHelpTabContent();
                  break;
              default:
                  content = '<p>Tab content not available</p>';
          }
  
          // Get current theme for pop-out window
          const currentTheme = UnifiedState.currentTheme || generateThemeStyles();
  
          // Create pop-out window HTML with dynamic theming
          const popoutHTML = `
  <!DOCTYPE html>
  <html>
  <head>
      <title>${title}</title>
      <style>
          ${UNIFIED_STYLES}
          body {
              margin: 0;
              padding: 16px;
              background: ${currentTheme.background};
              color: #ffffff;
              font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
              min-height: 100vh;
              --panel-scale: 1;
              --base-font-size: 13px;
              --responsive-font-size: calc(var(--base-font-size) * var(--panel-scale));
              font-size: var(--responsive-font-size);
          }
  
          /* Removed universal font scaling to prevent oversized popout UI */
          .popout-header {
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 16px;
              padding: 12px;
              background: rgba(255, 255, 255, 0.05);
              border-radius: 8px;
              border: 1px solid rgba(255, 255, 255, 0.57);
              flex-wrap: wrap;
              gap: 10px;
          }
          .popout-title {
              font-size: 18px;
              font-weight: 600;
              color: #4a9eff;
              flex-shrink: 0;
              min-width: 150px;
          }
          .popout-sync-notice {
              font-size: 12px;
              color: #888;
              font-style: italic;
              flex: 1 1 auto;
              text-align: center;
              min-width: 200px;
          }
          .refresh-btn {
              padding: 6px 12px;
              background: #4a9eff;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-size: 12px;
              flex-shrink: 0;
          }
          .refresh-btn:hover {
              background: #3a8eef;
          }
      </style>
  </head>
  <body>
      <div class="popout-header">
          <div class="popout-title">${title}</div>
          <div class="popout-sync-notice">Note: This is a static snapshot. Click refresh to update.</div>
          <button class="refresh-btn" onclick="refreshPopoutContent('\${tabName}')">üîÑ Refresh</button>
      </div>
      <div id="popout-content" class="mga-scrollable mga-popout-content" style="max-height: calc(100vh - 120px); overflow-y: auto;">
          ${content}
      </div>
  
      <script>
          // Store reference to main window
          const mainWindow = window.opener;
  
          function refreshPopoutContent(tabName) {
              if (!mainWindow || mainWindow.closed) {
                  productionWarn('‚ö†Ô∏è Main window is closed. Cannot refresh content.');
                  return;
              }
  
              // Get fresh content from main window
              let freshContent = '';
              switch(tabName) {
                  case 'pets':
                      freshContent = mainWindow.MGA_Internal?.getPetsPopoutContent ? mainWindow.MGA_Internal?.getPetsPopoutContent() : 'Content unavailable';
                      break;
                  case 'abilities':
                      freshContent = mainWindow.MGA_Internal?.getAbilitiesTabContent ? mainWindow.MGA_Internal?.getAbilitiesTabContent() : 'Content unavailable';
                      break;
                  case 'seeds':
                      freshContent = mainWindow.MGA_Internal?.getSeedsTabContent ? mainWindow.MGA_Internal?.getSeedsTabContent() : 'Content unavailable';
                      break;
                  case 'shop':
                      freshContent = mainWindow.MGA_Internal?.getShopTabContent ? mainWindow.MGA_Internal?.getShopTabContent() : 'Content unavailable';
                      break;
                  case 'values':
                      freshContent = mainWindow.MGA_Internal?.getValuesTabContent ? mainWindow.MGA_Internal?.getValuesTabContent() : 'Content unavailable';
                      break;
                  case 'timers':
                      freshContent = mainWindow.MGA_Internal?.getTimersTabContent ? mainWindow.MGA_Internal?.getTimersTabContent() : 'Content unavailable';
                      break;
                  case 'tools':
                      freshContent = mainWindow.MGA_Internal?.getToolsTabContent ? mainWindow.MGA_Internal?.getToolsTabContent() : 'Content unavailable';
                      break;
                  case 'rooms':
                      freshContent = mainWindow.MGA_Internal?.getRoomStatusTabContent ? mainWindow.MGA_Internal?.getRoomStatusTabContent() : 'Content unavailable';
                      break;
                  case 'settings':
                      freshContent = mainWindow.MGA_Internal?.getSettingsTabContent ? mainWindow.MGA_Internal?.getSettingsTabContent() : 'Content unavailable';
                      break;
              }
  
              document.getElementById('popout-content').innerHTML = freshContent;
  
              // Rerun handlers if needed
              if (tabName === 'abilities' && mainWindow.setupAbilitiesTabHandlers) {
                  mainWindow.setupAbilitiesTabHandlers.call(mainWindow);
                  if (mainWindow.updateAbilityLogDisplay) {
                      mainWindow.updateAbilityLogDisplay.call(mainWindow);
                  }
              } else if (tabName === 'pets') {
                  // For pets popout, use special popout handlers instead of main tab handlers
                  if (mainWindow.setupPetPopoutHandlers) {
                      mainWindow.setupPetPopoutHandlers.call(mainWindow, document);
                  }
              } else if (tabName === 'seeds' && mainWindow.setupSeedsTabHandlers) {
                  mainWindow.setupSeedsTabHandlers.call(mainWindow, document);
              } else if (tabName === 'values' && mainWindow.resourceDashboard) {
                  mainWindow.resourceDashboard.setupDashboardHandlers(document);
              } else if (tabName === 'settings' && mainWindow.setupSettingsTabHandlers) {
                  mainWindow.setupSettingsTabHandlers.call(mainWindow, document);
              } else if (tabName === 'rooms' && mainWindow.setupRoomJoinButtons) {
                  mainWindow.setupRoomJoinButtons.call(mainWindow);
              }
  
              productionLog('Pop-out content refreshed for:', tabName);
          }
  
          // BUGFIX: Expose refresh function on window object for external access
          window.refreshPopoutContent = refreshPopoutContent;
  
          // Store the tab name for this popup window
          const currentTabName = '\${tabName}';
  
          // Auto-refresh every 5 seconds for dynamic tabs
          // BUGFIX: Added 'abilities' to auto-refresh list for real-time ability log updates
          if (['values', 'timers', 'rooms', 'abilities'].includes(currentTabName)) {
              // Use managed interval to prevent memory leaks
              if (window.opener && window.opener.setManagedInterval) {
                  window.opener.setManagedInterval(
                      'popoutRefresh_' + currentTabName + '_' + Date.now(),
                      () => refreshPopoutContent(currentTabName),
                      5000
                  );
              }
          }
  
          // Cleanup when window closes
          window.addEventListener('beforeunload', () => {
              productionLog('Pop-out window closing for:', currentTabName);
          });
      </script>
  </body>
  </html>
          `;
  
          productionLog('üå± [WINDOW DEBUG] Content being written to separate window:', {
              tabName,
              contentLength: content.length,
              htmlLength: popoutHTML.length,
              contentPreview: content.substring(0, 200)
          });
  
          popoutWindow.document.open();
          popoutWindow.document.write(popoutHTML);
          popoutWindow.document.close();
  
          // Set up handlers for the pop-out content
          setTimeout(() => {
              try {
                  switch(tabName) {
                      case 'abilities':
                          // Note: Handlers won't work perfectly in pop-out due to cross-window limitations
                          // Users should use refresh button for interactions
                          break;
                      case 'pets':
                          setupPetPopoutHandlers(popoutWindow.document);
                          break;
                      case 'seeds':
                          setupSeedsTabHandlers(popoutWindow.document);
                          break;
                      case 'shop':
                          setupShopTabHandlers(popoutWindow.document);
                          break;
                      case 'settings':
                          setupSettingsTabHandlers(popoutWindow.document);
                          break;
                      case 'tools':
                          setupToolsTabHandlers(popoutWindow.document);
                          break;
                      case 'rooms':
                          setupRoomJoinButtons();
                          break;
                      case 'hotkeys':
                          setupHotkeysTabHandlers(popoutWindow.document);
                          break;
                      case 'notifications':
                          setupNotificationsTabHandlers(popoutWindow.document);
                          break;
                      case 'help':
                          // Help tab doesn't need special handlers
                          break;
                  }
              } catch (error) {
                  productionWarn('Could not set up pop-out handlers:', error);
              }
          }, 100);
  
          productionLog(`‚úÖ Pop-out window opened for ${tabName} tab`);
      }
  
      // Expose content functions in MGA namespace for pop-out windows (prevents conflicts)
      window.MGA_Internal = window.MGA_Internal || {};
      window.MGA_Internal.getPetsTabContent = getPetsTabContent;
      window.MGA_Internal.getPetsPopoutContent = getPetsPopoutContent;
      window.MGA_Internal.setupPetPopoutHandlers = setupPetPopoutHandlers;
      window.MGA_Internal.getAbilitiesTabContent = getAbilitiesTabContent;
      window.MGA_Internal.getSeedsTabContent = getSeedsTabContent;
      window.MGA_Internal.getValuesTabContent = getValuesTabContent;
      window.MGA_Internal.getTimersTabContent = getTimersTabContent;
      window.MGA_Internal.getToolsTabContent = getToolsTabContent;
      window.MGA_Internal.getRoomStatusTabContent = getRoomStatusTabContent;
      window.MGA_Internal.getSettingsTabContent = getSettingsTabContent;
      window.MGA_Internal.setupAbilitiesTabHandlers = setupAbilitiesTabHandlers;
      window.MGA_Internal.updateAbilityLogDisplay = updateAbilityLogDisplay;
      window.MGA_Internal.setupPetsTabHandlers = setupPetsTabHandlers;
      window.MGA_Internal.setupSeedsTabHandlers = setupSeedsTabHandlers;
      window.MGA_Internal.setupSettingsTabHandlers = setupSettingsTabHandlers;
      window.MGA_Internal.setupToolsTabHandlers = setupToolsTabHandlers;
      window.MGA_Internal.setupRoomJoinButtons = setupRoomJoinButtons;
  
      // Export storage functions
      window.MGA_Internal.MGA_loadJSON = MGA_loadJSON;
      window.MGA_Internal.MGA_saveJSON = MGA_saveJSON;
  
      // ==================== IN-GAME OVERLAY SYSTEM ====================
  
      function getContentForTab(tabName, isPopout = false) {
          switch(tabName) {
              case 'pets':
                  return isPopout ? getPetsPopoutContent() : getPetsTabContent();
              case 'abilities':
                  return getAbilitiesTabContent();
              case 'seeds':
                  return getSeedsTabContent();
              case 'shop':
                  return getShopTabContent();
              case 'values':
                  return getValuesTabContent();
              case 'timers':
                  return getTimersTabContent();
              case 'rooms':
                  return getRoomStatusTabContent();
              case 'tools':
                  return getToolsTabContent();
              case 'settings':
                  return getSettingsTabContent();
              case 'hotkeys':
                  return getHotkeysTabContent();
              case 'notifications':
                  return getNotificationsTabContent();
              default:
                  return '<div style="padding: 20px; text-align: center; color: rgba(255,255,255,0.5);">Content not available</div>';
          }
      }
  
      function setupOverlayHandlers(overlay, tabName) {
          try {
              debugLog('HANDLER_SETUP', `Setting up handlers for content-only overlay ${tabName}`, {
                  overlayId: overlay.id
              });
  
              switch(tabName) {
                  case 'abilities':
                      setupAbilitiesTabHandlers(overlay);
                      if (overlay) {
                          updateAbilityLogDisplay(overlay);
                          debugLog('ABILITY_LOGS', 'Populated ability logs for content-only overlay', {
                              logCount: UnifiedState.data.petAbilityLogs.length
                          });
                      }
                      break;
                  case 'pets':
                      setupPetPopoutHandlers(overlay);  // Use popout handlers for overlays
                      break;
                  case 'seeds':
                      setupSeedsTabHandlers(overlay);
                      break;
                  case 'shop':
                      setupShopTabHandlers(overlay);
                      break;
                  case 'settings':
                      setupSettingsTabHandlers(overlay);
                      break;
                  case 'tools':
                      setupToolsTabHandlers(overlay);
                      break;
                  case 'rooms':
                      setupRoomJoinButtons();
                      break;
                  case 'hotkeys':
                      setupHotkeysTabHandlers(overlay);
                      break;
                  case 'notifications':
                      setupNotificationsTabHandlers(overlay);
                      break;
              }
          } catch (error) {
              debugError('HANDLER_SETUP', 'Failed to set up content-only overlay handlers', error, {
                  tabName,
                  overlayId: overlay?.id
              });
          }
      }
  
      function createInGameOverlay(tabName) {
          debugLog('OVERLAY_LIFECYCLE', `Creating content-only overlay for ${tabName} tab`);
  
          // Check if overlay already exists - toggle visibility
          if (UnifiedState.data.popouts.overlays.has(tabName)) {
              const existingOverlay = UnifiedState.data.popouts.overlays.get(tabName);
              if (existingOverlay && document.contains(existingOverlay)) {
                  // Toggle: if visible, remove it; if hidden, show it
                  if (existingOverlay.style.display !== 'none') {
                      existingOverlay.remove();
                      UnifiedState.data.popouts.overlays.delete(tabName);
                      debugLog('OVERLAY_LIFECYCLE', `Toggled OFF: ${tabName} overlay removed`);
                      return null;
                  } else {
                      existingOverlay.style.display = 'block';
                      existingOverlay.style.zIndex = '999999';
                      debugLog('OVERLAY_LIFECYCLE', `Toggled ON: ${tabName} overlay shown`);
                      return existingOverlay;
                  }
              }
          }
  
          // Create content-only overlay container - NO HEADER, NO DECORATIONS
          const overlay = targetDocument.createElement('div');
          overlay.className = 'mga-overlay-content-only mga-scrollable';
          overlay.id = `mga-overlay-${tabName}`;
  
          // SMART POSITIONING - Avoid overlapping with existing overlays
          const gameViewport = getGameViewport();
          const smartPosition = findOptimalPosition(tabName, gameViewport);
  
          // PURE CONTENT DESIGN with PROPER RESIZING - Perfect match to target image (NO CHROME)
          overlay.style.cssText = `
              position: fixed;
              top: ${smartPosition.top}px;
              left: ${smartPosition.left}px;
              width: 240px;
              height: 300px;
              min-height: 120px;
              max-height: 500px;
              padding: 10px 12px;
              color: #ffffff;
              font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
              font-size: 12px;
              line-height: 1.4;
              z-index: 999998;
              overflow-y: auto;
              min-width: 180px;
              max-width: 450px;
              user-select: none;
              border-radius: 4px;
              backdrop-filter: blur(10px);
              cursor: grab;
              will-change: width, height, transform;
          `;
  
          // Apply theme - clean background with textures support
          const popoutTheme = generateThemeStyles(UnifiedState.data.settings, true);

          // Layer texture over gradient if texture is enabled (same logic as applyThemeToElement)
          if (popoutTheme.texturePattern) {
              overlay.style.background = `${popoutTheme.texturePattern}, ${popoutTheme.background}`;
              overlay.style.backgroundSize = `${popoutTheme.textureBackgroundSize}, cover`;
              overlay.style.backgroundBlendMode = `${popoutTheme.textureBlendMode}, normal`;
          } else {
              overlay.style.background = popoutTheme.background;
              overlay.style.backgroundBlendMode = '';
          }
  
          // Invisible scrollbars are now handled by the mga-scrollable class
  
          debugLog('POP_OUT_DESIGN', `Applied content-only theme for ${tabName}`, {
              background: popoutTheme.background,
              dimensions: `${overlay.style.width} x ${overlay.style.height}`
          });
  
          // NO HEADER - Content only design matching target image
          // Add simple close functionality via right-click context menu or ESC key
  
          // Add keyboard shortcut for closing (ESC key)
          overlay.addEventListener('keydown', (e) => {
              if (e.key === 'Escape') {
                  debugLog('POP_OUT_DESIGN', `Closing overlay ${tabName} via ESC key`);
                  closeInGameOverlay(tabName);
              }
          });
  
          // Make overlay focusable for keyboard events
          overlay.tabIndex = -1;
          overlay.focus();
  
          // INVISIBLE DRAGGING - No chrome, entire overlay is draggable
          // Add subtle visual feedback on hover (skip for pets popouts to prevent stutter)
          overlay.addEventListener('mouseenter', () => {
              if (!overlay.hasAttribute('data-dragging') && !overlay.id.includes('mga-pets-popout') && !overlay.id.includes('pets')) {
                  overlay.style.transform = 'scale(1.005)';
                  overlay.style.transition = 'transform 0.15s ease';
              }
          });
  
          overlay.addEventListener('mouseleave', () => {
              if (!overlay.hasAttribute('data-dragging') && !overlay.id.includes('mga-pets-popout') && !overlay.id.includes('pets')) {
                  overlay.style.transform = 'scale(1)';
              }
          });
  
          // Add content directly to overlay (no separate contentArea needed)
          // Add scrollbar styling for content-only design
          const contentHtml = `
              <style>
                  /* TARGET IMAGE MATCH - Clean, readable styling */
                  /* Section titles are now handled in the main visibility rules above */
  
                  .mga-overlay-content-only .mga-section {
                      margin: 0 !important;
                      padding: 0 !important;
                  }
  
                  .mga-overlay-content-only .mga-value-row {
                      display: flex !important;
                      justify-content: space-between !important;
                      margin: 3px 0 !important;
                      padding: 2px 0 !important;
                      line-height: 1.3 !important;
                  }
  
                  .mga-overlay-content-only .mga-value-label {
                      font-size: 12px !important;
                      color: rgba(255, 255, 255, 0.9) !important;
                      font-weight: 400 !important;
                      margin: 0 !important;
                      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
                  }
  
                  .mga-overlay-content-only .mga-value-amount {
                      font-size: 13px !important;
                      font-weight: 600 !important;
                      color: #ffffff !important;
                      margin: 0 !important;
                      text-align: right;
                      min-width: 50px;
                      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
                  }
  
                  /* HIGH CONTRAST TOTAL VALUE */
                  .mga-overlay-content-only .mga-total-value {
                      border-top: 1px solid rgba(255, 255, 255, 0.73) !important;
                      margin-top: 6px !important;
                      padding-top: 4px !important;
                  }
  
                  .mga-overlay-content-only .mga-total-value .mga-value-label {
                      font-weight: 500 !important;
                      color: rgba(255, 255, 255, 0.95) !important;
                      font-size: 13px !important;
                  }
  
                  .mga-overlay-content-only .mga-total-value .mga-value-amount {
                      font-size: 14px !important;
                      font-weight: 700 !important;
                      color: #ffff00 !important;
                      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
                  }
  
                  /* Hide only truly unnecessary elements - KEEP buttons and checkboxes for functionality */
                  .mga-overlay-content-only .mga-section-header,
                  .mga-overlay-content-only .mga-input-group,
                  .mga-overlay-content-only .mga-timer-controls {
                      display: none !important;
                  }
  
                  /* Keep section titles visible but make them smaller */
                  .mga-overlay-content-only .mga-section-title {
                      display: block !important;
                      font-size: 11px !important;
                      margin-bottom: 4px !important;
                  }
  
                  /* Readable ability logs */
                  .mga-overlay-content-only .mga-log-item {
                      margin: 2px 0 !important;
                      padding: 2px 0 !important;
                      font-size: 11px !important;
                      line-height: 1.3 !important;
                      color: rgba(255, 255, 255, 0.9) !important;
                      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
                  }
  
                  .mga-overlay-content-only .mga-log-time {
                      font-size: 10px !important;
                      color: rgba(255, 255, 255, 0.7) !important;
                  }
  
                  /* Readable pet loadouts */
                  .mga-overlay-content-only .mga-pet-slot {
                      margin: 2px 0 !important;
                      padding: 3px !important;
                      font-size: 11px !important;
                      color: rgba(255, 255, 255, 0.9) !important;
                      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
                  }
              </style>
          `;
  
          // Get and add content directly to overlay - PURE CONTENT ONLY
          const contentHTML = getContentForTab(tabName, true); // isPopout=true for overlays
  
          productionLog('üîç [CONTENT DEBUG] Variables check:', {
              contentHtmlType: typeof contentHtml,
              contentHtmlLength: contentHtml?.length,
              contentHTMLType: typeof contentHTML,
              contentHTMLLength: contentHTML?.length,
              contentHtmlPreview: contentHtml?.substring(0, 100),
              contentHTMLPreview: contentHTML?.substring(0, 100)
          });
  
          // For ability logs, add a subtle drag indicator
          if (tabName === 'abilities') {
              const dragIndicator = `
                  <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px; padding: 4px 0; border-bottom: 1px solid rgba(255, 255, 255, 0.57);">
                      <div style="font-size: 11px; color: #4a9eff; font-weight: 600;">ABILITY LOGS</div>
                      <div style="font-size: 9px; color: rgba(255,255,255,0.4); cursor: grab;" title="Click and drag to move">‚£ø‚£ø drag</div>
                  </div>
              `;
              overlay.innerHTML = contentHtml + dragIndicator + contentHTML;
          } else {
              overlay.innerHTML = contentHtml + contentHTML;
          }
  
          productionLog('üå± [OVERLAY DEBUG] Content inserted:', {
              tabName,
              contentLength: contentHTML.length,
              overlayHTML: overlay.innerHTML.substring(0, 200)
          });
  
          // Apply invisible dragging to entire overlay surface
          makeEntireOverlayDraggable(overlay);
  
          // Add professional resize functionality
          addResizeHandleToOverlay(overlay);
  
          // Function now available globally - moved to global scope
  
          // Load saved position and dimensions
          loadOverlayPosition(overlay);
          loadOverlayDimensions(overlay);
  
          debugLog('POP_OUT_DESIGN', `Content added to overlay for ${tabName}`, {
              hasContent: !!contentHTML
          });
  
          // Add to DOM and track
          targetDocument.body.appendChild(overlay);

          // After rendering notification checkboxes in widget, reload saved state
          if (tabName === 'notifications') {
              // Use already-loaded settings from UnifiedState (avoid double-load race condition)
              const notifications = UnifiedState.data?.settings?.notifications;
              if (notifications) {

                  // Apply ability notification settings
                  const abilityCheckbox = overlay.querySelector('#ability-notifications-enabled');
                  if (abilityCheckbox) {
                      abilityCheckbox.checked = notifications.abilityNotificationsEnabled || false;
                  }

                  // Apply category settings if category checkboxes exist
                  if (notifications.watchedAbilityCategories) {
                      Object.keys(notifications.watchedAbilityCategories).forEach(category => {
                          const catCheckbox = overlay.querySelector(`#ability-cat-${category}`);
                          if (catCheckbox) {
                              catCheckbox.checked = notifications.watchedAbilityCategories[category];
                          }
                      });
                  }

                  // Apply individual ability checkboxes
                  if (notifications.watchedAbilities) {
                      const individualCheckboxes = overlay.querySelectorAll('.individual-ability-checkbox');
                      individualCheckboxes.forEach(checkbox => {
                          const abilityName = checkbox.dataset.abilityName;
                          if (abilityName) {
                              checkbox.checked = notifications.watchedAbilities.includes(abilityName);
                          }
                      });
                  }

                  productionLog(`‚úÖ [WIDGET-STATE] Reloaded notification settings for ${tabName} widget`);
              }
          }
          UnifiedState.data.popouts.overlays.set(tabName, overlay);
  
          // Setup handlers for the content (now that overlay is in DOM)
          setTimeout(() => {
              setupOverlayHandlers(overlay, tabName);
          }, 100);
  
          debugLog('OVERLAY_LIFECYCLE', `Content-only overlay created for ${tabName}`, {
              dimensions: `${overlay.style.width} x ${overlay.style.height}`,
              overlayId: overlay.id
          });
  
          return overlay;
      }
  
      function updateOverlayContent(contentArea, tabName) {
          let content = '';
          switch(tabName) {
              case 'pets':
                  content = getPetsPopoutContent();
                  break;
              case 'abilities':
                  content = getAbilitiesTabContent();
                  break;
              case 'seeds':
                  content = getSeedsTabContent();
                  break;
              case 'shop':
                  content = getShopTabContent();
                  break;
              case 'values':
                  content = getValuesTabContent();
                  break;
              case 'timers':
                  content = getTimersTabContent();
                  break;
              case 'tools':
                  content = getToolsTabContent();
                  break;
              case 'rooms':
                  content = getRoomStatusTabContent();
                  break;
              case 'settings':
                  content = getSettingsTabContent();
                  break;
              case 'help':
                  content = getHelpTabContent();
                  break;
              default:
                  content = '<p>Tab content not available</p>';
          }
  
          // Clear existing content except styles
          const styles = contentArea.querySelector('style');
          contentArea.innerHTML = '';
          if (styles) contentArea.appendChild(styles);
  
          const contentDiv = targetDocument.createElement('div');
          contentDiv.innerHTML = content;
          contentArea.appendChild(contentDiv);
  
          // Setup handlers if needed
          setTimeout(() => {
              try {
                  // Find the parent overlay element
                  const parentOverlay = contentArea.closest('.mga-overlay') || contentArea.parentElement;
                  debugLog('HANDLER_SETUP', `Setting up handlers for ${tabName}`, {
                      overlayFound: !!parentOverlay,
                      overlayClass: parentOverlay?.className,
                      contentAreaClass: contentArea?.className
                  });
  
                  switch(tabName) {
                      case 'abilities':
                          setupAbilitiesTabHandlers(parentOverlay);
                          // Ensure ability logs are populated immediately
                          if (parentOverlay) {
                              updateAbilityLogDisplay(parentOverlay);
                              debugLog('ABILITY_LOGS', 'Populated ability logs for new overlay', {
                                  logCount: UnifiedState.data.petAbilityLogs.length,
                                  overlayId: parentOverlay?.id || 'no-id'
                              });
  
                              // Additional delayed refresh to ensure logs appear
                              setTimeout(() => {
                                  updateAbilityLogDisplay(parentOverlay);
                                  debugLog('ABILITY_LOGS', 'Secondary refresh for ability logs completed');
                              }, 500);
                          } else {
                              debugError('HANDLER_SETUP', 'Could not find parent overlay for ability logs setup',
                                  new Error('Parent overlay not found'), { tabName, contentArea });
                          }
                          break;
                      case 'pets':
                          setupPetPopoutHandlers(overlay);  // Use popout handlers for overlays
                          break;
                      case 'seeds':
                          setupSeedsTabHandlers(overlay);
                          break;
                      case 'shop':
                          setupShopTabHandlers(overlay);
                          break;
                      case 'settings':
                          setupSettingsTabHandlers(overlay);
                          break;
                      case 'notifications':
                          setupNotificationsTabHandlers(parentOverlay);
                          break;
                  }
              } catch (error) {
                  debugError('HANDLER_SETUP', 'Failed to set up overlay handlers', error, {
                      tabName,
                      contentArea: contentArea?.className,
                      hasContent: !!contentArea
                  });
              }
          }, 100);
      }
  
      // INVISIBLE DRAGGING SYSTEM - Entire overlay surface is draggable
      function makeEntireOverlayDraggable(overlay) {
          let isDragging = false;
          let dragOffset = { x: 0, y: 0 };
          let animationFrame = null;
          let dragStartTime = 0;
  
          debugLog('OVERLAY_LIFECYCLE', 'Setting up invisible dragging for entire overlay', {
              overlayId: overlay.id
          });
  
          overlay.addEventListener('mousedown', (e) => {
              // Don't start drag if clicking on interactive elements or resize handle
              if (e.target.tagName === 'BUTTON' || e.target.tagName === 'INPUT' ||
                  e.target.tagName === 'SELECT' || e.target.closest('.mga-btn') ||
                  e.target.classList.contains('mga-resize-handle')) {
                  return;
              }
  
              e.preventDefault();
              e.stopPropagation();
  
              dragStartTime = Date.now();
              isDragging = false; // Start as false, will become true after movement threshold
  
              const rect = overlay.getBoundingClientRect();
              dragOffset.x = e.clientX - rect.left;
              dragOffset.y = e.clientY - rect.top;
          });
  
          document.addEventListener('mousemove', (e) => {
              if (dragStartTime === 0) return;
  
              const timeDiff = Date.now() - dragStartTime;
              const mouseMoved = Math.abs(e.clientX - dragOffset.x) > 3 || Math.abs(e.clientY - dragOffset.y) > 3;
  
              // Start dragging after small movement threshold to prevent accidental drags
              if (!isDragging && mouseMoved && timeDiff > 50) {
                  isDragging = true;
                  overlay.setAttribute('data-dragging', 'true');
  
                  // Professional drag start effects
                  overlay.style.zIndex = '999999';
                  overlay.style.transform = 'scale(1.02)';
                  overlay.style.filter = 'brightness(1.1)';
                  overlay.style.transition = 'transform 0.1s ease, filter 0.1s ease';
                  overlay.classList.add('mga-dragging');
                  targetDocument.body.style.userSelect = 'none';
                  targetDocument.body.style.cursor = 'grabbing !important';
  
                  debugLog('OVERLAY_LIFECYCLE', 'Started invisible dragging', { overlayId: overlay.id });
              }
  
              if (!isDragging) return;
  
              // Use RAF for smooth dragging performance
              if (animationFrame) {
                  cancelAnimationFrame(animationFrame);
              }
  
              animationFrame = requestAnimationFrame(() => {
                  const rect = overlay.getBoundingClientRect();
                  const newX = e.clientX - dragOffset.x;
                  const newY = e.clientY - dragOffset.y;
  
                  // Enhanced viewport constraints
                  const gameViewport = getGameViewport();
  
                  let constrainedX = Math.max(gameViewport.left,
                      Math.min(newX, gameViewport.right - rect.width));
                  let constrainedY = Math.max(gameViewport.top,
                      Math.min(newY, gameViewport.bottom - rect.height));
  
                  overlay.style.left = constrainedX + 'px';
                  overlay.style.top = constrainedY + 'px';
              });
          });
  
          document.addEventListener('mouseup', () => {
              if (dragStartTime > 0) {
                  dragStartTime = 0;
  
                  if (isDragging) {
                      isDragging = false;
                      overlay.removeAttribute('data-dragging');
                      overlay.classList.remove('mga-dragging');
  
                      // Professional drag end effects
                      overlay.style.transform = 'scale(1)';
                      overlay.style.filter = 'brightness(1)';
                      overlay.style.zIndex = '999998';
                      overlay.style.transition = 'transform 0.2s ease, filter 0.2s ease';
  
                      targetDocument.body.style.userSelect = '';
                      targetDocument.body.style.cursor = '';
  
                      if (animationFrame) {
                          cancelAnimationFrame(animationFrame);
                          animationFrame = null;
                      }
  
                      // Save position to localStorage
                      saveOverlayPosition(overlay.id, {
                          left: overlay.style.left,
                          top: overlay.style.top
                      });
  
                      debugLog('OVERLAY_LIFECYCLE', 'Finished invisible dragging', {
                          overlayId: overlay.id,
                          position: { left: overlay.style.left, top: overlay.style.top }
                      });
                  }
              }
          });
      }
  
      // Legacy draggable function for windowed overlays (to be replaced)
      function makeOverlayDraggable(overlay, header) {
          let isDragging = false;
          let dragOffset = { x: 0, y: 0 };
  
          header.addEventListener('mousedown', (e) => {
              if (e.target.tagName === 'BUTTON') return; // Don't drag when clicking buttons
  
              isDragging = true;
              const rect = overlay.getBoundingClientRect();
              dragOffset.x = e.clientX - rect.left;
              dragOffset.y = e.clientY - rect.top;
  
              overlay.style.zIndex = '999999'; // Bring to front while dragging
              targetDocument.body.style.userSelect = 'none';
              // Ensure proper cursor during drag - use grabbing instead of move
              targetDocument.body.style.cursor = 'grabbing !important';
  
              e.preventDefault();
          });
  
          document.addEventListener('mousemove', (e) => {
              if (!isDragging) return;
  
              const newX = e.clientX - dragOffset.x;
              const newY = e.clientY - dragOffset.y;
  
              // Constrain to game viewport
              const gameViewport = getGameViewport();
              const overlayRect = overlay.getBoundingClientRect();
  
              const constrainedX = Math.max(gameViewport.left,
                  Math.min(newX, gameViewport.right - overlayRect.width));
              const constrainedY = Math.max(gameViewport.top,
                  Math.min(newY, gameViewport.bottom - overlayRect.height));
  
              overlay.style.left = constrainedX + 'px';
              overlay.style.top = constrainedY + 'px';
          });
  
          document.addEventListener('mouseup', () => {
              if (isDragging) {
                  isDragging = false;
                  targetDocument.body.style.userSelect = '';
                  targetDocument.body.style.cursor = ''; // Reset cursor
                  overlay.style.zIndex = '999998'; // Return to normal z-index
              }
          });
      }
  
      function constrainOverlayToViewport(overlay) {
          const observer = new ResizeObserver(() => {
              const gameViewport = getGameViewport();
              const rect = overlay.getBoundingClientRect();
  
              if (rect.right > gameViewport.right) {
                  overlay.style.left = (gameViewport.right - rect.width) + 'px';
              }
              if (rect.bottom > gameViewport.bottom) {
                  overlay.style.top = (gameViewport.bottom - rect.height) + 'px';
              }
              if (rect.left < gameViewport.left) {
                  overlay.style.left = gameViewport.left + 'px';
              }
              if (rect.top < gameViewport.top) {
                  overlay.style.top = gameViewport.top + 'px';
              }
          });
  
          observer.observe(overlay);
  
          // Also listen for window resize
          window.addEventListener('resize', () => {
              const gameViewport = getGameViewport();
              const rect = overlay.getBoundingClientRect();
  
              if (rect.right > gameViewport.right) {
                  overlay.style.left = (gameViewport.right - rect.width) + 'px';
              }
              if (rect.bottom > gameViewport.bottom) {
                  overlay.style.top = (gameViewport.bottom - rect.height) + 'px';
              }
          });
      }
  
      function getGameViewport() {
          // Try to find the game container or use window as fallback
          const gameContainer = document.querySelector('#game-container, #app, .game-wrapper, main') || targetDocument.body;
          const rect = gameContainer.getBoundingClientRect();
  
          return {
              top: Math.max(0, rect.top),
              left: Math.max(0, rect.left),
              right: Math.min(window.innerWidth, rect.right),
              bottom: Math.min(window.innerHeight, rect.bottom)
          };
      }
  
      // PROFESSIONAL RESIZE SYSTEM FOR POP-OUTS
      function addResizeHandleToOverlay(overlay) {
          productionLog('üîß [RESIZE DEBUG] Adding resize handle to overlay:', overlay.id);
          debugLog('RESIZE', 'Adding resize handle to overlay', { overlayId: overlay.id });
  
          // Remove any existing resize handles first to prevent duplicates
          const existingHandle = overlay.querySelector('.mga-resize-handle');
          if (existingHandle) {
              existingHandle.remove();
              productionLog('üîß [RESIZE DEBUG] Removed existing handle before adding new one');
          }
  
          // Use the unified resize system with overlay-specific options
          makeElementResizable(overlay, {
              minWidth: 180,
              minHeight: 120,
              maxWidth: 450,
              maxHeight: 500,
              showHandleOnHover: true
          });
  
          // Add save dimensions functionality
          const observer = new MutationObserver(() => {
              if (overlay.style.width && overlay.style.height) {
                  saveOverlayDimensions(overlay.id, {
                      width: overlay.style.width,
                      height: overlay.style.height
                  });
              }
          });
  
          observer.observe(overlay, {
              attributes: true,
              attributeFilter: ['style']
          });
  
          // Store observer for cleanup later if needed
          overlay._resizeObserver = observer;
      }
  
      function saveOverlayDimensions(overlayId, dimensions) {
          try {
              const savedDimensions = MGA_loadJSON('MGA_overlayDimensions', {});
              savedDimensions[overlayId] = dimensions;
              MGA_saveJSON('MGA_overlayDimensions', savedDimensions);
  
              debugLog('OVERLAY_LIFECYCLE', 'Saved overlay dimensions', {
                  overlayId,
                  dimensions
              });
          } catch (error) {
              debugError('OVERLAY_LIFECYCLE', 'Failed to save overlay dimensions', error, {
                  overlayId,
                  dimensions
              });
          }
      }
  
  
      function loadOverlayDimensions(overlay) {
          try {
              const savedDimensions = MGA_loadJSON('MGA_overlayDimensions', {});
              const dimensions = savedDimensions[overlay.id];
  
              if (dimensions && dimensions.width && dimensions.height) {
                  const width = parseInt(dimensions.width);
                  const height = parseInt(dimensions.height);
  
                  if (!isNaN(width) && !isNaN(height)) {
                      overlay.style.width = dimensions.width;
                      overlay.style.height = dimensions.height;
  
                      // Apply responsive scaling for the loaded dimensions
                      applyResponsiveTextScaling(overlay, width, height);
  
                      debugLog('OVERLAY_LIFECYCLE', 'Restored overlay dimensions', {
                          overlayId: overlay.id,
                          dimensions
                      });
                  }
              }
          } catch (error) {
              debugError('OVERLAY_LIFECYCLE', 'Failed to load overlay dimensions', error, {
                  overlayId: overlay.id
              });
          }
      }
  
      // SMART POSITIONING SYSTEM - Professional collision avoidance
      function findOptimalPosition(tabName, gameViewport) {
          const overlayWidth = 240;
          const overlayHeight = 140;
          const margin = 15;
          const mainHudBuffer = 20; // Buffer around main HUD
          const snapGrid = 10; // Snap to 10px increments
  
          // Check if we have a saved position first
          const savedPositions = MGA_loadJSON('MGA_overlayPositions', {});
          const savedPosition = savedPositions[`mga-overlay-${tabName}`];
  
          if (savedPosition) {
              const leftPx = parseInt(savedPosition.left);
              const topPx = parseInt(savedPosition.top);
  
              if (!isNaN(leftPx) && !isNaN(topPx) &&
                  leftPx >= gameViewport.left && topPx >= gameViewport.top &&
                  leftPx + overlayWidth <= gameViewport.right &&
                  topPx + overlayHeight <= gameViewport.bottom) {
  
                  // Check for collisions with existing overlays and main HUD
                  if (!hasCollisionAtPosition(leftPx, topPx, overlayWidth, overlayHeight)) {
                      debugLog('OVERLAY_LIFECYCLE', 'Using saved position with no collisions', {
                          tabName,
                          position: { left: leftPx, top: topPx }
                      });
                      return { left: leftPx, top: topPx };
                  }
              }
          }
  
          // Define priority zones (in order of preference)
          const priorityZones = [
              // Zone 1: Right side of game viewport
              {
                  name: 'rightSide',
                  x: gameViewport.right - overlayWidth - margin,
                  y: gameViewport.top + margin,
                  maxX: gameViewport.right - margin,
                  maxY: gameViewport.bottom - overlayHeight - margin,
                  stepX: 0,
                  stepY: overlayHeight + margin
              },
              // Zone 2: Left side if right is full
              {
                  name: 'leftSide',
                  x: gameViewport.left + margin,
                  y: gameViewport.top + margin,
                  maxX: gameViewport.left + overlayWidth + margin,
                  maxY: gameViewport.bottom - overlayHeight - margin,
                  stepX: 0,
                  stepY: overlayHeight + margin
              },
              // Zone 3: Top area (cascade down)
              {
                  name: 'topArea',
                  x: gameViewport.left + margin + overlayWidth + margin,
                  y: gameViewport.top + margin,
                  maxX: gameViewport.right - overlayWidth - margin,
                  maxY: gameViewport.top + overlayHeight * 3,
                  stepX: overlayWidth + margin,
                  stepY: 30
              },
              // Zone 4: Bottom area (cascade up)
              {
                  name: 'bottomArea',
                  x: gameViewport.left + margin,
                  y: gameViewport.bottom - overlayHeight * 3,
                  maxX: gameViewport.right - overlayWidth - margin,
                  maxY: gameViewport.bottom - overlayHeight - margin,
                  stepX: overlayWidth + margin,
                  stepY: overlayHeight + margin
              }
          ];
  
          // Try each priority zone
          for (const zone of priorityZones) {
              const position = findPositionInZone(zone, overlayWidth, overlayHeight, snapGrid, mainHudBuffer);
              if (position) {
                  debugLog('OVERLAY_LIFECYCLE', `Found optimal position in ${zone.name}`, {
                      tabName,
                      position,
                      zone: zone.name
                  });
                  return position;
              }
          }
  
          // Ultimate fallback with collision avoidance
          let fallbackX = gameViewport.left + margin;
          let fallbackY = gameViewport.top + margin;
          let attempts = 0;
  
          while (attempts < 20) {
              if (!hasCollisionAtPosition(fallbackX, fallbackY, overlayWidth, overlayHeight) &&
                  !overlapsMainHUD(fallbackX, fallbackY, overlayWidth, overlayHeight)) {
                  break;
              }
              fallbackX += 30;
              fallbackY += 30;
  
              // Wrap around if we go out of bounds
              if (fallbackX + overlayWidth > gameViewport.right) {
                  fallbackX = gameViewport.left + margin;
                  fallbackY += overlayHeight + margin;
              }
              if (fallbackY + overlayHeight > gameViewport.bottom) {
                  fallbackY = gameViewport.top + margin;
              }
              attempts++;
          }
  
          debugLog('OVERLAY_LIFECYCLE', 'Using fallback positioning', {
              tabName,
              attempts,
              position: { left: fallbackX, top: fallbackY }
          });
          return {
              left: fallbackX,
              top: fallbackY
          };
      }
  
      function findPositionInZone(zone, overlayWidth, overlayHeight, snapGrid, mainHudBuffer) {
          let x = zone.x;
          let y = zone.y;
  
          while (y <= zone.maxY) {
              while (x <= zone.maxX) {
                  // Snap to grid
                  const snappedX = Math.round(x / snapGrid) * snapGrid;
                  const snappedY = Math.round(y / snapGrid) * snapGrid;
  
                  // Check bounds
                  if (snappedX + overlayWidth <= zone.maxX &&
                      snappedY + overlayHeight <= zone.maxY) {
  
                      // Check collisions with existing overlays and main HUD
                      if (!hasCollisionAtPosition(snappedX, snappedY, overlayWidth, overlayHeight) &&
                          !overlapsMainHUD(snappedX, snappedY, overlayWidth, overlayHeight)) {
                          return { left: snappedX, top: snappedY };
                      }
                  }
  
                  x += zone.stepX || (overlayWidth + 15);
                  if (zone.stepX === 0) break; // Single column zone
              }
              x = zone.x;
              y += zone.stepY || 30;
          }
  
          return null;
      }
  
      function overlapsMainHUD(x, y, width, height) {
          const mainHUD = targetDocument.querySelector('.mga-panel');
          if (!mainHUD) return false;
  
          const mainHudRect = mainHUD.getBoundingClientRect();
          const buffer = 20; // 20px buffer around main HUD
  
          // Expand main HUD rect by buffer
          const expandedRect = {
              left: mainHudRect.left - buffer,
              top: mainHudRect.top - buffer,
              right: mainHudRect.right + buffer,
              bottom: mainHudRect.bottom + buffer
          };
  
          // Check for overlap
          return !(x + width < expandedRect.left ||
                  x > expandedRect.right ||
                  y + height < expandedRect.top ||
                  y > expandedRect.bottom);
      }
  
      function hasCollisionAtPosition(x, y, width, height) {
          const existingOverlays = Array.from(targetDocument.querySelectorAll('.mga-overlay-content-only'));
          const buffer = 5; // Minimum spacing between overlays
  
          for (const existingOverlay of existingOverlays) {
              const rect = existingOverlay.getBoundingClientRect();
  
              // Check for overlap with buffer
              if (!(x + width + buffer < rect.left ||
                    x - buffer > rect.right ||
                    y + height + buffer < rect.top ||
                    y - buffer > rect.bottom)) {
                  return true; // Collision detected
              }
          }
          return false; // No collision
      }
  
      // OVERLAY POSITION PERSISTENCE SYSTEM
      function saveOverlayPosition(overlayId, position) {
          try {
              const savedPositions = MGA_loadJSON('MGA_overlayPositions', {});
              savedPositions[overlayId] = position;
              MGA_saveJSON('MGA_overlayPositions', savedPositions);
  
              debugLog('OVERLAY_LIFECYCLE', 'Saved overlay position', {
                  overlayId,
                  position
              });
          } catch (error) {
              debugError('OVERLAY_LIFECYCLE', 'Failed to save overlay position', error, {
                  overlayId,
                  position
              });
          }
      }
  
      function loadOverlayPosition(overlay) {
          try {
              const savedPositions = MGA_loadJSON('MGA_overlayPositions', {});
              const position = savedPositions[overlay.id];
  
              if (position) {
                  // Validate position is still within viewport
                  const gameViewport = getGameViewport();
                  const leftPx = parseInt(position.left);
                  const topPx = parseInt(position.top);
  
                  if (!isNaN(leftPx) && !isNaN(topPx) &&
                      leftPx >= gameViewport.left && topPx >= gameViewport.top &&
                      leftPx < gameViewport.right && topPx < gameViewport.bottom) {
  
                      overlay.style.left = position.left;
                      overlay.style.top = position.top;
  
                      debugLog('OVERLAY_LIFECYCLE', 'Restored overlay position', {
                          overlayId: overlay.id,
                          position
                      });
                  } else {
                      debugLog('OVERLAY_LIFECYCLE', 'Saved position out of bounds, using default', {
                          overlayId: overlay.id,
                          savedPosition: position,
                          viewport: gameViewport
                      });
                  }
              }
          } catch (error) {
              debugError('OVERLAY_LIFECYCLE', 'Failed to load overlay position', error, {
                  overlayId: overlay.id
              });
          }
      }
  
      // PROFESSIONAL MINIMIZE/MAXIMIZE FUNCTIONALITY
      function toggleOverlayMinimized(overlay, tabName) {
          const isMinimized = overlay.hasAttribute('data-minimized');
          const contentContainer = overlay.querySelector('.mga-content-container');
  
          if (isMinimized) {
              // EXPAND - Restore to normal state
              overlay.removeAttribute('data-minimized');
              overlay.style.height = 'auto';
              overlay.style.minHeight = '80px';
              overlay.style.maxHeight = '180px';
              overlay.style.overflow = 'visible'; // Allow resize handles to show
  
              if (contentContainer) {
                  contentContainer.style.display = 'block';
                  contentContainer.style.opacity = '1';
              }
  
              // Update minimize button
              const minimizeBtn = overlay.querySelector('.mga-drag-zone div:last-child');
              if (minimizeBtn) {
                  minimizeBtn.innerHTML = '‚îÄ';
                  minimizeBtn.title = 'Minimize';
              }
  
              debugLog('OVERLAY_LIFECYCLE', `Expanded overlay ${tabName}`, {
                  overlayId: overlay.id
              });
  
          } else {
              // MINIMIZE - Collapse to title bar only
              overlay.setAttribute('data-minimized', 'true');
              overlay.style.height = '18px';
              overlay.style.minHeight = '18px';
              overlay.style.maxHeight = '18px';
              overlay.style.overflow = 'visible'; // Allow resize handles to show
  
              if (contentContainer) {
                  contentContainer.style.display = 'none';
                  contentContainer.style.opacity = '0';
              }
  
              // Update minimize button to restore button
              const minimizeBtn = overlay.querySelector('.mga-drag-zone div:last-child');
              if (minimizeBtn) {
                  minimizeBtn.innerHTML = '‚ñ°';
                  minimizeBtn.title = 'Restore';
              }
  
              debugLog('OVERLAY_LIFECYCLE', `Minimized overlay ${tabName}`, {
                  overlayId: overlay.id
              });
          }
  
          // Save minimized state
          const overlayStates = MGA_loadJSON('MGA_overlayStates', {});
          overlayStates[overlay.id] = { minimized: !isMinimized };
          MGA_saveJSON('MGA_overlayStates', overlayStates);
  
          // Add smooth animation
          overlay.style.transition = 'height 0.2s ease, min-height 0.2s ease, max-height 0.2s ease';
          setTimeout(() => {
              overlay.style.transition = '';
          }, 200);
      }
  
      function loadOverlayState(overlay) {
          try {
              const overlayStates = MGA_loadJSON('MGA_overlayStates', {});
              const state = overlayStates[overlay.id];
  
              if (state && state.minimized) {
                  // Apply minimized state without animation on startup
                  overlay.setAttribute('data-minimized', 'true');
                  overlay.style.height = '18px';
                  overlay.style.minHeight = '18px';
                  overlay.style.maxHeight = '18px';
                  overlay.style.overflow = 'visible'; // Allow resize handles to show
  
                  const contentContainer = overlay.querySelector('.mga-content-container');
                  if (contentContainer) {
                      contentContainer.style.display = 'none';
                      contentContainer.style.opacity = '0';
                  }
  
                  const minimizeBtn = overlay.querySelector('.mga-drag-zone div:last-child');
                  if (minimizeBtn) {
                      minimizeBtn.innerHTML = '‚ñ°';
                      minimizeBtn.title = 'Restore';
                  }
  
                  debugLog('OVERLAY_LIFECYCLE', `Loaded minimized state for ${overlay.id}`);
              }
          } catch (error) {
              debugError('OVERLAY_LIFECYCLE', 'Failed to load overlay state', error, {
                  overlayId: overlay.id
              });
          }
      }
  
      function closeInGameOverlay(tabName) {
          const overlay = UnifiedState.data.popouts.overlays.get(tabName);
          if (overlay && document.contains(overlay)) {
              overlay.remove();
          }
          UnifiedState.data.popouts.overlays.delete(tabName);
  
          // Update the corresponding pop-out button state
          updatePopoutButtonStateByTab(tabName, false);
  
          productionLog(`üóëÔ∏è Closed in-game overlay for ${tabName} tab`);
      }
  
      function updatePopoutButtonStateByTab(tabName, isActive) {
          const popoutBtn = targetDocument.querySelector(`[data-popout="${tabName}"]`);
          if (popoutBtn) {
              updatePopoutButtonState(popoutBtn, isActive);
          }
      }
  
      // NEW: Update function for pure content overlays
      function updatePureOverlayContent(overlay, tabName) {
          try {
              debugLog('OVERLAY_LIFECYCLE', `Updating pure overlay content for ${tabName}`, {
                  overlayId: overlay.id
              });
  
              let content = '';
              switch(tabName) {
                  case 'pets':
                      content = getPetsPopoutContent();  // Use popout version for overlays too
                      break;
                  case 'abilities':
                      content = getAbilitiesTabContent();
                      break;
                  case 'seeds':
                      content = getSeedsTabContent();
                      break;
                  case 'values':
                      content = getValuesTabContent();
                      break;
                  case 'timers':
                      content = getTimersTabContent();
                      break;
                  case 'settings':
                      content = getSettingsTabContent();
                      break;
                  default:
                      content = '<p>Tab content not available</p>';
              }
  
              // Create the full content with styles (matching createInGameOverlay structure)
              const contentHtml = `
              <style>
                  /* TARGET IMAGE MATCH - Clean, readable styling */
                  /* Section titles are now handled in the main visibility rules above */
  
                  .mga-overlay-content-only .mga-section {
                      margin: 0 !important;
                      padding: 0 !important;
                  }
  
                  .mga-overlay-content-only .mga-value-row {
                      display: flex !important;
                      justify-content: space-between !important;
                      margin: 3px 0 !important;
                      padding: 2px 0 !important;
                      line-height: 1.3 !important;
                  }
  
                  .mga-overlay-content-only .mga-value-label {
                      font-size: 12px !important;
                      color: rgba(255, 255, 255, 0.9) !important;
                      font-weight: 400 !important;
                      margin: 0 !important;
                      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
                  }
  
                  .mga-overlay-content-only .mga-value-amount {
                      font-size: 13px !important;
                      font-weight: 600 !important;
                      color: #ffffff !important;
                      margin: 0 !important;
                      text-align: right;
                      min-width: 50px;
                      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
                  }
  
                  /* HIGH CONTRAST TOTAL VALUE */
                  .mga-overlay-content-only .mga-total-value {
                      border-top: 1px solid rgba(255, 255, 255, 0.73) !important;
                      margin-top: 6px !important;
                      padding-top: 4px !important;
                  }
  
                  .mga-overlay-content-only .mga-total-value .mga-value-label {
                      font-weight: 500 !important;
                      color: rgba(255, 255, 255, 0.95) !important;
                      font-size: 13px !important;
                  }
  
                  .mga-overlay-content-only .mga-total-value .mga-value-amount {
                      font-size: 14px !important;
                      font-weight: 700 !important;
                      color: #ffff00 !important;
                      text-shadow: 0 1px 3px rgba(0, 0, 0, 0.8);
                  }
  
                  /* Hide only truly unnecessary elements - KEEP buttons and checkboxes for functionality */
                  .mga-overlay-content-only .mga-section-header,
                  .mga-overlay-content-only .mga-input-group,
                  .mga-overlay-content-only .mga-timer-controls {
                      display: none !important;
                  }
  
                  /* Keep section titles visible but make them smaller */
                  .mga-overlay-content-only .mga-section-title {
                      display: block !important;
                      font-size: 11px !important;
                      margin-bottom: 4px !important;
                  }
  
                  /* Readable ability logs */
                  .mga-overlay-content-only .mga-log-item {
                      margin: 2px 0 !important;
                      padding: 2px 0 !important;
                      font-size: 11px !important;
                      line-height: 1.3 !important;
                      color: rgba(255, 255, 255, 0.9) !important;
                      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
                  }
  
                  .mga-overlay-content-only .mga-log-time {
                      font-size: 10px !important;
                      color: rgba(255, 255, 255, 0.7) !important;
                  }
  
                  /* Readable pet loadouts */
                  .mga-overlay-content-only .mga-pet-slot {
                      margin: 2px 0 !important;
                      padding: 3px !important;
                      font-size: 11px !important;
                      color: rgba(255, 255, 255, 0.9) !important;
                      text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
                  }
              </style>
          `;
  
              // Update overlay content
              productionLog('üîç [PURE OVERLAY DEBUG] Variables check:', {
                  contentHtmlType: typeof contentHtml,
                  contentHtmlLength: contentHtml?.length,
                  contentType: typeof content,
                  contentLength: content?.length,
                  contentHtmlPreview: contentHtml?.substring(0, 100),
                  contentPreview: content?.substring(0, 100)
              });
  
              overlay.innerHTML = contentHtml + content;
  
              // Setup handlers for the overlay
              setupPureOverlayHandlers(overlay, tabName);
  
              // Re-add resize handle after content update (since innerHTML replaces everything)
              setTimeout(() => {
                  if (!overlay.querySelector('.mga-resize-handle')) {
                      addResizeHandleToOverlay(overlay);
                      productionLog(`üîß [RESIZE] Re-added missing resize handle to ${tabName} pure overlay`);
                  }
              }, 50);
  
          } catch (error) {
              debugError('OVERLAY_LIFECYCLE', 'Failed to update pure overlay content', error, {
                  tabName,
                  overlayId: overlay.id
              });
          }
      }
  
      function setupPureOverlayHandlers(overlay, tabName) {
          setTimeout(() => {
              try {
                  productionLog(`üîß [HANDLER-SETUP] Setting up handlers for ${tabName} overlay`);
                  debugLog('HANDLER_SETUP', `Setting up pure overlay handlers for ${tabName}`, {
                      overlayId: overlay.id
                  });
  
                  switch(tabName) {
                      case 'abilities':
                          setupAbilitiesTabHandlers(overlay);
                          updateAbilityLogDisplay(overlay);
                          debugLog('ABILITY_LOGS', 'Set up ability logs for pure overlay', {
                              logCount: UnifiedState.data.petAbilityLogs.length,
                              overlayId: overlay.id
                          });
                          break;
                      case 'pets':
                          setupPetPopoutHandlers(overlay);  // Use popout handlers for overlays
                          break;
                      case 'seeds':
                          setupSeedsTabHandlers(overlay);
                          break;
                      case 'settings':
                          setupSettingsTabHandlers(overlay);
                          break;
                      case 'tools':
                          setupToolsTabHandlers(overlay);
                          break;
                      default:
                          break;
                  }
              } catch (error) {
                  debugError('HANDLER_SETUP', 'Failed to set up pure overlay handlers', error, {
                      tabName,
                      overlayId: overlay.id
                  });
              }
          }, 200);  // Increased from 100ms to 200ms to ensure DOM is fully updated
      }
  
      function refreshOverlayContent(tabName) {
          const overlay = UnifiedState.data.popouts.overlays.get(tabName);
          if (overlay && document.contains(overlay)) {
              // NEW: Handle pure content overlays (no .mga-overlay-content wrapper)
              if (overlay.className.includes('mga-overlay-content-only')) {
                  updatePureOverlayContent(overlay, tabName);
                  productionLog(`üîÑ Refreshed pure overlay content for ${tabName} tab`);
              } else {
                  // LEGACY: Handle old overlay structure if it exists
                  const contentArea = overlay.querySelector('.mga-overlay-content');
                  if (contentArea) {
                      updateOverlayContent(contentArea, tabName);
                      productionLog(`üîÑ Refreshed legacy overlay content for ${tabName} tab`);
                  }
              }
          }
      }
  
      // Rename original function to avoid conflicts
      function openTabInSeparateWindow(tabName) {
          productionLog(`üîó Opening ${tabName} tab in separate window...`);
  
          const tabTitles = {
              pets: 'üêæ Pets',
              abilities: '‚ö° Abilities',
              seeds: 'üå± Seeds',
              values: 'üí∞ Values',
              timers: '‚è∞ Timers',
              settings: '‚öôÔ∏è Settings'
          };
  
          const title = `MGTools - ${tabTitles[tabName] || tabName}`;
          const windowFeatures = 'width=500,height=550,scrollbars=yes,resizable=yes,menubar=no,toolbar=no,location=no,status=no';
          const popoutWindow = window.open('', `mga_popout_${tabName}`, windowFeatures);
  
          if (!popoutWindow) {
              productionWarn('‚ö†Ô∏è Pop-out blocked! Please allow popups for this site.');
              return;
          }
  
          // Track the popout window for cleanup
          trackPopoutWindow(popoutWindow);
  
          // BUGFIX: Store window reference in Map for real-time updates
          UnifiedState.data.popouts.windows.set(tabName, popoutWindow);
  
          // Add cleanup listener to remove from Map when window closes
          popoutWindow.addEventListener('beforeunload', () => {
              UnifiedState.data.popouts.windows.delete(tabName);
              debugLog('POPOUT_LIFECYCLE', `Removed ${tabName} from windows Map`);
          });
  
          // Get tab content based on tab name
          let content = '';
          switch(tabName) {
              case 'pets':
                  content = getPetsPopoutContent();
                  break;
              case 'abilities':
                  content = getAbilitiesTabContent();
                  break;
              case 'seeds':
                  content = getSeedsTabContent();
                  break;
              case 'shop':
                  content = getShopTabContent();
                  break;
              case 'values':
                  content = getValuesTabContent();
                  break;
              case 'timers':
                  content = getTimersTabContent();
                  break;
              case 'tools':
                  content = getToolsTabContent();
                  break;
              case 'rooms':
                  content = getRoomStatusTabContent();
                  break;
              case 'settings':
                  content = getSettingsTabContent();
                  break;
              case 'help':
                  content = getHelpTabContent();
                  break;
              default:
                  content = '<p>Tab content not available</p>';
          }
  
          // Get current theme for pop-out window
          const currentTheme = UnifiedState.currentTheme || generateThemeStyles();
  
          // Create pop-out window HTML with dynamic theming
          const popoutHTML = `
  <!DOCTYPE html>
  <html>
  <head>
      <title>${title}</title>
      <style>
          ${UNIFIED_STYLES}
          body {
              margin: 0;
              padding: 16px;
              background: ${currentTheme.background};
              color: #ffffff;
              font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
              min-height: 100vh;
              --panel-scale: 1;
              --base-font-size: 13px;
              --responsive-font-size: calc(var(--base-font-size) * var(--panel-scale));
              font-size: var(--responsive-font-size);
          }
  
          /* Removed universal font scaling to prevent oversized popout UI */
          .popout-header {
              display: flex;
              justify-content: space-between;
              align-items: center;
              margin-bottom: 16px;
              padding: 12px;
              background: rgba(255, 255, 255, 0.05);
              border-radius: 8px;
              border: 1px solid rgba(255, 255, 255, 0.57);
              flex-wrap: wrap;
              gap: 10px;
          }
          .popout-title {
              font-size: 18px;
              font-weight: 600;
              color: #4a9eff;
              flex-shrink: 0;
              min-width: 150px;
          }
          .popout-sync-notice {
              font-size: 12px;
              color: #888;
              font-style: italic;
              flex: 1 1 auto;
              text-align: center;
              min-width: 200px;
          }
          .refresh-btn {
              padding: 6px 12px;
              background: #4a9eff;
              color: white;
              border: none;
              border-radius: 4px;
              cursor: pointer;
              font-size: 12px;
              flex-shrink: 0;
          }
          .refresh-btn:hover {
              background: #3a8eef;
          }
      </style>
  </head>
  <body>
      <div class="popout-header">
          <div class="popout-title">${title}</div>
          <div class="popout-sync-notice">Click refresh to sync with main window</div>
          <button class="refresh-btn" onclick="refreshPopoutContent('${tabName}')">üîÑ Refresh</button>
      </div>
  
      <div id="popout-content" class="mga-scrollable mga-popout-content" style="max-height: calc(100vh - 120px); overflow-y: auto;">
          ${content}
      </div>
  
      <script>
          // Store reference to main window
          const mainWindow = window.opener;
  
          function refreshPopoutContent(tabName) {
              if (!mainWindow || mainWindow.closed) {
                  productionWarn('‚ö†Ô∏è Main window is closed. Cannot refresh content.');
                  return;
              }
  
              // Get fresh content from main window
              let freshContent = '';
              switch(tabName) {
                  case 'pets':
                      freshContent = mainWindow.MGA_Internal?.getPetsPopoutContent ? mainWindow.MGA_Internal?.getPetsPopoutContent() : 'Content unavailable';
                      break;
                  case 'abilities':
                      freshContent = mainWindow.MGA_Internal?.getAbilitiesTabContent ? mainWindow.MGA_Internal?.getAbilitiesTabContent() : 'Content unavailable';
                      break;
                  case 'seeds':
                      freshContent = mainWindow.MGA_Internal?.getSeedsTabContent ? mainWindow.MGA_Internal?.getSeedsTabContent() : 'Content unavailable';
                      break;
                  case 'shop':
                      freshContent = mainWindow.MGA_Internal?.getShopTabContent ? mainWindow.MGA_Internal?.getShopTabContent() : 'Content unavailable';
                      break;
                  case 'values':
                      freshContent = mainWindow.MGA_Internal?.getValuesTabContent ? mainWindow.MGA_Internal?.getValuesTabContent() : 'Content unavailable';
                      break;
                  case 'timers':
                      freshContent = mainWindow.MGA_Internal?.getTimersTabContent ? mainWindow.MGA_Internal?.getTimersTabContent() : 'Content unavailable';
                      break;
                  case 'tools':
                      freshContent = mainWindow.MGA_Internal?.getToolsTabContent ? mainWindow.MGA_Internal?.getToolsTabContent() : 'Content unavailable';
                      break;
                  case 'rooms':
                      freshContent = mainWindow.MGA_Internal?.getRoomStatusTabContent ? mainWindow.MGA_Internal?.getRoomStatusTabContent() : 'Content unavailable';
                      break;
                  case 'settings':
                      freshContent = mainWindow.MGA_Internal?.getSettingsTabContent ? mainWindow.MGA_Internal?.getSettingsTabContent() : 'Content unavailable';
                      break;
              }
  
              document.getElementById('popout-content').innerHTML = freshContent;
  
              // Rerun handlers if needed
              if (tabName === 'abilities' && mainWindow.setupAbilitiesTabHandlers) {
                  mainWindow.setupAbilitiesTabHandlers.call(mainWindow);
                  if (mainWindow.updateAbilityLogDisplay) {
                      mainWindow.updateAbilityLogDisplay.call(mainWindow);
                  }
              } else if (tabName === 'pets') {
                  // For pets popout, use special popout handlers instead of main tab handlers
                  if (mainWindow.setupPetPopoutHandlers) {
                      mainWindow.setupPetPopoutHandlers.call(mainWindow, document);
                  }
              } else if (tabName === 'seeds' && mainWindow.setupSeedsTabHandlers) {
                  mainWindow.setupSeedsTabHandlers.call(mainWindow, document);
              } else if (tabName === 'values' && mainWindow.resourceDashboard) {
                  mainWindow.resourceDashboard.setupDashboardHandlers(document);
              } else if (tabName === 'settings' && mainWindow.setupSettingsTabHandlers) {
                  mainWindow.setupSettingsTabHandlers.call(mainWindow, document);
              }
          }
  
          // BUGFIX: Expose refresh function on window object for external access
          window.refreshPopoutContent = refreshPopoutContent;
  
          // Store the tab name for this popup window
          const currentTabName = '\${tabName}';
  
          // Auto-refresh every 30 seconds - Use managed interval to prevent memory leaks
          if (window.opener && window.opener.setManagedInterval) {
              window.opener.setManagedInterval(
                  'popoutRefresh_' + currentTabName + '_' + Date.now(),
                  () => refreshPopoutContent(currentTabName),
                  30000
              );
          }
  
          // Cleanup when window closes
          window.addEventListener('beforeunload', () => {
              productionLog('Pop-out window closing for:', currentTabName);
          });
      </script>
  </body>
  </html>
          `;
  
          popoutWindow.document.open();
          popoutWindow.document.write(popoutHTML);
          popoutWindow.document.close();
  
          // Set up handlers for the separate window popout content
          setTimeout(() => {
              try {
                  switch(tabName) {
                      case 'pets':
                          setupPetPopoutHandlers(popoutWindow.document);  // Use popout handlers
                          break;
                      case 'seeds':
                          setupSeedsTabHandlers(popoutWindow.document);
                          break;
                      case 'shop':
                          setupShopTabHandlers(popoutWindow.document);
                          break;
                      case 'settings':
                          setupSettingsTabHandlers(popoutWindow.document);
                          break;
                      case 'tools':
                          setupToolsTabHandlers(popoutWindow.document);
                          break;
                      case 'rooms':
                          setupRoomJoinButtons();
                          break;
                      case 'hotkeys':
                          setupHotkeysTabHandlers(popoutWindow.document);
                          break;
                      case 'notifications':
                          setupNotificationsTabHandlers(popoutWindow.document);
                          break;
                      case 'abilities':
                          // Abilities handlers are complex due to cross-window limitations
                          break;
                  }
              } catch (error) {
                  productionWarn('Could not set up separate window popout handlers:', error);
              }
          }, 100);
  
          productionLog(`‚úÖ Separate window opened for ${tabName} tab`);
      }
  
      // TOGGLE FUNCTIONALITY - Professional pop-out management
      function toggleTabPopout(tabName, buttonElement) {
          const isOverlayMode = UnifiedState.data.settings.useInGameOverlays;
  
          if (isOverlayMode) {
              // Check if overlay already exists
              const existingOverlay = UnifiedState.data.popouts.overlays.get(tabName);
  
              if (existingOverlay && document.contains(existingOverlay)) {
                  // CLOSE existing overlay
                  closeInGameOverlay(tabName);
                  updatePopoutButtonState(buttonElement, false);
                  debugLog('OVERLAY_LIFECYCLE', `Toggled OFF: ${tabName} overlay closed`);
              } else {
                  // OPEN new overlay
                  createInGameOverlay(tabName);
                  updatePopoutButtonState(buttonElement, true);
                  debugLog('OVERLAY_LIFECYCLE', `Toggled ON: ${tabName} overlay opened`);
              }
          } else {
              // For separate windows, always open (can't easily detect if window is open)
              openTabInSeparateWindow(tabName);
              updatePopoutButtonState(buttonElement, true);
              debugLog('OVERLAY_LIFECYCLE', `Opened separate window for ${tabName}`);
          }
      }
  
      function updatePopoutButtonState(buttonElement, isActive) {
          if (isActive) {
              buttonElement.style.color = '#4CAF50';
              buttonElement.style.transform = 'scale(1.1)';
              buttonElement.style.opacity = '1';
              buttonElement.title = 'Click to close pop-out';
          } else {
              buttonElement.style.color = '';
              buttonElement.style.transform = '';
              buttonElement.style.opacity = '';
              buttonElement.title = 'Click to open in pop-out';
          }
      }
  
      // Legacy function - Update openTabInPopout to check overlay preference
      function openTabInPopout(tabName) {
          if (UnifiedState.data.settings.useInGameOverlays) {
              return createInGameOverlay(tabName);
          } else {
              return openTabInSeparateWindow(tabName);
          }
      }
  
      // ==================== TAB CONTENT CACHE SYSTEM ====================
      // Performance optimization: Cache static tab content to reduce regeneration
      const tabContentCache = new Map();
      const TAB_CACHE_DURATION = 30000; // 30 seconds for static tabs
  
      function getCachedTabContent(tabName, generator) {
          // Never cache dynamic tabs (they need real-time data)
          const dynamicTabs = ['pets', 'abilities', 'seeds', 'shop', 'values', 'timers', 'rooms', 'hotkeys', 'settings', 'notifications', 'protect'];
          if (dynamicTabs.includes(tabName)) {
              return generator();
          }
  
          // Check cache for static tabs
          const cached = tabContentCache.get(tabName);
          const now = Date.now();
  
          if (cached && now - cached.timestamp < TAB_CACHE_DURATION) {
              return cached.content;
          }
  
          // Generate and cache
          const content = generator();
          tabContentCache.set(tabName, { content, timestamp: now });
          return content;
      }
  
      // Invalidate tab cache (call when settings change)
      function invalidateTabCache(tabName = null) {
          if (tabName) {
              tabContentCache.delete(tabName);
          } else {
              tabContentCache.clear();
          }
      }
  
      window.MGA_TabCache = { getCachedTabContent, invalidateTabCache };
  
      function updateTabContent() {
          const contentEl = getCachedElement('#mga-tab-content') || document.getElementById('mga-tab-content');
  
          // Safety check - if content element doesn't exist, bail out (normal during initialization)
          if (!contentEl) {
              debugLog('UPDATE_TAB', 'Content element not found, skipping update (UI not ready yet)');
              return;
          }
  
          // Preserve input state for pets tab to prevent typing interruption
          let preservedInputValue = '';
          let preservedInputFocused = false;
          let preservedCursorPosition = 0;
          if (UnifiedState.activeTab === 'pets') {
              const currentInput = document.getElementById('preset-name-input');
              if (currentInput) {
                  preservedInputValue = currentInput.value;
                  preservedInputFocused = document.activeElement === currentInput;
                  preservedCursorPosition = currentInput.selectionStart || 0;
                  if (UnifiedState.data.settings.debugMode) {
                      productionLog('üîí Preserving input state:', { value: preservedInputValue, focused: preservedInputFocused, cursor: preservedCursorPosition });
                  }
              }
          }
  
          // Add data attribute for CSS targeting
          contentEl.setAttribute('data-active', UnifiedState.activeTab);
  
          switch(UnifiedState.activeTab) {
              case 'pets':
                  // üîç RENDER CYCLE DEBUG: Track pets tab content generation
                  productionLog('üîÑ [RENDER-CYCLE] Starting pets tab content generation', {
                      timestamp: new Date().toLocaleTimeString(),
                      activeTab: UnifiedState.activeTab,
                      atomActivePets: UnifiedState.atoms.activePets?.length || 0,
                      windowActivePets: window.activePets?.length || 0,
                      renderTrigger: 'updateTabContent'
                  });
  
                  const petsHtml = getPetsTabContent();
                  productionLog('üîÑ [RENDER-CYCLE] Generated pets HTML', {
                      htmlLength: petsHtml.length,
                      containsActivePets: petsHtml.includes('Active Pets'),
                      containsPetData: petsHtml.includes('mga-pet-'),
                      renderStage: 'html-generated'
                  });
  
                  contentEl.innerHTML = petsHtml;
  
                  // Check what was actually rendered to DOM
                  setTimeout(() => {
                      const activePetsElements = contentEl.querySelectorAll('.mga-pet-item');
                      productionLog('üîÑ [RENDER-CYCLE] DOM render result', {
                          activePetsInDOM: activePetsElements.length,
                          elementsFound: activePetsElements.length > 0,
                          renderStage: 'dom-updated',
                          timestamp: new Date().toLocaleTimeString()
                      });
                  }, 10);
  
                  setupPetsTabHandlers();
  
                  // Restore input state after HTML regeneration
                  if (preservedInputValue || preservedInputFocused) {
                      setTimeout(() => {
                          const newInput = document.getElementById('preset-name-input');
                          if (newInput) {
                              newInput.value = preservedInputValue;
                              if (preservedInputFocused) {
                                  newInput.focus();
                                  // Set cursor to preserved position
                                  newInput.setSelectionRange(preservedCursorPosition, preservedCursorPosition);
                                  if (UnifiedState.data.settings.debugMode) {
                                      productionLog('‚úÖ Restored input state:', { value: newInput.value, focused: document.activeElement === newInput });
                                  }
                              }
                          }
                      }, 0);
                  }
                  break;
              case 'abilities':
                  contentEl.innerHTML = getAbilitiesTabContent();
                  setupAbilitiesTabHandlers();
                  updateAbilityLogDisplay();
                  break;
              case 'seeds':
                  contentEl.innerHTML = getSeedsTabContent();
                  setupSeedsTabHandlers(contentEl);
                  break;
              case 'shop':
                  contentEl.innerHTML = getShopTabContent();
                  setupShopTabHandlers(contentEl);
                  break;
              case 'values':
                  contentEl.innerHTML = getValuesTabContent();
                  setupValuesTabHandlers(contentEl);
                  break;
              case 'timers':
                  contentEl.innerHTML = getTimersTabContent();
                  break;
              case 'rooms':
                  contentEl.innerHTML = getRoomStatusTabContent();
                  setupRoomJoinButtons();
                  break;
              case 'tools':
                  contentEl.innerHTML = getCachedTabContent('tools', getToolsTabContent);
                  setupToolsTabHandlers(contentEl);
                  break;
              case 'hotkeys':
                  contentEl.innerHTML = getCachedTabContent('hotkeys', getHotkeysTabContent);
                  setupHotkeysTabHandlers(contentEl);
                  break;
              case 'notifications':
                  contentEl.innerHTML = getCachedTabContent('notifications', getNotificationsTabContent);
                  setupNotificationsTabHandlers(contentEl);
                  break;
              case 'settings':
                  productionLog('‚öôÔ∏è [SETTINGS-DEBUG] Settings tab case triggered');
                  productionLog('‚öôÔ∏è [SETTINGS-DEBUG] contentEl exists:', !!contentEl);
                  contentEl.innerHTML = getCachedTabContent('settings', getSettingsTabContent);
                  productionLog('‚öôÔ∏è [SETTINGS-DEBUG] Settings HTML rendered');
                  contentEl.setAttribute('data-tab', 'settings'); // Enable settings-specific scrolling
                  productionLog('‚öôÔ∏è [SETTINGS-DEBUG] About to call setupSettingsTabHandlers with context:', contentEl ? 'contentEl' : 'null');
                  setupSettingsTabHandlers(contentEl);
                  productionLog('‚öôÔ∏è [SETTINGS-DEBUG] setupSettingsTabHandlers completed');
                  break;
              case 'protect':
                  contentEl.innerHTML = getCachedTabContent('protect', getProtectTabContent);
                  setupProtectTabHandlers(contentEl);
                  break;
              case 'help':
                  contentEl.innerHTML = getCachedTabContent('help', getHelpTabContent);
                  break;
          }
      }
  
      // ==================== TAB CONTENTS ====================
      // Simplified pets content for popouts - JUST preset selection
      function getPetsPopoutContent() {
          productionLog('üîç [PETS DEBUG] getPetsPopoutContent() called');
          // Use multiple sources for pet data (same as updateActivePetsDisplay)
          const activePets = UnifiedState.atoms.activePets || window.activePets || [];
          const petPresets = UnifiedState.data.petPresets;
          productionLog('üîç [PETS DEBUG] Data check:', {
              activePetsCount: activePets.length,
              presetsCount: Object.keys(petPresets).length,
              unifiedStateActivePets: UnifiedState.atoms.activePets?.length || 0,
              windowActivePets: window.activePets?.length || 0
          });
  
          if (Object.keys(petPresets).length === 0) {
              return `
                  <div class="mga-section">
                      <div class="mga-section-title mga-pet-section-title">Active Pets</div>
                      <div class="mga-active-pets-display">
                          ${activePets.length > 0 ? `
                              <div style="color: #93c5fd; font-size: 12px; margin-bottom: 4px;">Currently Equipped:</div>
                              <div class="mga-active-pets-list">
                                  ${activePets.map((p, index) => {
                                      const timeUntilHungry = calculateTimeUntilHungry(p);
                                      const timerText = formatHungerTimer(timeUntilHungry);
                                      const timerColor = timeUntilHungry === null ? '#999' :
                                                         timeUntilHungry <= 0 ? '#8B0000' :
                                                         timeUntilHungry < 5 * 60 * 1000 ? '#ff4444' :
                                                         timeUntilHungry < 15 * 60 * 1000 ? '#ffa500' : '#4caf50';
                                      return `
                                          <div class="mga-pet-slot" style="display: flex; flex-direction: column; align-items: center; gap: 4px; margin-bottom: 8px;">
                                              <span class="mga-pet-badge">${p.petSpecies}</span>
                                              <span class="mga-hunger-timer" data-pet-index="${index}" style="font-size: 12px; color: ${timerColor}; font-weight: bold;">${timerText}</span>
                                          </div>
                                      `;
                                  }).join('')}
                              </div>
                          ` : `
                              <div class="mga-empty-state">
                                  <div class="mga-empty-state-icon">‚Äî</div>
                                  <div class="mga-empty-state-description">No pets currently active</div>
                              </div>
                          `}
                      </div>
                  </div>
                  <div class="mga-section">
                      <div class="mga-empty-state" style="padding: 40px 20px;">
                          <div class="mga-empty-state-icon">üìã</div>
                          <div class="mga-empty-state-title">No Saved Presets</div>
                          <div class="mga-empty-state-description">
                              You haven't saved any pet loadout presets yet.<br>
                              Open the main HUD Pets tab to create presets from your current active pets.
                          </div>
                      </div>
                  </div>
              `;
          }
  
          let html = `
              <div class="mga-section">
                  <div class="mga-section-title mga-pet-section-title">Active Pets</div>
                  <div class="mga-active-pets-display">
                      ${activePets.length > 0 ? `
                          <div class="mga-active-pets-header">Currently Equipped:</div>
                          <div class="mga-active-pets-list">
                              ${activePets.map((p, index) => {
                                  const timeUntilHungry = calculateTimeUntilHungry(p);
                                  const timerText = formatHungerTimer(timeUntilHungry);
                                  const timerColor = timeUntilHungry === null ? '#999' :
                                                     timeUntilHungry <= 0 ? '#8B0000' :
                                                     timeUntilHungry < 5 * 60 * 1000 ? '#ff4444' :
                                                     timeUntilHungry < 15 * 60 * 1000 ? '#ffa500' : '#4caf50';
                                  return `
                                      <div class="mga-pet-slot" style="display: flex; flex-direction: column; align-items: center; gap: 4px; margin-bottom: 8px;">
                                          <span class="mga-pet-badge">${p.petSpecies}</span>
                                          <span class="mga-hunger-timer" data-pet-index="${index}" style="font-size: 12px; color: ${timerColor}; font-weight: bold;">${timerText}</span>
                                      </div>
                                  `;
                              }).join('')}
                          </div>
                      ` : `
                          <div class="mga-empty-state">
                              <div class="mga-empty-state-icon">‚Äî</div>
                              <div class="mga-empty-state-description">No pets currently active</div>
                          </div>
                      `}
                  </div>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">Load Pet Preset</div>
          `;
  
          // Create clickable preset cards (consistent with main HUD structure) in order
          ensurePresetOrder();
          UnifiedState.data.petPresetsOrder.forEach(name => {
              if (petPresets[name]) {
                  const pets = petPresets[name];
                  const petList = pets.map(p => p.petSpecies).join(', ');
                  html += `
                      <div class="mga-preset mga-preset-clickable" data-preset="${name}">
                          <div class="mga-preset-header">
                              <span class="mga-preset-name">${name}</span>
                          </div>
                          <div class="mga-preset-pets">${petList}</div>
                      </div>
                  `;
              }
          });
  
          html += `</div>`;
          productionLog('üîç [PETS DEBUG] Returning HTML:', { htmlLength: html.length, htmlPreview: html.substring(0, 200) });
          return html;
      }
  
      // Setup handlers specifically for pet popout preset buttons
      function setupPetPopoutHandlers(context = document) {
          // Find all preset cards
          const cards = context.querySelectorAll('.mga-preset-clickable[data-preset]');
  
          productionLog(`üîß [PETS-HANDLERS] Setting up handlers for ${cards.length} preset cards`);
  
          // Set up preset card handlers - use cloneNode to ensure clean slate
          cards.forEach((presetCard, index) => {
              // Clone the node to remove ALL event listeners
              const newCard = presetCard.cloneNode(true);
              presetCard.parentNode.replaceChild(newCard, presetCard);
  
              // Attach fresh handler to the cloned card
              newCard.addEventListener('click', (e) => {
                  productionLog(`üéØ [PETS-CLICK] Clicked preset #${index}: ${e.currentTarget.dataset.preset}`);
                  const presetName = e.currentTarget.dataset.preset;
  
                  if (!presetName || !UnifiedState.data.petPresets[presetName]) {
                      productionWarn('‚ö†Ô∏è Preset not found!');
                      return;
                  }
  
                  const preset = UnifiedState.data.petPresets[presetName];
  
                  // Store current pets first
                  (UnifiedState.atoms.activePets || []).forEach(p => {
                      safeSendMessage({
                          scopePath: ["Room", "Quinoa"],
                          type: "StorePet",
                          itemId: p.id
                      });
                  });
  
                  // Place preset pets with delay to prevent accidental clicks
                  preset.forEach((p, i) => {
                      setTimeout(() => {
                          safeSendMessage({
                              scopePath: ["Room", "Quinoa"],
                              type: "PlacePet",
                              itemId: p.id,
                              position: { x: 17 + i * 2, y: 13 },
                              localTileIndex: 64,
                              tileType: "Boardwalk"
                          });
                      }, i * 50); // 50ms delay between each pet placement
                  });
  
                  // Update displays after all pets are placed (single refresh with retry)
                  const refreshPetDisplays = () => {
                      productionLog('üîÑ [PETS-REFRESH] Starting refresh...');
                      // Force update from room state
                      updateActivePetsFromRoomState();
  
                      // Get the actual window context, whether we're in main window or popout
                      const contextDoc = context.ownerDocument || context;
                      const contextWindow = contextDoc.defaultView || window;
  
                      // Check if this is a separate window popout
                      const isSeparateWindow = contextWindow !== window && contextWindow.refreshPopoutContent;
  
                      if (isSeparateWindow) {
                          // Refresh separate window popout
                          contextWindow.refreshPopoutContent('pets');
                      } else {
                          // It's an in-game overlay or main window - update all popouts
                          refreshSeparateWindowPopouts('pets');
  
                          // Update all overlays
                          UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                              if (overlay && document.contains(overlay) && tabName === 'pets') {
                                  if (overlay.className.includes('mga-overlay-content-only')) {
                                      updatePureOverlayContent(overlay, tabName);
                                  }
                              }
                          });
  
                          // Update main tab if active
                          if (UnifiedState.activeTab === 'pets') {
                              updateTabContent();
                          }
                      }
                  };
  
                  // Single refresh after 2 seconds (gives game time to update)
                  setTimeout(() => {
                      refreshPetDisplays();
                      productionLog('‚úÖ [PETS-REFRESH] First refresh complete');
  
                      // Retry handler reattachment after a short delay to ensure reliability
                      setTimeout(() => {
                          const overlay = UnifiedState.data.popouts.overlays.get('pets');
                          if (overlay && document.contains(overlay)) {
                              productionLog('üîÑ [PETS-HANDLERS] Reattaching handlers to ensure reliability');
                              setupPetPopoutHandlers(overlay);
                          }
                      }, 500);
                  }, preset.length * 50 + 2000);
  
                  // Visual feedback - gentle highlight, no transform (prevents stutter)
                  // Temporarily disable pointer events to prevent hover conflicts
                  e.currentTarget.style.pointerEvents = 'none';
                  const originalBackground = e.currentTarget.style.background;
                  e.currentTarget.style.background = 'rgba(16, 185, 129, 0.3)';
                  setTimeout(() => {
                      e.currentTarget.style.background = originalBackground;
                      e.currentTarget.style.pointerEvents = '';
                  }, 200);
  
                  productionLog(`‚úÖ [PETS-SWAP] Loaded preset: ${presetName}`);
              });
          });
  
          // Add event delegation for preset action buttons (move-up, move-down, save, place, remove)
          const presetsContainer = context.querySelector('#presets-list');
          if (presetsContainer) {
              // Remove old listener if it exists
              if (presetsContainer._mgaClickHandler) {
                  presetsContainer.removeEventListener('click', presetsContainer._mgaClickHandler);
              }
  
              // Create new handler
              presetsContainer._mgaClickHandler = (e) => {
                  const btn = e.target.closest('[data-action]');
                  if (!btn) return;
  
                  e.preventDefault();
                  e.stopPropagation();
  
                  const action = btn.dataset.action;
                  const presetName = btn.dataset.preset;
  
                  if (action === 'move-up') {
                      movePreset(presetName, 'up', context);
                  } else if (action === 'move-down') {
                      movePreset(presetName, 'down', context);
                  } else if (action === 'save') {
                      UnifiedState.data.petPresets[presetName] = (UnifiedState.atoms.activePets || []).slice(0, 3);
                      MGA_saveJSON('MGA_petPresets', UnifiedState.data.petPresets);
                      refreshPresetsList(context);
                      refreshSeparateWindowPopouts('pets');
                  } else if (action === 'place') {
                      placePetPreset(presetName);
                  } else if (action === 'remove') {
                      delete UnifiedState.data.petPresets[presetName];
                      const saveSuccess = MGA_saveJSON('MGA_petPresets', UnifiedState.data.petPresets);
                      if (!saveSuccess) {
                          console.error('‚ùå Failed to save after removing preset');
                          alert('‚ö†Ô∏è Failed to save changes! The preset removal may not persist.');
                      }
                      refreshPresetsList(context);
                      refreshSeparateWindowPopouts('pets');
                  }
              };
  
              // Add the handler
              presetsContainer.addEventListener('click', presetsContainer._mgaClickHandler);
          }
      }
  
      function getPetsTabContent() {
          // Use multiple sources for pet data (same as updateActivePetsDisplay)
          const activePets = UnifiedState.atoms.activePets || window.activePets || [];
          const petPresets = UnifiedState.data.petPresets;
  
          productionLog('üêæ [PETS-TAB-CONTENT] Generating HTML with pets:', {
              unifiedStateActivePets: UnifiedState.atoms.activePets?.length || 0,
              windowActivePets: window.activePets?.length || 0,
              finalActivePets: activePets.length,
              activePetsData: activePets
          });
  
          let html = `
              <div class="mga-section">
                  <div class="mga-section-title mga-pet-section-title">Active Pets</div>
                  <div class="mga-active-pets-display">
                      ${activePets.length > 0 ? `
                          <div class="mga-active-pets-header">Currently Equipped:</div>
                          <div class="mga-active-pets-list">
                              ${activePets.map((p, index) => {
                                  const timeUntilHungry = calculateTimeUntilHungry(p);
                                  const timerText = formatHungerTimer(timeUntilHungry);
                                  const timerColor = timeUntilHungry === null ? '#999' :
                                                     timeUntilHungry <= 0 ? '#8B0000' :
                                                     timeUntilHungry < 5 * 60 * 1000 ? '#ff4444' :
                                                     timeUntilHungry < 15 * 60 * 1000 ? '#ffa500' : '#4caf50';
                                  return `
                                      <div class="mga-pet-slot" style="display: flex; flex-direction: column; align-items: center; gap: 4px; margin-bottom: 8px;">
                                          <span class="mga-pet-badge">${p.petSpecies}</span>
                                          <span class="mga-hunger-timer" data-pet-index="${index}" style="font-size: 12px; color: ${timerColor}; font-weight: bold;">${timerText}</span>
                                      </div>
                                  `;
                              }).join('')}
                          </div>
                      ` : `
                          <div class="mga-empty-state">
                              <div class="mga-empty-state-icon">‚Äî</div>
                              <div class="mga-empty-state-description">No pets currently active</div>
                          </div>
                      `}
                  </div>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title mga-pet-section-title">Quick Load Preset</div>
                  <select class="mga-select" id="preset-quick-select" style="margin-bottom: 8px;">
                      <option value="">-- Select Preset --</option>
                      ${Object.keys(petPresets).map(name =>
                          `<option value="${name}">${name} (${petPresets[name].map(p => p.petSpecies).join(', ')})</option>`
                      ).join('')}
                  </select>
                  <button class="mga-btn" id="quick-load-btn" style="width: 100%;">Load</button>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title mga-pet-section-title">Create New Preset</div>
                  <div style="display: grid; grid-template-columns: 1fr auto; gap: 8px; margin-bottom: 8px;">
                      <input type="text" class="mga-input" id="preset-name-input" placeholder="Preset name...">
                      <button class="mga-btn" id="add-preset-btn" style="white-space: nowrap; padding: 6px 24px;">Save Current</button>
                  </div>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title mga-pet-section-title">Manage Presets</div>
                  <div id="presets-list" class="mga-scrollable mga-presets-container">
          `;
  
          // Display presets in order
          ensurePresetOrder();
          UnifiedState.data.petPresetsOrder.forEach(name => {
              if (petPresets[name]) {
                  const pets = petPresets[name];
                  const hotkey = UnifiedState.data.petPresetHotkeys[name];
                  html += `
                      <div class="mga-preset">
                          <div class="mga-preset-header">
                              <span class="mga-preset-name">${name}</span>
                              <button class="mga-hotkey-btn" data-preset="${name}" style="margin-left: auto; padding: 2px 8px; font-size: 11px; background: rgba(100, 200, 255, 0.48); border: 1px solid #4a9eff; border-radius: 4px; color: white; cursor: pointer;">
                                  ${hotkey || 'Set Hotkey'}
                              </button>
                          </div>
                          <div class="mga-preset-pets">${pets.map(p => p.petSpecies).join(', ')}</div>
                          <div class="mga-preset-actions">
                              <div style="display: flex; gap: 4px; margin-bottom: 4px;">
                                  <button class="mga-btn mga-btn-sm" data-action="move-up" data-preset="${name}" style="background: #6b7280; padding: 4px 8px;">‚Üë</button>
                                  <button class="mga-btn mga-btn-sm" data-action="move-down" data-preset="${name}" style="background: #6b7280; padding: 4px 8px;">‚Üì</button>
                                  <button class="mga-btn mga-btn-sm" data-action="save" data-preset="${name}">Save Current</button>
                              </div>
                              <div style="display: flex; gap: 4px;">
                                  <button class="mga-btn mga-btn-sm" data-action="place" data-preset="${name}">Place</button>
                                  <button class="mga-btn mga-btn-sm" data-action="remove" data-preset="${name}">Remove</button>
                              </div>
                          </div>
                      </div>
                  `;
              }
          });
  
          html += '</div></div>';
  
          return html;
      }
  
      function getAbilitiesTabContent() {
          const logs = UnifiedState.data.petAbilityLogs.slice(0, 30);
          const filterMode = UnifiedState.data.filterMode || 'categories';
  
          let html = `
              <div class="mga-section">
                  <div class="mga-section-title">Filter Mode</div>
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; gap: 8px;">
                      <div style="display: flex; gap: 6px;">
                          <button class="mga-btn mga-btn-sm ${filterMode === 'categories' ? 'active' : ''}" id="filter-mode-categories" style="padding: 6px 12px; font-size: 12px;">Categories</button>
                          <button class="mga-btn mga-btn-sm ${filterMode === 'byPet' ? 'active' : ''}" id="filter-mode-bypet" style="padding: 6px 12px; font-size: 12px;">By Pet</button>
                          <button class="mga-btn mga-btn-sm ${filterMode === 'custom' ? 'active' : ''}" id="filter-mode-custom" style="padding: 6px 12px; font-size: 12px;">Custom</button>
                      </div>
                      <div style="display: flex; gap: 6px;">
                          <button class="mga-btn mga-btn-sm" id="select-all-filters" style="padding: 6px 10px; font-size: 11px;">All</button>
                          <button class="mga-btn mga-btn-sm" id="select-none-filters" style="padding: 6px 10px; font-size: 11px;">None</button>
                      </div>
                  </div>
                  <div id="filter-mode-description" style="font-size: 11px; color: #aaa; margin-bottom: 12px; padding: 6px 10px; background: rgba(255,255,255,0.03); border-radius: 4px;">
                      ${filterMode === 'categories' ? 'üìÇ Filter by ability categories' :
                        filterMode === 'byPet' ? 'üêæ Filter by pet species' : '‚öôÔ∏è Filter by individual abilities'}
                  </div>
  
                  <!-- Categories Mode -->
                  <div id="category-filters" style="display: ${filterMode === 'categories' ? 'grid' : 'none'}; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
                      <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                          <input type="checkbox" class="mga-checkbox" ${UnifiedState.data.abilityFilters.xpBoost ? 'checked' : ''} data-filter="xpBoost" style="accent-color: #4a9eff;">
                          <span class="mga-label" style="font-size: 12px;">üí´ XP Boost</span>
                      </label>
                      <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                          <input type="checkbox" class="mga-checkbox" ${UnifiedState.data.abilityFilters.cropSizeBoost ? 'checked' : ''} data-filter="cropSizeBoost" style="accent-color: #4a9eff;">
                          <span class="mga-label" style="font-size: 12px;">üìà Crop Size Boost</span>
                      </label>
                      <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                          <input type="checkbox" class="mga-checkbox" ${UnifiedState.data.abilityFilters.selling ? 'checked' : ''} data-filter="selling" style="accent-color: #4a9eff;">
                          <span class="mga-label" style="font-size: 12px;">üí∞ Selling</span>
                      </label>
                      <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                          <input type="checkbox" class="mga-checkbox" ${UnifiedState.data.abilityFilters.harvesting ? 'checked' : ''} data-filter="harvesting" style="accent-color: #4a9eff;">
                          <span class="mga-label" style="font-size: 12px;">üåæ Harvesting</span>
                      </label>
                      <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                          <input type="checkbox" class="mga-checkbox" ${UnifiedState.data.abilityFilters.growthSpeed ? 'checked' : ''} data-filter="growthSpeed" style="accent-color: #4a9eff;">
                          <span class="mga-label" style="font-size: 12px;">üê¢ Growth Speed</span>
                      </label>
                      <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                          <input type="checkbox" class="mga-checkbox" ${UnifiedState.data.abilityFilters.specialMutations ? 'checked' : ''} data-filter="specialMutations" style="accent-color: #4a9eff;">
                          <span class="mga-label" style="font-size: 12px;">üåà‚ú® Special Mutations</span>
                      </label>
                      <label class="mga-checkbox-group" style="display: flex; align-items: center; gap: 8px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 4px; cursor: pointer; transition: background 0.2s;">
                          <input type="checkbox" class="mga-checkbox" ${UnifiedState.data.abilityFilters.other ? 'checked' : ''} data-filter="other" style="accent-color: #4a9eff;">
                          <span class="mga-label" style="font-size: 12px;">üîß Other</span>
                      </label>
                  </div>
  
                  <!-- By Pet Mode -->
                  <div id="pet-filters" style="display: ${filterMode === 'byPet' ? 'block' : 'none'}; margin-bottom: 8px;">
                      <div id="pet-species-list" class="mga-scrollable" style="max-height: 150px; border: 1px solid rgba(255, 255, 255, 0.57); border-radius: 4px; padding: 8px;">
                          <div style="color: #888; text-align: center;">Loading pet species...</div>
                      </div>
                  </div>
  
                  <!-- Custom Mode -->
                  <div id="custom-filters" style="display: ${filterMode === 'custom' ? 'block' : 'none'}; margin-bottom: 8px;">
                      <div id="individual-abilities-list" class="mga-scrollable" style="max-height: 150px; border: 1px solid rgba(255, 255, 255, 0.57); border-radius: 4px; padding: 8px;">
                          <div style="color: #888; text-align: center;">Loading individual abilities...</div>
                      </div>
                  </div>
  
                  <div style="display: flex; gap: 8px; margin-top: 8px; flex-wrap: wrap;">
                      <button class="mga-btn mga-btn-sm" id="clear-logs-btn">Clear Logs</button>
                      <button class="mga-btn mga-btn-sm" id="export-logs-btn">Export CSV</button>
                      ${UnifiedState.data.settings?.debugMode ? '<button class="mga-btn mga-btn-sm" id="diagnose-logs-btn" style="background: #ff6b35;">üîç Diagnose Storage</button>' : ''}
                  </div>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">Recent Ability Triggers</div>
                  <div style="margin-bottom: 8px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="detailed-timestamps-checkbox" class="mga-checkbox"
                                 ${UnifiedState.data.settings.detailedTimestamps ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üïê Show detailed timestamps (HH:MM:SS)</span>
                      </label>
                      <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                          When enabled, shows detailed 24-hour format timestamps instead of 12-hour format.
                      </p>
                  </div>
                  <div id="ability-logs" class="mga-scrollable" style="max-height: 400px; overflow-y: auto;">
                      ${logs.length === 0 ? '<div style="color: #888; text-align: center; padding: 20px;">No ability logs yet. Ability logs will appear here when your pets trigger abilities in-game.</div>' : ''}
                  </div>
              </div>
          `;
  
          return html;
      }
  
      function getSeedsTabContent() {
          debugLog('SEEDS_TAB', 'getSeedsTabContent() called - generating full content');
          productionLog('üîç [SEEDS DEBUG] getSeedsTabContent() called - generating content');
          const seedGroups = [
              { name: "Common", color: "#fff", seeds: ["Carrot", "Strawberry", "Aloe"] },
              { name: "Uncommon", color: "#0f0", seeds: ["Apple", "Tulip", "Tomato", "Blueberry"] },
              { name: "Rare", color: "#0af", seeds: ["Daffodil", "Corn", "Watermelon", "Pumpkin"] },
              { name: "Legendary", color: "#ff0", seeds: ["Echeveria", "Coconut", "Banana", "Lily", "BurrosTail"] },
              { name: "Mythical", color: "#a0f", seeds: ["Mushroom", "Cactus", "Bamboo", "Grape"] },
              { name: "Divine", color: "orange", seeds: ["Sunflower", "Pepper", "Lemon", "PassionFruit", "DragonFruit", "Lychee"] },
              { name: "Celestial", color: "#ff69b4", seeds: ["Starweaver", "Moonbinder", "Dawnbinder"], protected: true }
          ];
  
          let html = `
              <div class="mga-section">
                  <div class="mga-section-title">Quick Actions</div>
                  <div style="display: flex; gap: 8px; margin-bottom: 12px; flex-wrap: wrap;">
                      <button class="mga-btn mga-btn-sm" id="select-all-seeds" style="background: #059669;">Select All</button>
                      <button class="mga-btn mga-btn-sm" id="select-none-seeds" style="background: #dc2626;">Select None</button>
                      <button class="mga-btn mga-btn-sm" id="select-common" style="background: #6b7280;">Common</button>
                      <button class="mga-btn mga-btn-sm" id="select-uncommon" style="background: #059669;">Uncommon</button>
                      <button class="mga-btn mga-btn-sm" id="select-rare" style="background: #0ea5e9;">Rare+</button>
                  </div>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">Seed Management</div>
                  <div style="display: flex; gap: 8px; margin-bottom: 12px; align-items: center; flex-wrap: wrap;">
                      <label class="mga-checkbox-group">
                          <input type="checkbox" class="mga-checkbox" id="auto-delete-checkbox">
                          <span class="mga-label">Auto-Delete</span>
                      </label>
                      <button class="mga-btn" id="delete-selected-btn" style="background: #dc2626;">Delete Selected</button>
                      <button class="mga-btn mga-btn-sm" id="calculate-value-btn" style="background: #f59e0b;">Calculate Value</button>
                  </div>
                  <div id="seed-value-display" style="display: none; margin-top: 8px; padding: 8px; background: rgba(245, 158, 11, 0.30); border-radius: 4px;">
                      <div style="font-size: 13px; color: #f59e0b;">Selected Seeds Value: <span id="selected-seeds-value">0</span> üí∞</div>
                  </div>
              </div>
          `;
  
          // Seed ID mapping for checking saved state (same as setupSeedsTabHandlers)
          const seedIdMap = {
              "Carrot": "Carrot", "Strawberry": "Strawberry", "Aloe": "Aloe",
              "Blueberry": "Blueberry", "Apple": "Apple", "Tulip": "OrangeTulip",
              "Tomato": "Tomato", "Daffodil": "Daffodil", "Sunflower": "Sunflower", "Corn": "Corn",
              "Watermelon": "Watermelon", "Pumpkin": "Pumpkin", "Echeveria": "Echeveria",
              "Coconut": "Coconut", "Banana": "Banana", "Lily": "Lily",
              "BurrosTail": "BurrosTail", "Mushroom": "Mushroom", "Cactus": "Cactus",
              "Bamboo": "Bamboo", "Grape": "Grape", "Pepper": "Pepper",
              "Lemon": "Lemon", "PassionFruit": "PassionFruit", "DragonFruit": "DragonFruit",
              "Lychee": "Lychee", "Starweaver": "Starweaver", "Moonbinder": "Moonbinder", "Dawnbinder": "Dawnbinder"
          };
  
          productionLog('üîç [SEEDS DEBUG] Applying saved state to checkboxes:', {
              savedSeedsToDelete: UnifiedState.data.seedsToDelete,
              savedSeedsCount: UnifiedState.data.seedsToDelete?.length || 0
          });
  
          seedGroups.forEach(group => {
              html += `
                  <div class="mga-section">
                      <div class="mga-section-title" style="color: ${group.color}">${group.name}</div>
                      <div class="mga-grid">
              `;
  
              group.seeds.forEach(seed => {
                  const isGroupProtected = group.protected === true;
                  const isIndividuallyProtected = ['Starweaver', 'Moonbinder', 'Dawnbinder', 'Sunflower'].includes(seed);
                  const isProtected = isGroupProtected || isIndividuallyProtected;
                  const disabledAttr = isProtected ? 'disabled' : '';
                  const protectedStyle = isProtected ? 'opacity: 0.5; cursor: not-allowed;' : '';
                  const protectedLabel = isProtected ? ' üîí' : '';
  
                  // Check if this seed should be checked based on saved state
                  const internalId = seedIdMap[seed] || seed;
                  const isChecked = UnifiedState.data.seedsToDelete?.includes(internalId) || false;
                  const checkedAttr = isChecked ? 'checked' : '';
  
                  productionLog(`üîç [SEEDS DEBUG] Seed ${seed} (${internalId}): checked=${isChecked}`);
  
                  html += `
                      <label class="mga-checkbox-group" style="${protectedStyle}">
                          <input type="checkbox" class="mga-checkbox seed-checkbox" data-seed="${seed}" ${disabledAttr} ${checkedAttr}>
                          <span class="mga-label" style="color: ${group.color}">${seed}${protectedLabel}</span>
                      </label>
                  `;
              });
  
              html += '</div></div>';
          });
  
          debugLog('SEEDS_TAB', 'getSeedsTabContent() returning HTML', { htmlLength: html.length });
          productionLog('üîç [SEEDS DEBUG] Returning HTML:', { htmlLength: html.length, htmlPreview: html.substring(0, 200) });
          return html;
      }
  
      // ==================== DUAL SHOP WINDOWS ====================
      let shopWindowsOpen = false;
      let seedShopWindow = null;
      let eggShopWindow = null;
      let shopOverlay = null;
      let shopRenderFunctions = {
          seed: null,
          egg: null
      };
  
      // Global shop refresh function
      function refreshAllShopWindows() {
          if (shopRenderFunctions.seed) {
              shopRenderFunctions.seed();
          }
          if (shopRenderFunctions.egg) {
              shopRenderFunctions.egg();
          }
      }
  
      // Make it available globally so atom hooks can call it
      targetWindow.refreshAllShopWindows = refreshAllShopWindows;
  
      // Shop sprite image map (Discord CDN URLs)
      const SHOP_IMAGE_MAP = {
          // Seeds
          "Carrot": "https://cdn.discordapp.com/emojis/1423010183574982669.webp",
          "Strawberry": "https://cdn.discordapp.com/emojis/1423010222724874330.webp",
          "Aloe": "https://cdn.discordapp.com/emojis/1423010259655590028.webp",
          "Blueberry": "https://cdn.discordapp.com/emojis/1423010283126784010.webp",
          "Apple": "https://cdn.discordapp.com/emojis/1423010302965846046.webp",
          "OrangeTulip": "https://cdn.discordapp.com/emojis/1423010324952514621.webp",
          "Tomato": "https://cdn.discordapp.com/emojis/1423010355109433478.webp",
          "Daffodil": "https://cdn.discordapp.com/emojis/1423010391356866654.webp",
          "Corn": "https://cdn.discordapp.com/emojis/1423010497648656566.webp",
          "Watermelon": "https://cdn.discordapp.com/emojis/1423010520067346515.webp",
          "Pumpkin": "https://cdn.discordapp.com/emojis/1423010546474549338.webp",
          "Echeveria": "https://cdn.discordapp.com/emojis/1423010587910078614.webp",
          "Coconut": "https://cdn.discordapp.com/emojis/1423010611721273444.webp",
          "Banana": "https://cdn.discordapp.com/emojis/1423010652582187089.webp",
          "Lily": "https://cdn.discordapp.com/emojis/1423010686388404407.webp",
          "BurrosTail": "https://cdn.discordapp.com/emojis/1423010714267942912.webp",
          "Mushroom": "https://cdn.discordapp.com/emojis/1423010734002012160.webp",
          "Cactus": "https://cdn.discordapp.com/emojis/1423010755267133531.webp",
          "Bamboo": "https://cdn.discordapp.com/emojis/1423010797830930552.webp",
          "Grape": "https://cdn.discordapp.com/emojis/1423010779522666616.webp",
          "Pepper": "https://cdn.discordapp.com/emojis/1423010818953580574.webp",
          "Lemon": "https://cdn.discordapp.com/emojis/1423010911144120330.webp",
          "PassionFruit": "https://cdn.discordapp.com/emojis/1423010934863171677.webp",
          "DragonFruit": "https://cdn.discordapp.com/emojis/1423010954991370271.webp",
          "Lychee": "https://cdn.discordapp.com/emojis/1423011007206396076.webp",
          "Sunflower": "https://cdn.discordapp.com/emojis/1423010976499765288.webp",
          "Starweaver": "https://cdn.discordapp.com/emojis/1423011042744729700.webp",
          "DawnCelestial": "https://cdn.discordapp.com/emojis/1423011097883185412.webp",
          "MoonCelestial": "https://cdn.discordapp.com/emojis/1423011077410525308.webp",
          // Eggs
          "CommonEgg": "https://cdn.discordapp.com/emojis/1423011628978540676.webp",
          "UncommonEgg": "https://cdn.discordapp.com/emojis/1423011627602804856.webp",
          "RareEgg": "https://cdn.discordapp.com/emojis/1423011625664905316.webp",
          "LegendaryEgg": "https://cdn.discordapp.com/emojis/1423011623089737739.webp",
          "MythicalEgg": "https://cdn.discordapp.com/emojis/1423011620828745899.webp",
          // Tools (Use Discord emojis for proper display)
          "WateringCan": "https://cdn.discordapp.com/emojis/1426622484957888512.webp",
          "PlanterPot": "https://cdn.discordapp.com/emojis/1426622518948794451.webp",
          "Shovel": "https://cdn.discordapp.com/emojis/1426622542222856282.webp",
          "Watering Can": "https://cdn.discordapp.com/emojis/1426622484957888512.webp",
          "Planter Pot": "https://cdn.discordapp.com/emojis/1426622518948794451.webp",
          "Garden Shovel": "https://cdn.discordapp.com/emojis/1426622542222856282.webp"
      };
  
      // Color groups for item rarity/type
      const SHOP_COLOR_GROUPS = {
          white: ["CommonEgg", "Carrot", "Strawberry", "Aloe"],
          green: ["UncommonEgg", "Apple", "OrangeTulip", "Tomato", "Blueberry"],
          blue: ["RareEgg", "Daffodil", "Corn", "Watermelon", "Pumpkin"],
          yellow: ["LegendaryEgg", "Echeveria", "Coconut", "Banana", "Lily", "BurrosTail"],
          purple: ["MythicalEgg", "Mushroom", "Cactus", "Bamboo", "Grape"],
          orange: ["Pepper", "Lemon", "PassionFruit", "DragonFruit", "Lychee", "Sunflower"]
      };
  
      // Rainbow items (celestial seeds)
      const SHOP_RAINBOW_ITEMS = ["Starweaver", "DawnCelestial", "MoonCelestial"];
  
      // Shop prices (from in-game shop screenshots)
      const SHOP_PRICES = {
          // Seeds - Common tier
          "Carrot": 10,
          "Strawberry": 50,
          "Aloe": 135,
          // Seeds - Uncommon tier
          "Blueberry": 400,
          "Apple": 500,
          "OrangeTulip": 600,
          "Tomato": 800,
          // Seeds - Rare tier
          "Daffodil": 1000,
          "Corn": 1300,
          "Watermelon": 2500,
          "Pumpkin": 3000,
          // Seeds - Legendary tier
          "Echeveria": 4200,
          "Coconut": 6000,
          "Banana": 7500,
          "Lily": 20000,
          "BurrosTail": 93000,
          // Seeds - Mythical tier
          "Mushroom": 150000,
          "Cactus": 250000,
          "Bamboo": 400000,
          "Grape": 850000,
          // Seeds - Divine tier
          "Pepper": 1000000,
          "Lemon": 2000000,
          "PassionFruit": 2750000,
          "DragonFruit": 5000000,
          "Lychee": 25000000,
          "Sunflower": 100000000,
          // Seeds - Celestial tier
          "Starweaver": 1000000000,
          "DawnCelestial": 10000000000,
          "MoonCelestial": 50000000000,
          // Eggs
          "CommonEgg": 100000,
          "UncommonEgg": 1000000,
          "RareEgg": 10000000,
          "LegendaryEgg": 100000000,
          "MythicalEgg": 1000000000,
          // Tools (from game screenshot)
          "WateringCan": 3000,
          "Watering Can": 3000,
          "PlanterPot": 25000,
          "Planter Pot": 25000,
          "GardenShovel": 0,  // OWNED - unlimited uses
          "Garden Shovel": 0
      };
  
      // Format price with k/m/b notation and return color
      function formatShopPrice(price) {
          let formatted, color;
          if (price >= 1000000000) {
              formatted = (price / 1000000000).toFixed(price % 1000000000 === 0 ? 0 : 1) + 'b';
              color = '#4a9eff'; // Blue for billions
          } else if (price >= 1000000) {
              formatted = (price / 1000000).toFixed(price % 1000000 === 0 ? 0 : 1) + 'm';
              color = '#ffd700'; // Gold for millions
          } else if (price >= 1000) {
              formatted = (price / 1000).toFixed(price % 1000 === 0 ? 0 : 1) + 'k';
              color = '#999'; // Grey for thousands
          } else {
              formatted = price.toString();
              color = '#999'; // Grey for under 1000
          }
          return { formatted, color };
      }
  
      // Normalize string for comparison
      function normalizeShopKey(s) {
          return String(s ?? '').toLowerCase().replace(/[^a-z0-9]/g, '');
      }
  
      // Get text color class for an item
      function getShopItemColorClass(itemId) {
          const normalized = normalizeShopKey(itemId);
  
          // Check if rainbow item
          for (const rainbowItem of SHOP_RAINBOW_ITEMS) {
              if (normalized.includes(normalizeShopKey(rainbowItem))) {
                  return 'shop-rainbow-text';
              }
          }
  
          // Check color groups
          for (const color in SHOP_COLOR_GROUPS) {
              const items = SHOP_COLOR_GROUPS[color];
              for (const item of items) {
                  if (normalized === normalizeShopKey(item) || normalized.includes(normalizeShopKey(item))) {
                      return `shop-color-${color}`;
                  }
              }
          }
  
          return '';
      }
  
      // Preload shop images for better performance
      (function preloadShopImages() {
          Object.values(SHOP_IMAGE_MAP).forEach(src => {
              if (!src) return;
              const img = new Image();
              img.src = src;
          });
      })();
  
      // Flash purchase feedback tooltip
      function flashPurchaseFeedback(el, message, duration = 1500) {
          // Clean up any stuck tooltips first
          try {
              const stuckTooltips = targetDocument.querySelectorAll('.mga-flash-tooltip');
              stuckTooltips.forEach(t => {
                  if (t && t.parentNode) t.remove();
              });
          } catch (e) {}
  
          try {
              if (!el || !(el instanceof Element)) {
                  console.warn('flashPurchaseFeedback: invalid element', el);
                  showFloatingMsg(message, duration);
                  return;
              }
  
              const rect = el.getBoundingClientRect();
              const msg = targetDocument.createElement('div');
              msg.className = 'mga-flash-tooltip';
              msg.textContent = message;
              msg.setAttribute('role', 'status');
              msg.style.cssText = 'position:fixed;pointer-events:none;padding:6px 10px;border-radius:8px;font-size:12px;background:rgba(0,0,0,.9);color:#fff;z-index:2147483647;transition:opacity 180ms ease,transform 220ms ease;opacity:0;transform:translateY(-6px);';
  
              if (rect && rect.width > 0 && rect.height > 0) {
                  const left = rect.left + rect.width / 2;
                  let top = rect.top - 10;
  
                  if (top < 6) top = rect.bottom + 8;
                  msg.style.left = `${Math.round(left)}px`;
                  msg.style.top = `${Math.round(top)}px`;
                  msg.style.transform += ' translateX(-50%)';
              } else {
                  const left = window.innerWidth / 2;
                  const top = 20;
                  msg.style.left = `${Math.round(left)}px`;
                  msg.style.top = `${Math.round(top)}px`;
                  msg.style.transform += ' translateX(-50%)';
              }
  
              targetDocument.body.appendChild(msg);
  
              // Trigger animation
              requestAnimationFrame(() => {
                  msg.style.opacity = '1';
                  msg.style.transform = msg.style.transform.replace('translateY(-6px)', 'translateY(0)');
              });
  
              // Ensure removal with multiple fallbacks
              const removeMsg = () => {
                  try {
                      if (msg && msg.parentNode) {
                          msg.style.opacity = '0';
                          msg.style.transform = msg.style.transform.replace('translateY(0)', 'translateY(-6px)');
                          setTimeout(() => {
                              try {
                                  if (msg && msg.parentNode) msg.remove();
                              } catch (e) {}
                          }, 220);
                      }
                  } catch (e) {
                      try {
                          if (msg && msg.parentNode) msg.remove();
                      } catch (_) {}
                  }
              };
  
              setTimeout(removeMsg, duration);
          } catch (err) {
              console.error('flashPurchaseFeedback error:', err);
              try {
                  showFloatingMsg(message, duration);
              } catch (e) {}
          }
      }
  
      function showFloatingMsg(msg, dur = 900) {
          const m = targetDocument.createElement('div');
          m.textContent = msg;
          m.style.cssText = 'position:fixed;left:50%;top:20px;transform:translateX(-50%);background:rgba(0,0,0,.9);color:#fff;padding:6px 10px;border-radius:8px;z-index:2147483647;';
          targetDocument.body.appendChild(m);
          setTimeout(() => m.remove(), dur);
      }
  
      // Create shop overlay
      function createShopOverlay() {
          if (shopOverlay) return shopOverlay;
  
          shopOverlay = targetDocument.createElement('div');
          shopOverlay.id = 'mga-shop-overlay';
          targetDocument.body.appendChild(shopOverlay);
  
          // Click outside to close
          shopOverlay.addEventListener('click', (e) => {
              if (e.target === shopOverlay) {
                  toggleShopWindows();
              }
          });
  
          return shopOverlay;
      }
  
      function createShopSidebar(type, title, side) {
          const sidebar = targetDocument.createElement('div');
          sidebar.className = `mga-shop-sidebar mga-shop-sidebar-${side}`;
          sidebar.id = `mga-shop-${type}`;
  
          sidebar.innerHTML = `
              <div class="mga-shop-sidebar-header">
                  <h3 style="margin: 0; font-size: 16px; font-weight: 600;">üå± ${title}</h3>
                  <div style="display: flex; gap: 8px; align-items: center;">
                      <button class="shop-refresh-btn" style="cursor: pointer; font-size: 16px; color: #4a9eff; background: none; border: none; padding: 4px 8px; transition: color 0.2s ease;" title="Refresh shop">üîÑ</button>
                      <button class="shop-close-btn" style="cursor: pointer; font-weight: 700; font-size: 20px; color: #cfcfcf; background: none; border: none; padding: 0 8px; transition: color 0.2s ease;">√ó</button>
                  </div>
              </div>
              <div style="display: flex; flex-direction: column; gap: 8px; padding: 12px; border-bottom: 1px solid rgba(255, 255, 255, 0.57);">
                  <label style="font-size: 12px; display: flex; align-items: center; gap: 6px; cursor: pointer;">
                      <input type="checkbox" class="show-available-only" style="accent-color: #2afd23;">
                      <span>Show available only</span>
                  </label>
                  <label style="font-size: 12px; display: flex; align-items: center; gap: 6px; cursor: pointer;">
                      <input type="checkbox" class="sort-by-value" style="accent-color: #4a9eff;">
                      <span>Sort by Value</span>
                  </label>
              </div>
              <div class="shop-items-list" style="display: flex; flex-direction: column; gap: 6px; padding: 12px; overflow-y: auto; flex: 1;"></div>
          `;
  
          targetDocument.body.appendChild(sidebar);
  
          // Close button handler
          const closeBtn = sidebar.querySelector('.shop-close-btn');
          closeBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              toggleShopWindows();
          });
          closeBtn.addEventListener('mouseenter', () => {
              closeBtn.style.color = '#ff5555';
          });
          closeBtn.addEventListener('mouseleave', () => {
              closeBtn.style.color = '#cfcfcf';
          });
  
          // Refresh button handler (will be fully wired in setupShopWindowHandlers)
          const refreshBtn = sidebar.querySelector('.shop-refresh-btn');
          refreshBtn.addEventListener('mouseenter', () => {
              refreshBtn.style.color = '#6fbfff';
          });
          refreshBtn.addEventListener('mouseleave', () => {
              refreshBtn.style.color = '#4a9eff';
          });
  
          return sidebar;
      }
  
      function toggleShopWindows() {
          if (shopWindowsOpen) {
              // Close both sidebars
              if (seedShopWindow) {
                  seedShopWindow.classList.remove('open');
              }
              if (eggShopWindow) {
                  eggShopWindow.classList.remove('open');
              }
              shopWindowsOpen = false;
          } else {
              // Open both sidebars
              if (!seedShopWindow) createShopSidebars();
              seedShopWindow.classList.add('open');
              eggShopWindow.classList.add('open');
              shopWindowsOpen = true;
          }
      }
  
      function createShopSidebars() {
          // Create seed shop sidebar (left)
          seedShopWindow = createShopSidebar('seed', 'Seeds', 'left');
          // Create egg & tool shop sidebar (right)
          eggShopWindow = createShopSidebar('egg', 'Eggs & Tools', 'right');

          // Setup handlers
          setupShopWindowHandlers(seedShopWindow, 'seed');
          setupShopWindowHandlers(eggShopWindow, 'egg'); // This now handles both eggs and tools
      }
  
      // Escape key handler to close shop windows
      targetDocument.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && shopWindowsOpen) {
              toggleShopWindows();
          }
      });
  
      function createShopWindow(type, title, leftOffset) {
          const window = targetDocument.createElement('div');
          window.className = 'mga-shop-window';
          window.id = `mga-shop-${type}`;
  
          // Load saved position and size with validation
          const savedPositions = MGA_loadJSON('MGA_shopWindowPositions', {});
          const savedSizes = MGA_loadJSON('MGA_shopWindowSizes', {});
          let savedPos = savedPositions[type] || { left: leftOffset, top: 120 };
          let savedSize = savedSizes[type] || { width: 300, height: 500 };
  
          // Validate saved position is on screen
          if (savedPos.left < 0 || savedPos.left > window.innerWidth - 100) {
              savedPos.left = leftOffset;
          }
          if (savedPos.top < 0 || savedPos.top > window.innerHeight - 100) {
              savedPos.top = 120;
          }
  
          // Validate saved size is reasonable
          if (savedSize.width < 250 || savedSize.width > 800) {
              savedSize.width = 300;
          }
          if (savedSize.height < 300 || savedSize.height > 900) {
              savedSize.height = 500;
          }
  
          window.style.cssText = `
              position: fixed;
              top: ${savedPos.top}px;
              left: ${savedPos.left}px;
              width: ${savedSize.width}px;
              height: ${savedSize.height}px;
              background: rgba(17, 24, 39, 0.98);
              border: 1px solid rgba(255, 255, 255, 0.73);
              border-radius: 8px;
              padding: 12px;
              z-index: 999999;
              overflow-y: auto;
              color: #fff;
              transition: transform 0.3s ease, opacity 0.3s ease;
          `;
  
          window.innerHTML = `
              <div class="shop-window-header" style="padding-bottom: 8px; margin-bottom: 8px; border-bottom: 1px solid rgba(255, 255, 255, 0.57); cursor: grab;">
                  <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; position: relative;">
                      <h3 style="margin: 0; font-size: 14px;">üå± ${title}</h3>
                      <button class="shop-close-btn" style="position: absolute; top: -4px; right: -4px; cursor: pointer; font-weight: 700; font-size: 16px; color: #cfcfcf; background: none; border: none; padding: 0 6px; transition: color 0.2s ease;">√ó</button>
                  </div>
                  <div style="display: flex; flex-direction: column; gap: 6px;">
                      <label style="font-size: 11px; display: flex; align-items: center; gap: 4px; cursor: pointer;">
                          <input type="checkbox" class="show-available-only" style="accent-color: #2afd23;">
                          <span>Show available only</span>
                      </label>
                      <label style="font-size: 11px; display: flex; align-items: center; gap: 4px; cursor: pointer;">
                          <input type="checkbox" class="sort-by-value" style="accent-color: #4a9eff;">
                          <span>Sort by Value</span>
                      </label>
                  </div>
              </div>
              <div class="shop-items-list" style="display: flex; flex-direction: column; gap: 6px;"></div>
          `;
  
          // Append to body (overlay is just a backdrop)
          targetDocument.body.appendChild(window);
  
          // Add close button handler
          const closeBtn = window.querySelector('.shop-close-btn');
          closeBtn.addEventListener('click', (e) => {
              e.stopPropagation();
              window.remove();
              // Update state
              if (type === 'seed') {
                  seedShopWindow = null;
              } else {
                  eggShopWindow = null;
              }
              // If both windows are closed, close overlay and update state
              if (!seedShopWindow && !eggShopWindow) {
                  if (shopOverlay) shopOverlay.classList.remove('active');
                  shopWindowsOpen = false;
              }
          });
          closeBtn.addEventListener('mouseenter', () => {
              closeBtn.style.color = '#ff5555';
          });
          closeBtn.addEventListener('mouseleave', () => {
              closeBtn.style.color = '#cfcfcf';
          });
  
          // Make draggable with type parameter for position saving
          makeShopWindowDraggable(window, window.querySelector('.shop-window-header'), type);
  
          // Make resizable with size saving
          makeElementResizable(window, {
              minWidth: 250,
              minHeight: 300,
              maxWidth: 600,
              maxHeight: 800,
              showHandleOnHover: true
          });
  
          // Save size on resize
          const resizeObserver = new ResizeObserver(() => {
              const sizes = MGA_loadJSON('MGA_shopWindowSizes', {});
              sizes[type] = {
                  width: window.offsetWidth,
                  height: window.offsetHeight
              };
              MGA_saveJSON('MGA_shopWindowSizes', sizes);
          });
          resizeObserver.observe(window);
  
          return window;
      }
  
      function makeShopWindowDraggable(element, handle, windowType) {
          let isDragging = false;
          let startX, startY, startLeft, startTop;
  
          handle.style.cursor = 'grab';
  
          handle.addEventListener('mousedown', (e) => {
              // Don't drag if clicking on interactive elements
              if (e.target.tagName === 'INPUT' || e.target.tagName === 'BUTTON') return;
              // Allow dragging from labels and spans, but not if they contain an input
              if (e.target.tagName === 'LABEL' && e.target.querySelector('input')) return;
              // Don't start drag if clicking resize handle
              if (e.target.classList && e.target.classList.contains('mga-resize-handle')) return;
  
              isDragging = true;
              startX = e.clientX;
              startY = e.clientY;
              startLeft = element.offsetLeft;
              startTop = element.offsetTop;
              handle.style.cursor = 'grabbing';
              element.style.zIndex = '9999999'; // Bring to front while dragging
          });
  
          targetDocument.addEventListener('mousemove', (e) => {
              if (!isDragging) return;
              const dx = e.clientX - startX;
              const dy = e.clientY - startY;
              element.style.left = `${startLeft + dx}px`;
              element.style.top = `${startTop + dy}px`;
          });
  
          targetDocument.addEventListener('mouseup', () => {
              if (isDragging) {
                  isDragging = false;
                  handle.style.cursor = 'grab';
                  element.style.zIndex = '999999'; // Reset z-index
  
                  // Save position
                  const positions = MGA_loadJSON('MGA_shopWindowPositions', {});
                  positions[windowType] = {
                      left: element.offsetLeft,
                      top: element.offsetTop
                  };
                  MGA_saveJSON('MGA_shopWindowPositions', positions);
              }
          });
      }
  
      function setupShopWindowHandlers(window, type) {
          const itemsList = window.querySelector('.shop-items-list');
          const sortCheckbox = window.querySelector('.sort-by-value');
          const showAvailableCheckbox = window.querySelector('.show-available-only');

          const items = type === 'seed' ? SEED_SPECIES_SHOP : EGG_IDS_SHOP;

          function renderItems(sortByValue = false, showAvailableOnly = false) {
              itemsList.innerHTML = '';

              // For egg type, render both eggs and tools with divider
              if (type === 'egg') {
                  // Render eggs section
                  let eggItemsToRender = EGG_IDS_SHOP.map(id => ({
                      id,
                      stock: getItemStock(id, 'egg'),
                      value: getItemValue(id, 'egg'),
                      type: 'egg'
                  }));

                  if (showAvailableOnly) {
                      eggItemsToRender = eggItemsToRender.filter(item => item.stock > 0);
                  }

                  if (sortByValue) {
                      eggItemsToRender.sort((a, b) => b.value - a.value);
                  }

                  eggItemsToRender.forEach(({ id, stock, value }) => {
                      const itemEl = createShopItemElement(id, 'egg', stock, value);
                      itemsList.appendChild(itemEl);
                  });

                  // Get tools from game shop inventory
                  const toolShop = targetWindow?.globalShop?.shops?.tool;
                  const toolInventory = toolShop?.inventory || [];
                  // Only show divider and tools if tools exist
                  if (toolInventory.length > 0) {
                      // Add professional divider
                      const divider = targetDocument.createElement('div');
                      divider.style.cssText = `
                          margin: 12px 0;
                          padding: 8px 0;
                          border-top: 1px solid rgba(255, 255, 255, 0.1);
                          border-bottom: 1px solid rgba(255, 255, 255, 0.05);
                          text-align: center;
                          font-size: 11px;
                          font-weight: 600;
                          color: rgba(255, 255, 255, 0.5);
                          text-transform: uppercase;
                          letter-spacing: 1px;
                      `;
                      divider.textContent = 'üîß Tools';
                      itemsList.appendChild(divider);

                      // Render tools dynamically from inventory
                      let toolItemsToRender = toolInventory.map((tool, idx) => {
                          // Tools use toolId property (confirmed from friendscript)
                          const toolId = tool.toolId || tool.name || `Tool_${idx}`;

                          // Check if player owns Shovel (it's a one-time purchase)
                          let isOwned = false;
                          let isUnlimited = false;
                          if (toolId === 'Shovel' || toolId === 'GardenShovel') {
                              // Check player inventory for Shovel ownership
                              const playerInventory = targetWindow.myData?.inventory?.items || [];
                              isOwned = playerInventory.some(item =>
                                  item.itemType === 'Tool' &&
                                  (item.toolId === 'Shovel' || item.toolId === 'GardenShovel')
                              );
                              if (isOwned) {
                                  isUnlimited = true;
                              }
                          }

                          const toolStock = isOwned ? 0 : getItemStock(toolId, 'tool');
                          return {
                              id: toolId,
                              stock: toolStock,
                              value: getItemValue(toolId, 'tool'),
                              type: 'tool',
                              owned: isOwned,
                              unlimited: isUnlimited
                          };
                      });

                      if (showAvailableOnly) {
                          // Don't filter out owned/unlimited items (like Shovel)
                          toolItemsToRender = toolItemsToRender.filter(item => item.stock > 0 || item.owned || item.unlimited);
                      }

                      if (sortByValue) {
                          toolItemsToRender.sort((a, b) => b.value - a.value);
                      }

                      toolItemsToRender.forEach(({ id, stock, value, owned, unlimited }) => {
                          const itemEl = createShopItemElement(id, 'tool', stock, value, { owned, unlimited });
                          itemsList.appendChild(itemEl);
                      });
                  }

                  // Show empty state if no items after filtering
                  if (eggItemsToRender.length === 0 && toolInventory.length === 0 && showAvailableOnly) {
                      itemsList.innerHTML = '<div style="color: #888; text-align: center; padding: 20px; font-size: 12px;">No items in stock</div>';
                  }
              } else {
                  // Render seeds normally
                  let itemsToRender = items.map(id => ({
                      id,
                      stock: getItemStock(id, type),
                      value: getItemValue(id, type)
                  }));

                  if (showAvailableOnly) {
                      itemsToRender = itemsToRender.filter(item => item.stock > 0);
                  }

                  if (sortByValue) {
                      itemsToRender.sort((a, b) => b.value - a.value);
                  }

                  itemsToRender.forEach(({ id, stock, value }) => {
                      const itemEl = createShopItemElement(id, type, stock, value);
                      itemsList.appendChild(itemEl);
                  });

                  if (itemsToRender.length === 0 && showAvailableOnly) {
                      itemsList.innerHTML = '<div style="color: #888; text-align: center; padding: 20px; font-size: 12px;">No items in stock</div>';
                  }
              }
          }
  
          // Load saved checkbox states
          const savedFilters = MGA_loadJSON('MGA_shopFilters', {});
          const savedShowAvailable = savedFilters.showAvailableOnly ?? false;
          const savedSortByValue = savedFilters.sortByValue ?? false;
  
          sortCheckbox.checked = savedSortByValue;
          showAvailableCheckbox.checked = savedShowAvailable;
  
          sortCheckbox.addEventListener('change', () => {
              const filters = { showAvailableOnly: showAvailableCheckbox.checked, sortByValue: sortCheckbox.checked };
              MGA_saveJSON('MGA_shopFilters', filters);
              renderItems(sortCheckbox.checked, showAvailableCheckbox.checked);
          });
  
          showAvailableCheckbox.addEventListener('change', () => {
              const filters = { showAvailableOnly: showAvailableCheckbox.checked, sortByValue: sortCheckbox.checked };
              MGA_saveJSON('MGA_shopFilters', filters);
              renderItems(sortCheckbox.checked, showAvailableCheckbox.checked);
          });
  
          // Manual refresh button handler
          const refreshBtn = window.querySelector('.shop-refresh-btn');
          if (refreshBtn) {
              refreshBtn.addEventListener('click', () => {
                  // Force re-render with latest game data
                  renderItems(sortCheckbox.checked, showAvailableCheckbox.checked);
              });
          }
  
          renderItems(savedSortByValue, savedShowAvailable);
  
          // Store render function for global refresh
          shopRenderFunctions[type] = () => renderItems(sortCheckbox.checked, showAvailableCheckbox.checked);
  
          // Auto-refresh stock and detect restocks using pattern-based detection
          let lastTimerValue = null;
          let timerWasDecreasing = false;
  
          setInterval(() => {
              // Check if shop has restocked by watching secondsUntilRestock timer pattern
              const shop = targetWindow?.globalShop?.shops;
              if (shop) {
                  const shopData = type === 'seed' ? shop.seed : shop.egg;
                  if (shopData && typeof shopData.secondsUntilRestock !== 'undefined') {
                      const currentTimer = Number(shopData.secondsUntilRestock) || 0;
  
                      // First reading - initialize tracking
                      if (lastTimerValue === null) {
                          lastTimerValue = currentTimer;
                          return;
                      }
  
                      let restockDetected = false;
  
                      // Pattern-based detection: timer naturally decreases, then suddenly increases = restock
                      if (currentTimer < lastTimerValue) {
                          // Timer decreasing normally (countdown in progress)
                          timerWasDecreasing = true;
                      } else if (timerWasDecreasing && currentTimer > lastTimerValue + 2) {
                          // Timer increased after decreasing - this is the restock pattern!
                          // +2 threshold prevents false positives from network jitter
                          restockDetected = true;
                          timerWasDecreasing = false;
  
                          if (UnifiedState.data.settings.debugMode) {
                              console.log(`[SHOP DEBUG] Restock detected for ${type}! Pattern: ${lastTimerValue}s ‚Üí ${currentTimer}s (was decreasing, then increased)`);
                          }
                      }
  
                      lastTimerValue = currentTimer;
  
                      // Refresh UI when restock is detected
                      if (restockDetected) {
                          // Reset local purchase tracking for this shop type
                          resetLocalPurchases(type);
  
                          // Short delay to ensure stock data is stable
                          setTimeout(() => {
                              renderItems(sortCheckbox.checked, showAvailableCheckbox.checked);
                          }, 500);
                          return; // Skip the immediate render below
                      }
                  }
              }
  
              // Normal periodic refresh (no restock detected)
              // In-game purchases are now detected via sendMessage interception
              // ONLY refresh if no buttons are being hovered (prevents flickering)
              const isHovering = itemsList.querySelector('.buy-btn:hover');
              if (!isHovering) {
                  renderItems(sortCheckbox.checked, showAvailableCheckbox.checked);
              }
          }, 2000); // Check every 2 seconds for better responsiveness
      }
  
      function createShopItemElement(id, type, stock, value, options = {}) {
          const { owned = false, unlimited = false } = options;

          const div = targetDocument.createElement('div');
          div.className = 'shop-item';
          // Only add 'in-stock' class if actually in stock (not owned)
          if (stock > 0 && !owned) div.classList.add('in-stock');
  
          div.style.cssText = `
              padding: 8px;
              background: ${(stock > 0 && !owned) ? 'rgba(76, 255, 106, 0.40)' : 'rgba(255,255,255,0.03)'};
              border: 1px solid ${(stock > 0 && !owned) ? 'rgba(9, 255, 0, 0.48)' : 'rgba(255, 255, 255, 0.57)'};
              border-radius: 4px;
              display: flex;
              align-items: center;
              justify-content: space-between;
              gap: 8px;
              transition: all 0.2s ease;
          `;
  
          const displayName = SHOP_DISPLAY_NAMES[id] || id.replace(/([A-Z])/g, ' $1').trim();
          const spriteUrl = SHOP_IMAGE_MAP[id] || '';
          const colorClass = getShopItemColorClass(id);
          const price = SHOP_PRICES[id] || 0;
          const priceData = formatShopPrice(price);

          // Determine stock display text
          let stockDisplay;
          if (owned || unlimited) {
              // For owned items (like Shovel), just show "OWNED" in neutral color
              stockDisplay = '<span style="color: #888; font-weight: 600;">OWNED</span>';
          } else {
              stockDisplay = `Stock: ${stock} | <span style="color: ${priceData.color};">üí∞${priceData.formatted}</span>`;
          }

          div.innerHTML = `
              <div style="flex: 1; min-width: 0; display: flex; align-items: center; gap: 8px;">
                  ${spriteUrl ? `<img src="${spriteUrl}" alt="${displayName}" class="shop-sprite" loading="lazy">` : ''}
                  <div style="flex: 1; min-width: 0;">
                      <div style="font-size: 12px; font-weight: 600; margin-bottom: 2px;" class="${colorClass}">${displayName}</div>
                      <div class="stock-display" style="font-size: 10px; color: #888;">${stockDisplay}</div>
                  </div>
              </div>
              <div style="display: ${(owned || unlimited) ? 'none' : 'flex'}; gap: 4px;">
                  <button class="buy-btn" data-amount="1" ${stock === 0 ? 'disabled' : ''}
                          style="padding: 4px 8px; font-size: 11px; background: rgba(74, 158, 255, 0.3); border: 1px solid rgba(74, 158, 255, 0.5); border-radius: 3px; color: #fff; cursor: ${stock > 0 ? 'pointer' : 'not-allowed'}; transition: all 0.15s ease;">1</button>
                  <button class="buy-btn" data-amount="all" ${stock === 0 ? 'disabled' : ''}
                          style="padding: 4px 8px; font-size: 11px; background: rgba(76, 175, 80, 0.3); border: 1px solid rgba(76, 175, 80, 0.5); border-radius: 3px; color: #fff; cursor: ${stock > 0 ? 'pointer' : 'not-allowed'}; transition: all 0.15s ease;">All</button>
              </div>
          `;
  
          div.querySelectorAll('.buy-btn').forEach(btn => {
              btn.addEventListener('click', () => {
                  const amount = btn.dataset.amount === 'all' ? stock : 1;
                  buyItem(id, type, amount, div);
              });
  
              // Add hover effects (NO TRANSFORM - prevents flickering)
              if (stock > 0) {
                  btn.addEventListener('mouseenter', () => {
                      btn.style.background = 'rgba(9, 255, 0, 0.5)';
                      btn.style.borderColor = 'rgba(9, 255, 0, 0.8)';
                      btn.style.boxShadow = '0 0 8px rgba(9, 255, 0, 0.4)';
                  });
                  btn.addEventListener('mouseleave', () => {
                      const isAllButton = btn.dataset.amount === 'all';
                      btn.style.background = isAllButton ? 'rgba(76, 175, 80, 0.3)' : 'rgba(74, 158, 255, 0.3)';
                      btn.style.borderColor = isAllButton ? 'rgba(76, 175, 80, 0.5)' : 'rgba(74, 158, 255, 0.5)';
                      btn.style.boxShadow = '';
                  });
              }
          });
  
          return div;
      }
  
      function buyItem(id, type, amount, itemEl) {
          const conn = targetWindow.MagicCircle_RoomConnection;
          if (!conn?.sendMessage) {
              alert('Connection not available');
              return;
          }

          try {
              for (let i = 0; i < amount; i++) {
                  let messageType, itemKey;

                  if (type === 'seed') {
                      messageType = "PurchaseSeed";
                      itemKey = 'species';
                  } else if (type === 'egg') {
                      messageType = "PurchaseEgg";
                      itemKey = 'eggId';
                  } else if (type === 'tool') {
                      messageType = "PurchaseTool";
                      itemKey = 'toolId';
                  }

                  conn.sendMessage({
                      scopePath: ["Room", "Quinoa"],
                      type: messageType,
                      [itemKey]: id
                  });
              }
  
              // Purchase tracking happens automatically in sendMessage intercept
              const displayName = id.replace(/([A-Z])/g, ' $1').trim();
              flashPurchaseFeedback(itemEl, `Purchased x${amount} ${displayName}`);
              productionLog(`‚úÖ Purchased ${amount}x ${id}`);
  
              // Update stock display - game automatically updates window.bought.shopPurchases
              setTimeout(() => {
                  const newStock = getItemStock(id, type);
                  const stockSpan = itemEl.querySelector('.stock-display');
                  if (stockSpan) {
                      const priceData = formatShopPrice(SHOP_PRICES[id] || 0);
                      stockSpan.innerHTML = `Stock: ${newStock} | <span style="color: ${priceData.color};">üí∞${priceData.formatted}</span>`;
                  }
  
                  if (UnifiedState.data.settings.debugMode) {
                      console.log(`[SHOP DEBUG] Stock updated for ${id}: ${newStock} (using game's purchase data)`);
                  }
  
                  // Update in-stock styling
                  if (newStock === 0) {
                      itemEl.classList.remove('in-stock');
                      itemEl.style.background = 'rgba(255,255,255,0.03)';
                      itemEl.style.borderColor = 'rgba(255, 255, 255, 0.57)';
                      // Disable buttons
                      itemEl.querySelectorAll('.buy-btn').forEach(btn => {
                          btn.disabled = true;
                          btn.style.cursor = 'not-allowed';
                      });
                  } else {
                      itemEl.classList.add('in-stock');
                      itemEl.style.background = 'rgba(76, 255, 106, 0.40)';
                      itemEl.style.borderColor = 'rgba(9, 255, 0, 0.48)';
                  }
              }, 100);
          } catch (e) {
              console.error('Purchase error:', e);
              alert('Purchase failed');
          }
      }
  
      function getItemStock(id, type) {
          try {
              const shop = targetWindow?.globalShop?.shops;
              if (!shop) return 0;

              let inventory, item;

              if (type === 'seed') {
                  inventory = shop.seed?.inventory;
                  if (!inventory) return 0;
                  item = inventory.find(i => i.species === id);
              } else if (type === 'egg') {
                  inventory = shop.egg?.inventory;
                  if (!inventory) return 0;
                  item = inventory.find(i => i.eggId === id);
              } else if (type === 'tool') {
                  inventory = shop.tool?.inventory;
                  if (!inventory) return 0;
                  // Tools use toolId property (confirmed from friendscript)
                  // Also check with/without spaces for compatibility
                  const idNoSpaces = id.replace(/\s+/g, '');
                  item = inventory.find(i =>
                      i.toolId === id ||
                      i.name === id ||
                      i.toolId?.replace(/\s+/g, '') === idNoSpaces ||
                      i.name?.replace(/\s+/g, '') === idNoSpaces
                  );
              } else {
                  return 0;
              }

              if (!item) return 0;

              // initialStock is a snapshot that only updates on restock
              // We must subtract local purchases to get current stock
              const initial = item.initialStock || item.stock || 0;
              const purchased = getLocalPurchaseCount(id, type);

              const stock = Math.max(0, initial - purchased);
              return stock;
          } catch (e) {
              productionError('[SHOP] getItemStock error:', e);
              return 0;
          }
      }
  
      function getItemValue(id, type) {
          // Placeholder - you can integrate with your value system
          const valueMap = {
              // Seeds (approximate values)
              'MoonCelestial': 50000, 'DawnCelestial': 45000, 'Starweaver': 40000,
              'Lychee': 8000, 'DragonFruit': 7000, 'PassionFruit': 6000,
              'Sunflower': 5000, 'Lemon': 4000, 'Pepper': 3500,
              'Grape': 3000, 'Bamboo': 2500, 'Cactus': 2000,
              'Mushroom': 1800, 'BurrosTail': 1500, 'Lily': 1200,
              'Banana': 1000, 'Coconut': 900, 'Echeveria': 800,
              'Pumpkin': 600, 'Watermelon': 500, 'Corn': 400,
              'Daffodil': 300, 'Tomato': 250, 'OrangeTulip': 200,
              'Apple': 150, 'Blueberry': 100, 'Aloe': 80,
              'Strawberry': 60, 'Carrot': 40,
              // Eggs
              'MythicalEgg': 10000, 'LegendaryEgg': 5000, 'RareEgg': 1000,
              'UncommonEgg': 200, 'CommonEgg': 50,
              // Tools (placeholder values - these will be replaced with actual game values)
              'Shovel': 500, 'WateringCan': 300, 'Fertilizer': 200
          };
          return valueMap[id] || 100;
      }
  
      function formatValue(value) {
          if (value >= 1000) return `${(value / 1000).toFixed(1)}k`;
          return value.toString();
      }
  
      const SEED_SPECIES_SHOP = ['Carrot', 'Strawberry', 'Aloe', 'Blueberry', 'Apple', 'OrangeTulip', 'Tomato', 'Daffodil',
                                  'Corn', 'Watermelon', 'Pumpkin', 'Echeveria', 'Coconut', 'Banana', 'Lily', 'BurrosTail',
                                  'Mushroom', 'Cactus', 'Bamboo', 'Grape', 'Pepper', 'Lemon', 'PassionFruit', 'DragonFruit',
                                  'Lychee', 'Sunflower', 'Starweaver', 'DawnCelestial', 'MoonCelestial'];
  
      const EGG_IDS_SHOP = ['CommonEgg', 'UncommonEgg', 'RareEgg', 'LegendaryEgg', 'MythicalEgg'];
  
      // Local purchase tracking for immediate UI updates (persisted across page refreshes)
      let localPurchaseTracker = {
          seed: {},
          egg: {},
          tool: {}
      };

      // Load persisted purchase tracker from storage
      function loadPurchaseTracker() {
          try {
              const saved = MGA_loadJSON('MGA_purchaseTracker');
              if (saved && typeof saved === 'object') {
                  localPurchaseTracker = {
                      seed: saved.seed || {},
                      egg: saved.egg || {},
                      tool: saved.tool || {}
                  };
                  console.log('üì¶ [LOCAL-TRACK] Loaded purchase tracker:', {
                      seeds: Object.keys(localPurchaseTracker.seed).length,
                      eggs: Object.keys(localPurchaseTracker.egg).length,
                      tools: Object.keys(localPurchaseTracker.tool).length,
                      toolData: localPurchaseTracker.tool
                  });
              }
          } catch (e) {
              console.error('[LOCAL-TRACK] Error loading purchase tracker:', e);
          }
      }
  
      // Save purchase tracker to storage
      function savePurchaseTracker() {
          try {
              MGA_saveJSON('MGA_purchaseTracker', localPurchaseTracker);
          } catch (e) {
              console.error('[LOCAL-TRACK] Error saving purchase tracker:', e);
          }
      }
  
      // Load on script start
      loadPurchaseTracker();
  
      // Debug flag to only search for purchase atoms once
      let purchaseAtomsSearched = false;
  
      // Function to track a local purchase
      function trackLocalPurchase(id, type, amount = 1) {
          if (!localPurchaseTracker[type][id]) {
              localPurchaseTracker[type][id] = 0;
          }
          localPurchaseTracker[type][id] += amount;

          productionLog(`üìù [LOCAL-TRACK] Recorded ${amount}x ${id} (${type}). Total local: ${localPurchaseTracker[type][id]}`);

          // Persist to storage
          savePurchaseTracker();
      }
  
      // Function to get local purchase count
      function getLocalPurchaseCount(id, type) {
          // Check exact match first
          if (localPurchaseTracker[type][id]) {
              return localPurchaseTracker[type][id];
          }

          // For tools, also check with/without spaces for compatibility
          if (type === 'tool') {
              const idNoSpaces = id.replace(/\s+/g, '');
              for (const key in localPurchaseTracker[type]) {
                  const keyNoSpaces = key.replace(/\s+/g, '');
                  if (keyNoSpaces === idNoSpaces) {
                      return localPurchaseTracker[type][key];
                  }
              }
          }

          return 0;
      }
  
      // Function to reset local purchases when shop restocks
      function resetLocalPurchases(type = null) {
          if (type) {
              localPurchaseTracker[type] = {};
              productionLog(`üîÑ [LOCAL-TRACK] Reset ${type} purchases for restock`);
          } else {
              localPurchaseTracker.seed = {};
              localPurchaseTracker.egg = {};
              localPurchaseTracker.tool = {};
              productionLog(`üîÑ [LOCAL-TRACK] Reset all purchases for restock`);
          }

          // Persist to storage
          savePurchaseTracker();
      }
  
      // Display name overrides for shop (keeps internal names intact)
      const SHOP_DISPLAY_NAMES = {
          'OrangeTulip': 'Tulip',
          // Tools
          'WateringCan': 'Watering Can',
          'PlanterPot': 'Planter Pot',
          'GardenShovel': 'Garden Shovel'
      };
  
      // ==================== SHOP TAB (DEPRECATED - USING DUAL WINDOWS NOW) ====================
      function getShopTabContent() {
          const settings = UnifiedState.data.settings;
  
          return `
              <div class="mga-section">
                  <div class="mga-section-title">üõí Shop</div>
                  <p style="font-size: 12px; color: #aaa; margin-bottom: 16px;">
                      Quick buy seeds and eggs. Stock updates automatically when shop resets.
                  </p>
  
                  <div style="margin-bottom: 20px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                          <input type="checkbox" id="shop-in-stock-only" class="mga-checkbox">
                          <span>Show only items in stock</span>
                      </label>
                  </div>
  
                  <div id="shop-seed-section" style="margin-bottom: 24px;">
                      <h3 style="font-size: 14px; margin-bottom: 12px; color: #fff;">üå± Seeds</h3>
                      <div id="shop-seed-list" style="display: grid; gap: 6px;"></div>
                  </div>
  
                  <div id="shop-egg-section">
                      <h3 style="font-size: 14px; margin-bottom: 12px; color: #fff;">ü•ö Eggs</h3>
                      <div id="shop-egg-list" style="display: grid; gap: 6px;"></div>
                  </div>
              </div>
          `;
      }
  
      function setupShopTabHandlers(context) {
          if (!context) context = targetDocument;
  
          const inStockCheckbox = context.querySelector('#shop-in-stock-only');
          const seedList = context.querySelector('#shop-seed-list');
          const eggList = context.querySelector('#shop-egg-list');
  
          if (!seedList || !eggList) return;
  
          // Seed/Egg item definition
          const SEED_SPECIES = ['Carrot', 'Strawberry', 'Aloe', 'Blueberry', 'Apple', 'OrangeTulip', 'Tomato', 'Daffodil',
                                'Corn', 'Watermelon', 'Pumpkin', 'Echeveria', 'Coconut', 'Banana', 'Lily', 'BurrosTail',
                                'Mushroom', 'Cactus', 'Bamboo', 'Grape', 'Pepper', 'Lemon', 'PassionFruit', 'DragonFruit',
                                'Lychee', 'Sunflower', 'Starweaver', 'DawnCelestial', 'MoonCelestial'];
  
          const EGG_IDS = ['CommonEgg', 'UncommonEgg', 'RareEgg', 'LegendaryEgg', 'MythicalEgg'];
  
          // Create shop items
          function createShopItem(id, type) {
              const item = targetDocument.createElement('div');
              item.className = 'shop-item';
              item.dataset.itemId = id;
              item.dataset.itemType = type;
              item.style.cssText = `
                  padding: 10px;
                  background: rgba(255,255,255,0.03);
                  border: 1px solid rgba(255, 255, 255, 0.57);
                  border-radius: 6px;
                  display: flex;
                  align-items: center;
                  justify-content: space-between;
                  gap: 10px;
                  transition: all 0.2s ease;
              `;
  
              const displayName = SHOP_DISPLAY_NAMES[id] || id.replace(/([A-Z])/g, ' $1').trim();
              const stock = getItemStock(id, type);
  
              item.innerHTML = `
                  <div style="flex: 1; min-width: 0;">
                      <div style="font-weight: 600; font-size: 13px; color: #fff; margin-bottom: 2px;">${displayName}</div>
                      <div class="stock-display" style="font-size: 11px; color: #888;">Stock: ${stock}</div>
                  </div>
                  <div style="display: flex; gap: 6px;">
                      <button class="mga-btn mga-btn-secondary buy-one" ${stock === 0 ? 'disabled' : ''}
                              style="padding: 6px 12px; font-size: 12px;">Buy 1</button>
                      <button class="mga-btn mga-btn-secondary buy-all" ${stock === 0 ? 'disabled' : ''}
                              style="padding: 6px 12px; font-size: 12px;">Buy All</button>
                  </div>
              `;
  
              if (stock > 0) {
                  item.style.background = 'rgba(76, 255, 106, 0.40)';
                  item.style.borderColor = 'rgba(9, 255, 0, 0.48)';
              }
  
              // Event handlers
              item.querySelector('.buy-one').addEventListener('click', () => buyItem(id, type, 1, item));
              item.querySelector('.buy-all').addEventListener('click', () => buyItem(id, type, stock, item));
  
              return item;
          }
  
          function getItemStock(id, type) {
              try {
                  const shop = targetWindow?.globalShop?.shops;
                  if (!shop) return 0;
  
                  const inventory = type === 'seed' ? shop.seed?.inventory : shop.egg?.inventory;
                  if (!inventory) return 0;
  
                  const item = inventory.find(i => {
                      const itemId = type === 'seed' ? i.species : i.eggId;
                      return itemId === id;
                  });
  
                  if (!item) return 0;
  
                  // initialStock is a snapshot that only updates on restock
                  // We must subtract local purchases to get current stock
                  const initial = item.initialStock || 0;
                  const purchased = getLocalPurchaseCount(id, type);
                  const stock = Math.max(0, initial - purchased);
  
                  return stock;
              } catch (e) {
                  productionError('[SHOP-TAB] getItemStock error:', e);
                  return 0;
              }
          }
  
          function buyItem(id, type, amount, itemEl) {
              const conn = targetWindow.MagicCircle_RoomConnection;
              if (!conn?.sendMessage) {
                  alert('Connection not available');
                  return;
              }
  
              try {
                  for (let i = 0; i < amount; i++) {
                      let messageType, itemKey;

                      if (type === 'seed') {
                          messageType = "PurchaseSeed";
                          itemKey = 'species';
                      } else if (type === 'egg') {
                          messageType = "PurchaseEgg";
                          itemKey = 'eggId';
                      } else if (type === 'tool') {
                          messageType = "PurchaseTool";
                          itemKey = 'toolId';
                      }

                      conn.sendMessage({
                          scopePath: ["Room", "Quinoa"],
                          type: messageType,
                          [itemKey]: id
                      });
                  }
  
                  // Purchase tracking happens automatically in sendMessage intercept
  
                  // Update UI
                  setTimeout(() => {
                      const newStock = getItemStock(id, type);
                      const stockDisplay = itemEl.querySelector('.stock-display');
                      if (stockDisplay) stockDisplay.textContent = `Stock: ${newStock}`;
  
                      const buttons = itemEl.querySelectorAll('button');
                      buttons.forEach(btn => btn.disabled = newStock === 0);
  
                      if (newStock === 0) {
                          itemEl.style.background = 'rgba(255,255,255,0.03)';
                          itemEl.style.borderColor = 'rgba(255, 255, 255, 0.57)';
                      }
  
                      applyStockFilter();
                  }, 100);
  
                  productionLog(`‚úÖ Purchased ${amount}x ${id}`);
              } catch (e) {
                  console.error('Purchase error:', e);
                  alert('Purchase failed');
              }
          }
  
          function applyStockFilter() {
              if (!inStockCheckbox) return;
              const showOnlyInStock = inStockCheckbox.checked;
  
              context.querySelectorAll('.shop-item').forEach(item => {
                  const id = item.dataset.itemId;
                  const type = item.dataset.itemType;
                  const stock = getItemStock(id, type);
                  item.style.display = (showOnlyInStock && stock === 0) ? 'none' : 'flex';
              });
          }
  
          // Initialize shop
          SEED_SPECIES.forEach(species => {
              seedList.appendChild(createShopItem(species, 'seed'));
          });
  
          EGG_IDS.forEach(eggId => {
              eggList.appendChild(createShopItem(eggId, 'egg'));
          });
  
          if (inStockCheckbox) {
              inStockCheckbox.addEventListener('change', applyStockFilter);
          }
  
          // Auto-refresh on shop update
          const refreshInterval = setInterval(() => {
              if (!context.querySelector('#shop-seed-list')) {
                  clearInterval(refreshInterval);
                  return;
              }
  
              context.querySelectorAll('.shop-item').forEach(item => {
                  const id = item.dataset.itemId;
                  const type = item.dataset.itemType;
                  const newStock = getItemStock(id, type);
                  const stockDisplay = item.querySelector('.stock-display');
                  if (stockDisplay) stockDisplay.textContent = `Stock: ${newStock}`;
  
                  const buttons = item.querySelectorAll('button');
                  buttons.forEach(btn => btn.disabled = newStock === 0);
  
                  if (newStock > 0) {
                      item.style.background = 'rgba(76, 255, 106, 0.40)';
                      item.style.borderColor = 'rgba(9, 255, 0, 0.48)';
                  } else {
                      item.style.background = 'rgba(255,255,255,0.03)';
                      item.style.borderColor = 'rgba(255, 255, 255, 0.57)';
                  }
              });
  
              applyStockFilter();
          }, 2000);
      }
  
      function getValuesTabContent() {
          const valueManager = globalValueManager || initializeValueManager();
          const tileValue = valueManager.getTileValue();
          const gardenValue = valueManager.getGardenValue();
          const inventoryValue = valueManager.getInventoryValue();
  
          return `
              <div class="mga-section">
                  <div class="mga-section-title">üí∞ Garden Values</div>
                  <div class="mga-value-compact" style="
                      display: grid;
                      grid-template-columns: 1fr auto;
                      column-gap: 12px;
                      row-gap: 4px;
                      font-size: 13px;
                      line-height: 1.5;
                  ">
                      <div class="overlay-label" style="text-align: left; color: #e5e7eb; white-space: nowrap;">Tile value:</div>
                      <div class="overlay-val" style="text-align: right; color: #4a9eff; font-weight: bold; min-width: 90px; word-break: keep-all;">${tileValue.toLocaleString()}</div>
  
                      <div class="overlay-label" style="text-align: left; color: #e5e7eb; white-space: nowrap;">Inventory value:</div>
                      <div class="overlay-val" style="text-align: right; color: #f59e0b; font-weight: bold; min-width: 90px; word-break: keep-all;">${inventoryValue.toLocaleString()}</div>
  
                      <div class="overlay-label" style="text-align: left; color: #e5e7eb; white-space: nowrap;">Garden value:</div>
                      <div class="overlay-val" style="text-align: right; color: #10b981; font-weight: bold; min-width: 90px; word-break: keep-all;">${gardenValue.toLocaleString()}</div>
                  </div>
              </div>

              <div class="mga-section" style="margin-top: 16px;">
                  <div class="mga-section-title" style="display: flex; align-items: center; justify-content: space-between;">
                      <span>üåü Auto-Favorite</span>
                      <label class="switch" style="margin-left: auto;">
                          <input type="checkbox" id="auto-favorite-enabled" ${UnifiedState.data.settings.autoFavorite.enabled ? 'checked' : ''}>
                          <span class="slider"></span>
                      </label>
                  </div>
                  <div style="margin-top: 8px;">
                      <div style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                          Automatically favorite these species when added to inventory:
                      </div>
                      <div id="auto-favorite-species" style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 16px; max-height: 300px; overflow-y: auto; padding-right: 8px;">
                          ${['Carrot', 'Strawberry', 'Aloe', 'Blueberry', 'Apple', 'OrangeTulip', 'Tomato', 'Daffodil', 'Corn', 'Watermelon', 'Pumpkin', 'Echeveria', 'Coconut', 'Banana', 'Lily', 'BurrosTail', 'Mushroom', 'Cactus', 'Bamboo', 'Grape', 'Pepper', 'Lemon', 'PassionFruit', 'DragonFruit', 'Lychee', 'Sunflower', 'Starweaver', 'DawnCelestial', 'MoonCelestial']
                              .map(species => `
                                  <label style="display: flex; align-items: center; gap: 6px; font-size: 11px; cursor: pointer; user-select: none;">
                                      <input type="checkbox" value="${species}"
                                          ${UnifiedState.data.settings.autoFavorite.species.includes(species) ? 'checked' : ''}
                                          style="cursor: pointer;">
                                      <span style="color: #e5e7eb;">${species.replace('OrangeTulip', 'Tulip').replace('DawnCelestial', 'Dawnbinder').replace('MoonCelestial', 'Moonbinder')}</span>
                                  </label>
                              `).join('')}
                      </div>
                      <div style="font-size: 11px; color: #aaa; margin-bottom: 12px; border-top: 1px solid rgba(255, 255, 255, 0.57); padding-top: 12px;">
                          Automatically favorite items with these mutations:
                      </div>
                      <div id="auto-favorite-mutations" style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                          ${['Rainbow', 'Gold', 'Frozen', 'Wet', 'Chilled']
                              .map(mutation => `
                                  <label style="display: flex; align-items: center; gap: 6px; font-size: 12px; cursor: pointer; user-select: none;">
                                      <input type="checkbox" value="${mutation}"
                                          ${UnifiedState.data.settings.autoFavorite.mutations.includes(mutation) ? 'checked' : ''}
                                          style="cursor: pointer;">
                                      <span style="color: #e5e7eb;">${mutation}</span>
                                  </label>
                              `).join('')}
                      </div>
                  </div>
              </div>
          `;
      }
  
      function setupValuesTabHandlers(context = document) {
          // Helper function to save auto-favorite settings with dual-backend persistence
          const saveAutoFavoriteSettings = () => {
              // Save entire UnifiedState
              MGA_saveJSON('MGA_data', UnifiedState.data);

              // Also save auto-favorite settings separately for redundancy
              try {
                  const autoFavData = JSON.stringify(UnifiedState.data.settings.autoFavorite);
                  localStorage.setItem('mgtools_auto_favorites', autoFavData);
                  logDebug('AUTO-FAV', 'Saved auto-favorites to localStorage backup');
              } catch (e) {
                  logWarn('AUTO-FAV', 'Failed to save localStorage backup', e);
              }
          };

          // Auto-favorite toggle
          const autoFavoriteToggle = context.querySelector('#auto-favorite-enabled');
          if (autoFavoriteToggle) {
              autoFavoriteToggle.addEventListener('change', (e) => {
                  UnifiedState.data.settings.autoFavorite.enabled = e.target.checked;
                  saveAutoFavoriteSettings();
                  productionLog(`üåü Auto-favorite ${e.target.checked ? 'enabled' : 'disabled'}`);
              });
          }

          // Species checkboxes
          const speciesCheckboxes = context.querySelectorAll('#auto-favorite-species input[type="checkbox"]');
          speciesCheckboxes.forEach(checkbox => {
              checkbox.addEventListener('change', (e) => {
                  const species = e.target.value;
                  if (e.target.checked) {
                      if (!UnifiedState.data.settings.autoFavorite.species.includes(species)) {
                          UnifiedState.data.settings.autoFavorite.species.push(species);
                      }
                      // Immediately favorite all existing items of this species
                      if (targetWindow.favoriteSpecies) {
                          productionLog(`üåü [AUTO-FAVORITE] User checked ${species} - calling favoriteSpecies`);
                          targetWindow.favoriteSpecies(species);
                      } else {
                          productionLog('‚ùå [AUTO-FAVORITE] favoriteSpecies function not available!');
                      }
                  } else {
                      UnifiedState.data.settings.autoFavorite.species = UnifiedState.data.settings.autoFavorite.species.filter(s => s !== species);
                      // Immediately unfavorite all existing items of this species
                      if (targetWindow.unfavoriteSpecies) {
                          productionLog(`üåü [AUTO-FAVORITE] User unchecked ${species} - calling unfavoriteSpecies`);
                          targetWindow.unfavoriteSpecies(species);
                      } else {
                          productionLog('‚ùå [AUTO-FAVORITE] unfavoriteSpecies function not available!');
                      }
                  }
                  saveAutoFavoriteSettings();
              });
          });

          // Mutation checkboxes
          const mutationCheckboxes = context.querySelectorAll('#auto-favorite-mutations input[type="checkbox"]');
          mutationCheckboxes.forEach(checkbox => {
              checkbox.addEventListener('change', (e) => {
                  const mutation = e.target.value;
                  if (e.target.checked) {
                      if (!UnifiedState.data.settings.autoFavorite.mutations.includes(mutation)) {
                          UnifiedState.data.settings.autoFavorite.mutations.push(mutation);
                      }
                      // Immediately favorite all existing items with this mutation
                      if (targetWindow.favoriteMutation) {
                          productionLog(`üåü [AUTO-FAVORITE] User checked ${mutation} - calling favoriteMutation`);
                          targetWindow.favoriteMutation(mutation);
                      } else {
                          productionLog('‚ùå [AUTO-FAVORITE] favoriteMutation function not available!');
                      }
                  } else {
                      UnifiedState.data.settings.autoFavorite.mutations = UnifiedState.data.settings.autoFavorite.mutations.filter(m => m !== mutation);
                      // Immediately unfavorite all existing items with this mutation
                      if (targetWindow.unfavoriteMutation) {
                          productionLog(`üåü [AUTO-FAVORITE] User unchecked ${mutation} - calling unfavoriteMutation`);
                          targetWindow.unfavoriteMutation(mutation);
                      } else {
                          productionLog('‚ùå [AUTO-FAVORITE] unfavoriteMutation function not available!');
                      }
                  }
                  saveAutoFavoriteSettings();
              });
          });
      }
  
      function getTimersTabContent() {
          return `
              <div class="mga-section">
                  <div class="mga-section-title">Restock Timers</div>
                  <div class="mga-timer">
                      <div class="mga-timer-label">Seed Restock</div>
                      <div class="mga-timer-value" id="timer-seed">--:--</div>
                  </div>
                  <div class="mga-timer">
                      <div class="mga-timer-label">Egg Restock</div>
                      <div class="mga-timer-value" id="timer-egg">--:--</div>
                  </div>
                  <div class="mga-timer">
                      <div class="mga-timer-label">Tool Restock</div>
                      <div class="mga-timer-value" id="timer-tool">--:--</div>
                  </div>
                  <div class="mga-timer" style="background: rgba(147, 51, 234, 0.30); border-color: rgba(147, 51, 234, 0.3);">
                      <div class="mga-timer-label">Lunar Event</div>
                      <div class="mga-timer-value" id="timer-lunar" style="color: #9333ea;">--:--</div>
                  </div>
              </div>
          `;
      }
  
      function getRoomStatusTabContent() {
          const currentRoom = getCurrentRoomCode();
          const roomCounts = UnifiedState.data.roomStatus?.counts || {};

          return `
              <div class="mga-section">
                  <div class="mga-section-title">üéÆ Live Room Status</div>
                  <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                      Real-time player counts for all Magic Garden rooms. Shows how many players are currently in each room. Click "Join" to navigate to that room instantly.
                  </p>
  
                  <div style="margin-bottom: 12px;">
                      <input type="text" id="room-search-input" placeholder="Search room (e.g., SLAY)..."
                          style="width: 100%; padding: 8px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255, 255, 255, 0.57);
                          border-radius: 4px; color: white; font-size: 12px;">
                  </div>
  
                  <div id="room-status-list" style="display: flex; flex-direction: column; gap: 8px;">
                      ${UnifiedState.data.customRooms.map(roomCode => {
                          const count = roomCounts[roomCode] || 0;
                          const displayCount = Math.min(count, 6);
                          const isCurrentRoom = roomCode === currentRoom;
  
                          // Color based on player count
                          let statusColor = '#94a3b8'; // Gray for empty
                          if (count > 0) statusColor = '#4ade80'; // Green for active
                          if (count >= 4) statusColor = '#fbbf24'; // Yellow for busy
                          if (count >= 6) statusColor = '#ef4444'; // Red for full
  
                          const bgColor = isCurrentRoom ? 'rgba(59, 130, 246, 0.40)' : 'rgba(255, 255, 255, 0.03)';
                          const borderColor = isCurrentRoom ? '#3b82f6' : 'rgba(255, 255, 255, 0.57)';
  
                          return `
                              <div class="room-item" draggable="true" data-room="${roomCode}" style="
                                  display: flex;
                                  align-items: center;
                                  justify-content: space-between;
                                  padding: 12px;
                                  background: ${bgColor};
                                  border: 1px solid ${borderColor};
                                  border-radius: 6px;
                                  transition: all 0.2s;
                                  cursor: grab !important;
                                  user-select: none;
                              ">
                                  <div style="display: flex; align-items: center; gap: 12px; flex: 1; cursor: grab !important;">
                                      <span style="color: #666; font-size: 16px; cursor: grab !important;" title="Drag to reorder">‚ãÆ‚ãÆ</span>
                                      <span style="
                                          font-weight: bold;
                                          color: ${isCurrentRoom ? '#60a5fa' : '#e5e7eb'};
                                          font-size: 14px;
                                          min-width: 45px;
                                          cursor: grab !important;
                                      ">${roomCode}</span>
                                      <span style="
                                          font-weight: bold;
                                          color: ${statusColor};
                                          font-size: 13px;
                                          min-width: 50px;
                                          cursor: grab !important;
                                      ">${displayCount}/6 ${isCurrentRoom ? '(You)' : ''}</span>
                                  </div>
                                  <div style="display: flex; gap: 8px; align-items: center;">
                                      <button class="mga-button room-join-btn" data-room="${roomCode}" style="
                                          padding: 6px 14px;
                                          font-size: 12px;
                                          background: ${isCurrentRoom ? '#666' : '#4a9eff'};
                                          color: white;
                                          border: none;
                                          border-radius: 4px;
                                          cursor: ${isCurrentRoom ? 'not-allowed' : 'pointer'} !important;
                                          opacity: ${isCurrentRoom ? '0.5' : '1'};
                                      " ${isCurrentRoom ? 'disabled' : ''}>
                                          ${isCurrentRoom ? 'Current' : 'Join'}
                                      </button>
                                      <button class="room-delete-btn" data-room="${roomCode}" style="
                                          padding: 6px 10px;
                                          font-size: 14px;
                                          background: #ef4444;
                                          color: white;
                                          border: none;
                                          border-radius: 4px;
                                          cursor: pointer !important;
                                          opacity: 0.8;
                                          transition: opacity 0.2s;
                                      " title="Remove room from list">
                                          ‚ùå
                                      </button>
                                  </div>
                              </div>
                          `;
                      }).join('')}
                  </div>
  
                  <div style="margin-top: 16px; padding: 12px; background: rgba(59, 130, 246, 0.30); border-radius: 6px; border: 1px solid rgba(59, 130, 246, 0.3);">
                      <div style="font-size: 12px; color: #94a3b8; line-height: 1.5;">
                          <strong style="color: #60a5fa;">How it works:</strong><br>
                          ‚Ä¢ Player counts update automatically every 5 seconds<br>
                          ‚Ä¢ Shows actual players in each room (not just script users)<br>
                          ‚Ä¢ üü¢ Green (1-3) = Active  ‚Ä¢  üü° Yellow (4-5) = Busy  ‚Ä¢  üî¥ Red (6+) = Full<br>
                          ‚Ä¢ Your current room is highlighted in blue<br>
                          ‚Ä¢ Click "Join" to navigate to any room instantly
                      </div>
                  </div>
              </div>

              <!-- Add Room Section -->
              <div style="margin-top: 16px; padding: 12px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255, 255, 255, 0.57); border-radius: 6px;">
                  <div style="font-weight: bold; color: #60a5fa; margin-bottom: 8px; font-size: 13px;">‚ûï Add Custom Room</div>
                  <div style="display: flex; gap: 8px; align-items: center;">
                      <input type="text" id="add-room-input" placeholder="Room code (e.g., MG11)"
                          style="flex: 1; padding: 8px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255, 255, 255, 0.57);
                          border-radius: 4px; color: white; font-size: 12px; text-transform: uppercase;">
                      <button id="add-room-btn" class="mga-button" style="
                          padding: 8px 16px;
                          font-size: 12px;
                          background: #4ade80;
                          color: white;
                          border: none;
                          border-radius: 4px;
                          cursor: pointer;
                          font-weight: bold;
                      ">Add</button>
                  </div>
                  <div style="font-size: 10px; color: #888; margin-top: 6px;">
                      Tip: Drag rooms to reorder, click ‚ùå to remove
                  </div>
              </div>
          `;
      }
  
      function getToolsTabContent() {
          return `
              <div class="mga-section">
                  <div class="mga-section-title">Magic Garden Calculators</div>
                  <div class="mga-tools-grid">
                      <div class="mga-tool-card" data-calculator="sell-price">
                          <div class="mga-tool-icon">üí∞</div>
                          <div class="mga-tool-name">Sell Price Calculator</div>
                          <div class="mga-tool-desc">Calculate optimal selling prices for items</div>
                      </div>
                      <div class="mga-tool-card" data-calculator="weight-probability">
                          <div class="mga-tool-icon">‚öñÔ∏è</div>
                          <div class="mga-tool-name">Weight Probability Calculator</div>
                          <div class="mga-tool-desc">Calculate weight-based probability outcomes</div>
                      </div>
                      <div class="mga-tool-card" data-calculator="pet-appearance-probability">
                          <div class="mga-tool-icon">üé≤</div>
                          <div class="mga-tool-name">Pet Appearance Probability Calculator</div>
                          <div class="mga-tool-desc">Calculate probabilities for pet appearances</div>
                      </div>
                      <div class="mga-tool-card" data-calculator="ability-trigger-time">
                          <div class="mga-tool-icon">‚è±Ô∏è</div>
                          <div class="mga-tool-name">Ability Trigger Time Calculator</div>
                          <div class="mga-tool-desc">Calculate optimal timing for pet ability triggers</div>
                      </div>
                      <div class="mga-tool-card" data-calculator="import-garden">
                          <div class="mga-tool-icon">üì•</div>
                          <div class="mga-tool-name">Import Your Garden</div>
                          <div class="mga-tool-desc">Import and analyze your garden layout</div>
                      </div>
                  </div>
                  <div class="mga-section-note" style="margin-top: 20px; padding: 10px; background: rgba(255,255,255,0.15); border-radius: 5px;">
                      <strong>Note:</strong> Calculators will open in new popup windows. Make sure popup blockers are disabled for this site.
                  </div>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">üìö Wiki Resources</div>
                  <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                      Quick access to Magic Garden wiki pages. Click any card to open in a popup window.
                  </p>
                  <div class="mga-wiki-grid">
                      <div class="mga-wiki-card" data-wiki="crops">
                          <div class="mga-wiki-icon">üåæ</div>
                          <div class="mga-wiki-name">Crops</div>
                      </div>
                      <div class="mga-wiki-card" data-wiki="pets">
                          <div class="mga-wiki-icon">üêæ</div>
                          <div class="mga-wiki-name">Pets</div>
                      </div>
                      <div class="mga-wiki-card" data-wiki="abilities">
                          <div class="mga-wiki-icon">‚ö°</div>
                          <div class="mga-wiki-name">Abilities</div>
                      </div>
                      <div class="mga-wiki-card" data-wiki="weather">
                          <div class="mga-wiki-icon">üå§Ô∏è</div>
                          <div class="mga-wiki-name">Weather Events</div>
                      </div>
                      <div class="mga-wiki-card" data-wiki="multipliers">
                          <div class="mga-wiki-icon">üìà</div>
                          <div class="mga-wiki-name">Multipliers</div>
                      </div>
                      <div class="mga-wiki-card" data-wiki="shops">
                          <div class="mga-wiki-icon">üè™</div>
                          <div class="mga-wiki-name">Shops</div>
                      </div>
                  </div>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">üå± Crop Highlighting</div>
                  <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                      Visual highlighting system for crops. Use Ctrl+H to clear highlights, Ctrl+Shift+H to toggle this panel.
                  </p>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Highlight Species:
                      </label>
                      <select class="mga-select" id="highlight-species-select">
                          <option value="">Select species to highlight...</option>
                          <option value="Carrot">ü•ï Carrot</option>
                          <option value="Strawberry">üçì Strawberry</option>
                          <option value="Aloe">üåø Aloe</option>
                          <option value="Apple">üçé Apple</option>
                          <option value="Tulip">üå∑ Tulip</option>
                          <option value="Tomato">üçÖ Tomato</option>
                          <option value="Blueberry">ü´ê Blueberry</option>
                          <option value="Daffodil">üåª Daffodil</option>
                          <option value="Corn">üåΩ Corn</option>
                          <option value="Watermelon">üçâ Watermelon</option>
                          <option value="Pumpkin">üéÉ Pumpkin</option>
                          <option value="Echeveria">üåµ Echeveria</option>
                          <option value="Coconut">ü•• Coconut</option>
                          <option value="Banana">üçå Banana</option>
                          <option value="Lily">üå∫ Lily</option>
                          <option value="BurrosTail">üåø BurrosTail</option>
                          <option value="Mushroom">üçÑ Mushroom</option>
                          <option value="Cactus">üåµ Cactus</option>
                          <option value="Bamboo">üéã Bamboo</option>
                          <option value="Grape">üçá Grape</option>
                          <option value="Sunflower">üåª Sunflower</option>
                          <option value="Pepper">üå∂Ô∏è Pepper</option>
                          <option value="Lemon">üçã Lemon</option>
                          <option value="PassionFruit">ü•≠ PassionFruit</option>
                          <option value="DragonFruit">üêâ DragonFruit</option>
                          <option value="Lychee">üçí Lychee</option>
                          <option value="Starweaver">‚≠ê Starweaver</option>
                          <option value="Moonbinder">üåô Moonbinder</option>
                          <option value="Dawnbinder">üåÖ Dawnbinder</option>
                      </select>
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Slot Index (0-2):
                      </label>
                      <input type="number" class="mga-input" id="highlight-slot-input"
                             min="0" max="2" value="0" style="width: 80px;">
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Hidden Species:
                      </label>
                      <select class="mga-select" id="hidden-species-select">
                          <option value="">None</option>
                          <option value="Carrot">ü•ï Carrot</option>
                          <option value="Strawberry">üçì Strawberry</option>
                          <option value="Aloe">üåø Aloe</option>
                          <option value="Apple">üçé Apple</option>
                          <option value="Tulip">üå∑ Tulip</option>
                          <option value="Tomato">üçÖ Tomato</option>
                          <option value="Blueberry">ü´ê Blueberry</option>
                          <option value="Daffodil">üåª Daffodil</option>
                          <option value="Corn">üåΩ Corn</option>
                          <option value="Watermelon">üçâ Watermelon</option>
                          <option value="Pumpkin">üéÉ Pumpkin</option>
                          <option value="Echeveria">üåµ Echeveria</option>
                          <option value="Coconut">ü•• Coconut</option>
                          <option value="Banana">üçå Banana</option>
                          <option value="Lily">üå∫ Lily</option>
                          <option value="BurrosTail">üåø BurrosTail</option>
                          <option value="Mushroom">üçÑ Mushroom</option>
                          <option value="Cactus">üåµ Cactus</option>
                          <option value="Bamboo">üéã Bamboo</option>
                          <option value="Grape">üçá Grape</option>
                          <option value="Sunflower">üåª Sunflower</option>
                          <option value="Pepper">üå∂Ô∏è Pepper</option>
                          <option value="Lemon">üçã Lemon</option>
                          <option value="PassionFruit">ü•≠ PassionFruit</option>
                          <option value="DragonFruit">üêâ DragonFruit</option>
                          <option value="Lychee">üçí Lychee</option>
                          <option value="Starweaver">‚≠ê Starweaver</option>
                          <option value="Moonbinder">üåô Moonbinder</option>
                          <option value="Dawnbinder">üåÖ Dawnbinder</option>
                      </select>
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Hidden Scale (0.0 - 1.0):
                      </label>
                      <input type="number" class="mga-input" id="hidden-scale-input"
                             min="0" max="1" step="0.1" value="0.1" style="width: 80px;">
                  </div>
  
                  <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                      <button class="mga-btn" id="apply-highlighting-btn" style="background: #059669;">
                          ‚ú® Apply Highlighting
                      </button>
                      <button class="mga-btn mga-btn-sm" id="clear-highlighting-btn" style="background: #dc2626;">
                          üóëÔ∏è Clear All
                      </button>
                  </div>
              </div>
              <style>
                  .mga-tools-grid {
                      display: grid;
                      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
                      gap: 15px;
                      margin-top: 15px;
                  }
  
                  .mga-tool-card {
                      background: linear-gradient(135deg, rgba(255,255,255,0.15), rgba(255,255,255,0.02));
                      border: 1px solid rgba(255, 255, 255, 0.57);
                      border-radius: 8px;
                      padding: 15px;
                      cursor: pointer;
                      transition: all 0.3s ease;
                      text-align: center;
                  }
  
                  .mga-tool-card:hover {
                      background: linear-gradient(135deg, rgba(255, 255, 255, 0.55), rgba(255,255,255,0.04));
                      border-color: rgba(255, 255, 255, 0.73);
                      transform: translateY(-2px);
                      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.48);
                  }
  
                  .mga-tool-icon {
                      font-size: 2em;
                      margin-bottom: 8px;
                  }
  
                  .mga-tool-name {
                      font-weight: bold;
                      margin-bottom: 5px;
                      color: rgba(255,255,255,0.9);
                  }
  
                  .mga-tool-desc {
                      font-size: 0.85em;
                      color: rgba(255,255,255,0.6);
                      line-height: 1.3;
                  }
  
                  .mga-wiki-grid {
                      display: grid;
                      grid-template-columns: repeat(3, 1fr);
                      gap: 10px;
                      margin-top: 12px;
                  }
  
                  .mga-wiki-card {
                      background: linear-gradient(135deg, rgba(74, 158, 255, 0.28), rgba(74, 158, 255, 0.03));
                      border: 1px solid rgba(74, 158, 255, 0.48);
                      border-radius: 6px;
                      padding: 12px 8px;
                      cursor: pointer;
                      transition: all 0.2s ease;
                      text-align: center;
                  }
  
                  .mga-wiki-card:hover {
                      background: linear-gradient(135deg, rgba(74, 158, 255, 0.40), rgba(74, 158, 255, 0.28));
                      border-color: rgba(74, 158, 255, 0.4);
                      transform: translateY(-1px);
                      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.48);
                  }
  
                  .mga-wiki-icon {
                      font-size: 1.5em;
                      margin-bottom: 4px;
                  }
  
                  .mga-wiki-name {
                      font-size: 0.85em;
                      font-weight: 600;
                      color: rgba(255,255,255,0.9);
                  }
              </style>
          `;
      }
  
      // ==================== AUDIO NOTIFICATION SYSTEM ====================
  
      // BUGFIX: Reuse single AudioContext to prevent memory leaks and browser audio conflicts
      let sharedAudioContext = null;
  
      function getAudioContext() {
          if (!sharedAudioContext || sharedAudioContext.state === 'closed') {
              sharedAudioContext = new (window.AudioContext || window.webkitAudioContext)();
          }
          // Resume if suspended (browser autoplay policy)
          if (sharedAudioContext.state === 'suspended') {
              sharedAudioContext.resume();
          }
          return sharedAudioContext;
      }
  
      // Play notification sound using Web Audio API
      function playNotificationSound(frequency = 800, duration = 200, volume = 0.3) {
          try {
              const audioContext = getAudioContext();
              const oscillator = audioContext.createOscillator();
              const gainNode = audioContext.createGain();
  
              oscillator.connect(gainNode);
              gainNode.connect(audioContext.destination);
  
              oscillator.frequency.value = frequency;
              oscillator.type = 'sine';
  
              gainNode.gain.setValueAtTime(volume, audioContext.currentTime);
              gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration/1000);
  
              oscillator.start(audioContext.currentTime);
              oscillator.stop(audioContext.currentTime + duration/1000);
  
              productionLog(`üîä [NOTIFICATIONS] Sound played for rare item!`);
          } catch (error) {
              console.error('‚ùå [NOTIFICATIONS] Failed to play notification sound:', error);
          }
      }
  
      // Play triple beep notification for rare items
      function playTripleBeepNotification(volume = 0.3) {
          playNotificationSound(1000, 250, volume);
          setTimeout(() => playNotificationSound(1000, 200, volume * 0.8), 300);
          setTimeout(() => playNotificationSound(1200, 150, volume * 0.6), 600);
      }
  
      // Play double beep notification for pet hunger (different from shop alerts)
      function playDoubleBeepNotification(volume = 0.3) {
          playNotificationSound(600, 200, volume);
          setTimeout(() => playNotificationSound(600, 200, volume * 0.9), 250);
      }
  
      // Play single beep for ability notifications (subtle)
      function playSingleBeepNotification(volume = 0.2) {
          playNotificationSound(500, 150, volume);
      }
  
      // Play chime notification - ascending notes (pleasant)
      function playChimeNotification(volume = 0.2) {
          playNotificationSound(500, 100, volume);
          setTimeout(() => playNotificationSound(800, 100, volume * 0.9), 120);
          setTimeout(() => playNotificationSound(1000, 120, volume * 0.8), 240);
      }
  
      // Play alert notification - urgent descending (attention-grabbing)
      function playAlertNotification(volume = 0.2) {
          playNotificationSound(1200, 150, volume);
          setTimeout(() => playNotificationSound(900, 150, volume * 0.9), 160);
      }
  
      // Play buzz notification - rapid pulsing (energetic)
      function playBuzzNotification(volume = 0.2) {
          for (let i = 0; i < 8; i++) {
              setTimeout(() => playNotificationSound(300, 40, volume * (i % 2 === 0 ? 1 : 0.6)), i * 50);
          }
      }
  
      // Play ding notification - clean bell-like (clear)
      function playDingNotification(volume = 0.2) {
          playNotificationSound(2000, 180, volume);
      }
  
      // Play chirp notification - quick rising chirp (cute)
      function playChirpNotification(volume = 0.2) {
          playNotificationSound(400, 80, volume);
          setTimeout(() => playNotificationSound(800, 60, volume * 0.8), 85);
          setTimeout(() => playNotificationSound(1200, 40, volume * 0.6), 150);
      }
  
      // Play alarm siren notification (very loud and noticeable)
      function playAlarmNotification(volume = 0.5) {
          let count = 0;
          const interval = setInterval(() => {
              // Alternating high-low siren sound
              playNotificationSound(count % 2 === 0 ? 1500 : 800, 400, volume);
              count++;
              if (count >= 6) clearInterval(interval); // Play 6 times total
          }, 450);
      }
  
      // Play continuous warning sound (repeats until acknowledged)
      let continuousAlarmInterval = null;
      function startContinuousAlarm(volume = 0.4) {
          if (continuousAlarmInterval) return; // Already playing
  
          let tone = 800;
          continuousAlarmInterval = setInterval(() => {
              // Warbling effect
              tone = tone === 800 ? 1200 : 800;
              playNotificationSound(tone, 300, volume);
          }, 350);
  
          productionLog('üö® [NOTIFICATIONS] Continuous alarm started - requires acknowledgment!');
      }
  
      function stopContinuousAlarm() {
          if (continuousAlarmInterval) {
              clearInterval(continuousAlarmInterval);
              continuousAlarmInterval = null;
              productionLog('‚úÖ [NOTIFICATIONS] Continuous alarm stopped');
          }
      }
  
      // Play epic notification (multiple tones in sequence)
      function playEpicNotification(volume = 0.4) {
          const sequence = [
              [400, 100], [500, 100], [600, 100], [800, 150],
              [1000, 200], [1200, 150], [1000, 150], [1200, 200],
              [1500, 300], [1200, 100], [1500, 400]
          ];
  
          let delay = 0;
          sequence.forEach(([freq, dur]) => {
              setTimeout(() => playNotificationSound(freq, dur, volume), delay);
              delay += dur + 50;
          });
      }
  
      // Play selected notification type
      function playSelectedNotification() {
          const notifications = UnifiedState.data.settings.notifications;
          const volume = notifications.volume || 0.3;
          const type = notifications.notificationType || 'triple';
  
          productionLog(`üîä [NOTIFICATIONS] Playing ${type} notification at ${Math.round(volume * 100)}% volume`);
  
          switch (type) {
              case 'simple':
                  playNotificationSound(1000, 300, volume);
                  break;
              case 'triple':
                  playTripleBeepNotification(volume);
                  break;
              case 'alarm':
                  playAlarmNotification(volume);
                  break;
              case 'epic':
                  playEpicNotification(volume);
                  break;
              case 'continuous':
                  startContinuousAlarm(volume);
                  break;
              default:
                  playTripleBeepNotification(volume);
          }
      }
  
      // Normalize species names for case-insensitive matching
      function normalizeSpeciesName(name) {
          if (!name || typeof name !== 'string') return '';
          return name.trim().toLowerCase();
      }

      // ========== CUSTOM SOUND PLAYBACK WRAPPERS ==========
      // These functions check for custom uploaded sounds before falling back to default beeps

      function playCustomOrDefaultSound(soundType, defaultPlayFunc, volume) {
          const customSound = GM_getValue(`mgtools_custom_sound_${soundType}`, null);
          if (customSound) {
              try {
                  const audio = new Audio(customSound);
                  audio.volume = volume || 0.3;
                  audio.play();
                  productionLog(`üéµ [CUSTOM-SOUND] Playing custom ${soundType} sound`);
              } catch (err) {
                  console.error(`Failed to play custom ${soundType} sound:`, err);
                  defaultPlayFunc(volume);
              }
          } else {
              defaultPlayFunc(volume);
          }
      }

      function playShopNotificationSound(volume) {
          playCustomOrDefaultSound('shop', playTripleBeepNotification, volume);
      }

      function playPetNotificationSound(volume) {
          playCustomOrDefaultSound('pet', playDoubleBeepNotification, volume);
      }

      function playAbilityNotificationSound(volume) {
          playCustomOrDefaultSound('ability', playSingleBeepNotification, volume);
      }

      function playWeatherNotificationSound(volume) {
          playCustomOrDefaultSound('weather', playTripleBeepNotification, volume);
      }

      // Check if an item is on the watch list (case-insensitive for seeds)
      function isWatchedItem(itemId, type = 'seed') {
          const notifications = UnifiedState.data.settings.notifications;
          if (type === 'seed') {
              // Handle name variations for celestial seeds
              // Shop uses "DawnCelestial" and "MoonCelestial" but UI uses "Dawnbinder" and "Moonbinder"
              const nameMap = {
                  'DawnCelestial': 'Dawnbinder',
                  'MoonCelestial': 'Moonbinder'
              };
              const checkId = nameMap[itemId] || itemId;
  
              // Case-insensitive matching for seeds
              const normalizedItemId = normalizeSpeciesName(checkId);
              return notifications.watchedSeeds.some(watched =>
                  normalizeSpeciesName(watched) === normalizedItemId
              );
          } else if (type === 'egg') {
              return notifications.watchedEggs.includes(itemId);
          }
          return false;
      }
  
      // Update last seen timestamp for an item
      function updateLastSeen(itemId) {
          const notifications = UnifiedState.data.settings.notifications;
          notifications.lastSeenTimestamps[itemId] = Date.now();
          MGA_saveJSON('MGA_data', UnifiedState.data);
          productionLog(`üìÖ [NOTIFICATIONS] Updated last seen for ${itemId}`);
      }
  
      // Get time since last seen (in human readable format)
      function getTimeSinceLastSeen(itemId) {
          const notifications = UnifiedState.data.settings.notifications;
  
          // Map UI names to shop IDs for celestial seeds
          // UI shows "Moonbinder" but shop stores as "MoonCelestial"
          const reverseNameMap = {
              'Moonbinder': 'MoonCelestial',
              'Dawnbinder': 'DawnCelestial'
          };
          const lookupId = reverseNameMap[itemId] || itemId;
  
          const timestamp = notifications.lastSeenTimestamps[lookupId];
          if (!timestamp) return "Never seen";
  
          const diff = Date.now() - timestamp;
          const hours = Math.floor(diff / (1000 * 60 * 60));
          const days = Math.floor(hours / 24);
  
          if (days > 0) return `${days} day${days > 1 ? 's' : ''} ago`;
          if (hours > 0) return `${hours} hour${hours > 1 ? 's' : ''} ago`;
  
          const minutes = Math.floor(diff / (1000 * 60));
          return `${minutes} minute${minutes > 1 ? 's' : ''} ago`;
      }
  
      // Notification queue system for batching multiple notifications
      let notificationQueue = [];
      let currentNotificationModal = null;
      let notificationQueueTimer = null;
      const NOTIFICATION_BATCH_DELAY = 2000; // 2 seconds to batch notifications
  
      // Add notification to queue and show batched modal
      function queueNotification(message, requiresAcknowledgment = false) {
          notificationQueue.push({ message, requiresAcknowledgment, timestamp: Date.now() });
  
          // Clear existing timer and start new one
          if (notificationQueueTimer) {
              clearTimeout(notificationQueueTimer);
          }
  
          // If there's already a modal open, update it immediately
          if (currentNotificationModal) {
              updateNotificationModal();
              return;
          }
  
          // Otherwise, batch notifications for a short period
          notificationQueueTimer = setTimeout(() => {
              showBatchedNotificationModal();
          }, NOTIFICATION_BATCH_DELAY);
      }
  
      // Update existing notification modal with new notifications
      function updateNotificationModal() {
          if (!currentNotificationModal) return;
  
          const messageContainer = currentNotificationModal.querySelector('.notification-messages');
          if (messageContainer) {
              messageContainer.innerHTML = generateNotificationListHTML();
          }
  
          const countDisplay = currentNotificationModal.querySelector('.notification-count');
          if (countDisplay) {
              countDisplay.textContent = `${notificationQueue.length} Notification${notificationQueue.length > 1 ? 's' : ''}`;
          }
      }
  
      // Generate HTML for notification list
      function generateNotificationListHTML() {
          return notificationQueue.map((notif, index) => `
              <div style="margin-bottom: 10px; padding: 10px; background: rgba(255, 255, 255, 0.57); border-radius: 5px; border-left: 3px solid #fff;">
                  <div style="font-size: 14px; margin-bottom: 5px;">${notif.message}</div>
                  <div style="font-size: 10px; opacity: 0.8;">${new Date(notif.timestamp).toLocaleTimeString()}</div>
              </div>
          `).join('');
      }
  
      // Show batched notification modal
      function showBatchedNotificationModal() {
          if (notificationQueue.length === 0) return;
  
          // Ensure only one modal exists at a time - cleanup any existing modal
          if (currentNotificationModal) {
              dismissAllNotifications();
              // Wait a bit for the dismiss animation to complete
              setTimeout(() => showBatchedNotificationModal(), 350);
              return;
          }
  
          const hasAcknowledgmentRequired = notificationQueue.some(n => n.requiresAcknowledgment);
  
          // If only one notification and no acknowledgment required, use regular notification
          if (notificationQueue.length === 1 && !hasAcknowledgmentRequired) {
              const notif = notificationQueue[0];
              showVisualNotification(notif.message, notif.requiresAcknowledgment);
              notificationQueue = [];
              return;
          }
  
          // If multiple notifications but NONE require acknowledgment, show them as simple toasts
          if (!hasAcknowledgmentRequired) {
              // Show each notification as a simple non-blocking toast
              notificationQueue.forEach(notif => {
                  showVisualNotification(notif.message, false);
              });
              notificationQueue = [];
              return;
          }
  
          // Create batched modal (only if acknowledgment is required)
          const notification = targetDocument.createElement('div');
          notification.className = 'mga-batched-notification';
  
          notification.style.cssText = `
              position: fixed;
              top: 50%;
              left: 50%;
              transform: translate(-50%, -50%);
              background: linear-gradient(135deg, #ff6b6b 0%, #ff0000 100%);
              color: white;
              padding: 20px;
              border-radius: 15px;
              box-shadow: 0 20px 60px rgba(255,0,0,0.4), 0 0 100px rgba(255, 0, 0, 0.48);
              z-index: 9999999;
              font-weight: bold;
              animation: mga-modal-entrance 0.5s ease-out;
              border: 3px solid #ffffff;
              text-align: center;
              max-width: 500px;
              max-height: 400px;
              overflow-y: auto;
          `;
  
          notification.innerHTML = `
              <div class="notification-count" style="font-size: 20px; margin-bottom: 15px;">
                  ${notificationQueue.length} Notification${notificationQueue.length > 1 ? 's' : ''}
              </div>
              <div class="notification-messages" style="text-align: left; margin-bottom: 20px; max-height: 200px; overflow-y: auto;">
                  ${generateNotificationListHTML()}
              </div>
              <button class="acknowledge-all-btn" style="
                  background: white;
                  color: #ff0000;
                  border: none;
                  padding: 12px 24px;
                  border-radius: 5px;
                  font-weight: bold;
                  font-size: 16px;
                  cursor: pointer;
                  box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                  transition: all 0.2s;
              ">
                  ACKNOWLEDGE ALL (${notificationQueue.length})
              </button>
          `;
  
          // Add button interactivity
          const ackButton = notification.querySelector('.acknowledge-all-btn');
          ackButton.onmouseover = () => {
              ackButton.style.transform = 'scale(1.05)';
              ackButton.style.boxShadow = '0 6px 15px rgba(0,0,0,0.4)';
          };
          ackButton.onmouseout = () => {
              ackButton.style.transform = 'scale(1)';
              ackButton.style.boxShadow = '0 4px 10px rgba(0,0,0,0.3)';
          };
          ackButton.onclick = () => {
              dismissAllNotifications();
          };
  
          // Add backdrop
          const backdrop = targetDocument.createElement('div');
          backdrop.className = 'mga-notification-backdrop';
          backdrop.style.cssText = `
              position: fixed;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background: rgba(0, 0, 0, 0.7);
              z-index: 9999998;
              animation: fadeIn 0.3s ease-in;
          `;
          backdrop.onclick = () => {
              backdrop.style.animation = 'flash 0.3s ease-in-out';
          };
  
          targetDocument.body.appendChild(backdrop);
          targetDocument.body.appendChild(notification);
  
          currentNotificationModal = notification;
  
          // Stop continuous alarm if playing
          stopContinuousAlarm();
      }
  
      // Dismiss all notifications
      function dismissAllNotifications() {
          stopContinuousAlarm();
  
          if (currentNotificationModal) {
              const backdrop = targetDocument.querySelector('.mga-notification-backdrop');
  
              currentNotificationModal.style.animation = 'fadeOut 0.3s ease-out';
              if (backdrop) backdrop.style.animation = 'fadeOut 0.3s ease-out';
  
              setTimeout(() => {
                  if (currentNotificationModal) currentNotificationModal.remove();
                  if (backdrop) backdrop.remove();
                  currentNotificationModal = null;
              }, 300);
          }
  
          notificationQueue = [];
  
          if (notificationQueueTimer) {
              clearTimeout(notificationQueueTimer);
              notificationQueueTimer = null;
          }
      }
  
      // Format timestamp based on user preference
      function formatTimestamp(timestamp) {
          // PERFORMANCE: Check cache first (cache key includes timestamp + settings mode)
          const cacheKey = `${timestamp}_${UnifiedState.data.settings.detailedTimestamps}`;
          if (MGA_AbilityCache.timestamps.has(cacheKey)) {
              return MGA_AbilityCache.timestamps.get(cacheKey);
          }

          const date = new Date(timestamp);
          let formatted;
          if (UnifiedState.data.settings.detailedTimestamps) {
              // Return HH:MM:SS format in user's local timezone
              formatted = date.toLocaleTimeString(undefined, {
                  hour12: false,
                  hour: '2-digit',
                  minute: '2-digit',
                  second: '2-digit'
              });
          } else {
              // Return default H:MM AM/PM format in user's local timezone
              formatted = date.toLocaleTimeString(undefined, {
                  hour: 'numeric',
                  minute: '2-digit'
              });
          }

          // PERFORMANCE: Cache result (cleared every minute via setInterval)
          MGA_AbilityCache.timestamps.set(cacheKey, formatted);

          return formatted;
      }
  
      // Show visual notification in game (legacy function, now routes through queue)
      function showVisualNotification(message, requiresAcknowledgment = false) {
          // Ensure only one modal exists at a time for acknowledgment-required notifications
          if (requiresAcknowledgment && currentNotificationModal) {
              dismissAllNotifications();
              // Wait a bit for the dismiss animation to complete
              setTimeout(() => showVisualNotification(message, requiresAcknowledgment), 350);
              return;
          }
          window.devConsoleApi.executeCommand('send-notification', message);
          const notification = targetDocument.createElement('div');
  
          if (requiresAcknowledgment) {
              // Create persistent modal that requires acknowledgment
              notification.style.cssText = `
                  position: fixed;
                  top: 50%;
                  left: 50%;
                  transform: translate(-50%, -50%);
                  background: linear-gradient(135deg, #ff6b6b 0%, #ff0000 100%);
                  color: white;
                  padding: 30px;
                  border-radius: 15px;
                  box-shadow: 0 20px 60px rgba(255,0,0,0.4), 0 0 100px rgba(255, 0, 0, 0.48);
                  z-index: 9999999;
                  font-weight: bold;
                  font-size: 20px;
                  animation: mga-modal-entrance 0.5s ease-out;
                  border: 3px solid #ffffff;
                  text-align: center;
                  min-width: 400px;
              `;
  
              // Create message div
              const messageDiv = targetDocument.createElement('div');
              messageDiv.textContent = message;
              messageDiv.style.marginBottom = '20px';
              notification.appendChild(messageDiv);
  
              // Create acknowledge button
              const ackButton = targetDocument.createElement('button');
              ackButton.textContent = 'ACKNOWLEDGE (Stop Alarm)';
              ackButton.style.cssText = `
                  background: white;
                  color: #ff0000;
                  border: none;
                  padding: 10px 20px;
                  border-radius: 5px;
                  font-weight: bold;
                  font-size: 16px;
                  cursor: pointer;
                  box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                  transition: all 0.2s;
              `;
              ackButton.onmouseover = () => {
                  ackButton.style.transform = 'scale(1.05)';
                  ackButton.style.boxShadow = '0 6px 15px rgba(0,0,0,0.4)';
              };
              ackButton.onmouseout = () => {
                  ackButton.style.transform = 'scale(1)';
                  ackButton.style.boxShadow = '0 4px 10px rgba(0,0,0,0.3)';
              };
              ackButton.onclick = () => {
                  stopContinuousAlarm();
                  notification.style.animation = 'fadeOut 0.3s ease-out';
                  setTimeout(() => notification.remove(), 300);
              };
              notification.appendChild(ackButton);
  
              // Add backdrop
              const backdrop = targetDocument.createElement('div');
              backdrop.style.cssText = `
                  position: fixed;
                  top: 0;
                  left: 0;
                  width: 100%;
                  height: 100%;
                  background: rgba(0, 0, 0, 0.7);
                  z-index: 9999998;
                  animation: fadeIn 0.3s ease-in;
              `;
              backdrop.onclick = () => {
                  backdrop.style.animation = 'flash 0.3s ease-in-out';
              };
              targetDocument.body.appendChild(backdrop);
  
              // Append notification to body
              targetDocument.body.appendChild(notification);
  
              // Set as current modal for tracking
              currentNotificationModal = notification;
  
              // Link backdrop removal to button click
              ackButton.onclick = () => {
                  stopContinuousAlarm();
                  notification.style.animation = 'fadeOut 0.3s ease-out';
                  backdrop.style.animation = 'fadeOut 0.3s ease-out';
                  setTimeout(() => {
                      notification.remove();
                      backdrop.remove();
                      currentNotificationModal = null;
                  }, 300);
              };
  
          } else {
              // Regular auto-dismiss notification
              notification.style.cssText = `
                  position: fixed;
                  top: 20px;
                  right: 20px;
                  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                  color: white;
                  padding: 15px 20px;
                  border-radius: 10px;
                  box-shadow: 0 10px 30px rgba(0,0,0,0.3);
                  z-index: 999999;
                  font-weight: bold;
                  font-size: 16px;
                  animation: slideInRight 0.5s ease-out;
                  border: 2px solid rgba(255,255,255,0.3);
              `;
              notification.textContent = message;
  
              // Remove after 5 seconds
              setTimeout(() => {
                  notification.style.animation = 'slideOutRight 0.5s ease-out';
                  setTimeout(() => notification.remove(), 500);
              }, 5000);
          }
  
          // Add animation styles if not exists
          if (!targetDocument.getElementById('mga-notification-animations')) {
              const style = targetDocument.createElement('style');
              style.id = 'mga-notification-animations';
              style.textContent = `
                  @keyframes slideInRight {
                      from { transform: translateX(100%); opacity: 0; }
                      to { transform: translateX(0); opacity: 1; }
                  }
                  @keyframes slideOutRight {
                      from { transform: translateX(0); opacity: 1; }
                      to { transform: translateX(100%); opacity: 0; }
                  }
                  @keyframes mga-notification-pulse {
                      from { transform: translate(-50%, -50%) scale(1); }
                      to { transform: translate(-50%, -50%) scale(1.05); }
                  }
                  @keyframes mga-modal-entrance {
                      from {
                          opacity: 0;
                          transform: translate(-50%, -50%) scale(0.8);
                      }
                      to {
                          opacity: 1;
                          transform: translate(-50%, -50%) scale(1);
                      }
                  }
                  @keyframes fadeIn {
                      from { opacity: 0; }
                      to { opacity: 1; }
                  }
                  @keyframes fadeOut {
                      from { opacity: 1; }
                      to { opacity: 0; }
                  }
                  @keyframes flash {
                      0%, 100% { background: rgba(0, 0, 0, 0.7); }
                      50% { background: rgba(255, 0, 0, 0.3); }
                  }
              `;
              targetDocument.head.appendChild(style);
          }
  
          targetDocument.body.appendChild(notification);
      }
  
      // Track current shop inventory and restock state
      let previousSeedInventory = [];
      let previousEggInventory = [];
      let previousDecorInventory = [];
      let previousToolInventory = [];
      let previousSeedQuantities = {};
      let previousEggQuantities = {};
      let previousDecorQuantities = {};
      let previousToolQuantities = {};
      let lastRestockCheck = 0;
      let lastNotificationTime = 0;
      let lastSeedTimer = 999;
      let lastEggTimer = 999;
      let lastDecorTimer = 999;
      let lastSeedRestock = 0;
      let lastEggRestock = 0;
      let lastDecorRestock = 0;
      let seedRestockNotifiedItems = new Set(); // Track items notified during current restock
      let eggRestockNotifiedItems = new Set(); // Track items notified during current restock
      let decorRestockNotifiedItems = new Set(); // Track items notified during current restock
      let isFirstRun = true; // Track if this is the first check to notify for watched items already in stock
      const CHECK_INTERVAL = 2000; // Check every 2 seconds for better timing
  
      // Restock detection constants (same as Buy UI for maximum reliability)
      const SMALL_EDGE = 5;      // Timer at or below 5s means near restock
      const LARGE_EDGE = 180;    // Timer at or above 180s means just restocked
      const BIG_JUMP_DELTA = 60; // Timer jump of 60+ seconds indicates restock
      const NOTIFICATION_COOLDOWN = 30000; // 30 seconds between notifications for same item to prevent duplicates
      const RESTOCK_COOLDOWN = 30000; // 30 seconds cooldown after restock to catch all new items
  
      // Check for new watched items in shop
      function checkForWatchedItems() {
          const notifications = UnifiedState.data.settings.notifications;
          if (!notifications || !notifications.enabled) return;
  
          try {
              const now = Date.now();
  
              // Collect all detected items in this check cycle for batch notification
              const detectedItems = [];
  
              // Check every 5 seconds to catch items quickly
              if (now - lastRestockCheck < CHECK_INTERVAL) return;
              lastRestockCheck = now;
  
              // Get timer data - use both sources for reliability
              const quinoaData = UnifiedState.atoms.quinoaData || targetWindow?.globalShop;
              if (!quinoaData && !targetWindow?.globalShop) return; // No shop data available
  
              // Use targetWindow.globalShop as primary source, quinoaData as fallback
              const shopData = targetWindow?.globalShop || UnifiedState.atoms.quinoaData || quinoaData;
              const seedTimer = shopData?.shops?.seed?.secondsUntilRestock || 999;
              const eggTimer = shopData?.shops?.egg?.secondsUntilRestock || 999;
              const decorTimer = shopData?.shops?.decor?.secondsUntilRestock || 999;
  
              // Detect restock using robust edge-detection (same method as Buy UI)
              // Method 1: Timer was ‚â§5s and now ‚â•180s (actual reset moment)
              // Method 2: Timer jumped by ‚â•60s (big jump indicates restock)
              const seedRestocked =
                  (lastSeedTimer <= SMALL_EDGE && seedTimer >= LARGE_EDGE) ||
                  (seedTimer - lastSeedTimer >= BIG_JUMP_DELTA && lastSeedTimer > 0);
  
              const eggRestocked =
                  (lastEggTimer <= SMALL_EDGE && eggTimer >= LARGE_EDGE) ||
                  (eggTimer - lastEggTimer >= BIG_JUMP_DELTA && lastEggTimer > 0);
  
              const decorRestocked =
                  (lastDecorTimer <= SMALL_EDGE && decorTimer >= LARGE_EDGE) ||
                  (decorTimer - lastDecorTimer >= BIG_JUMP_DELTA && lastDecorTimer > 0);
  
              // Timer tracking (silent unless restock detected)
  
              if (seedRestocked) {
                  productionLog(`üîÑ [NOTIFICATIONS] SEED SHOP RESTOCKED! (Edge detection: ${lastSeedTimer}‚Üí${seedTimer})`);
                  previousSeedInventory = []; // Clear for new cycle
                  previousSeedQuantities = {}; // Clear quantity tracking
                  seedRestockNotifiedItems.clear(); // Clear restock notification tracking
                  lastSeedRestock = now;
              }
  
              if (eggRestocked) {
                  productionLog(`üîÑ [NOTIFICATIONS] EGG SHOP RESTOCKED! (Edge detection: ${lastEggTimer}‚Üí${eggTimer})`);
                  previousEggInventory = []; // Clear for new cycle
                  previousEggQuantities = {}; // Clear quantity tracking
                  eggRestockNotifiedItems.clear(); // Clear restock notification tracking
                  lastEggRestock = now;
              }
  
              if (decorRestocked) {
                  productionLog(`üîÑ [NOTIFICATIONS] DECOR SHOP RESTOCKED! (Edge detection: ${lastDecorTimer}‚Üí${decorTimer})`);
                  previousDecorInventory = []; // Clear for new cycle
                  previousDecorQuantities = {}; // Clear quantity tracking
                  decorRestockNotifiedItems.clear(); // Clear restock notification tracking
                  lastDecorRestock = now;
              }
  
              // Update last timer values
              lastSeedTimer = seedTimer;
              lastEggTimer = eggTimer;
              lastDecorTimer = decorTimer;
  
              // Check seed shop
              const currentSeeds = targetWindow?.globalShop?.shops?.seed?.inventory || [];
              const inStockSeeds = currentSeeds.filter(item => item.initialStock > 0);
              const currentSeedIds = inStockSeeds.map(item => item.species);
  
              // OPTIMIZED: Removed excessive debug logging
  
              // Track seed quantities (FIXED APPROACH)
              const currentSeedQuantities = {};
              inStockSeeds.forEach(item => {
                  currentSeedQuantities[item.species] = item.initialStock;
              });
  
              // Initialize previous quantities if empty (first run)
              if (Object.keys(previousSeedQuantities).length === 0 && !seedRestocked) {
                  productionLog(`üîß [NOTIFICATIONS] Initializing previous seed quantities...`);
                  Object.keys(currentSeedQuantities).forEach(seedId => {
                      previousSeedQuantities[seedId] = currentSeedQuantities[seedId];
                  });
              }
  
              productionLog(`üõí [NOTIFICATIONS] Current seed quantities:`, currentSeedQuantities, `| Previous:`, previousSeedQuantities);
  
              // Find seeds with increased quantities or new items (after restock)
              Object.keys(currentSeedQuantities).forEach(seedId => {
                  const oldQuantity = previousSeedQuantities[seedId] || 0;
                  const newQuantity = currentSeedQuantities[seedId];
  
                  // Always log each seed being processed for debugging
                  productionLog(`üîç [NOTIFICATIONS] Processing seed: ${seedId} (${oldQuantity}‚Üí${newQuantity})`);
  
                  // Determine if we should check for notification
                  const quantityIncreased = newQuantity > oldQuantity;
                  const isRestockWindow = seedRestocked && (now - lastSeedRestock) < RESTOCK_COOLDOWN;
                  const alreadyNotifiedInRestock = seedRestockNotifiedItems.has(seedId);
  
                  productionLog(`üîç [NOTIFICATIONS] ${seedId} check logic: quantityIncreased=${quantityIncreased}, isRestockWindow=${isRestockWindow}, alreadyNotifiedInRestock=${alreadyNotifiedInRestock}`);
  
                  // Only trigger notification if:
                  // 1) First run and item is in stock, OR
                  // 2) Quantity increased AND not in restock window, OR
                  // 3) In restock window AND item hasn't been notified in this restock cycle, OR
                  // 4) New item appears (oldQuantity was 0)
                  const shouldCheck = (isFirstRun && newQuantity > 0) || (quantityIncreased && !isRestockWindow) || (isRestockWindow && !alreadyNotifiedInRestock) || (oldQuantity === 0 && newQuantity > 0);
  
                  productionLog(`üîç [NOTIFICATIONS] ${seedId} shouldCheck: ${shouldCheck}`);
  
                  if (shouldCheck) {
                      productionLog(`üÜï [NOTIFICATIONS] Seed stock change: ${seedId} (${oldQuantity}‚Üí${newQuantity}) | Restock: ${seedRestocked} | RestockWindow: ${isRestockWindow}`);
  
                      // Update last seen for ANY seed that appears or increases
                      updateLastSeen(seedId);
  
                      // Check if it's a watched seed with detailed logging
                      const isWatched = isWatchedItem(seedId, 'seed');
                      productionLog(`üîç [NOTIFICATIONS] Is ${seedId} watched? ${isWatched}`);
                      productionLog(`üîç [NOTIFICATIONS] Watched list: [${notifications.watchedSeeds.join(', ')}]`);
                      productionLog(`üîç [NOTIFICATIONS] Exact match check:`, notifications.watchedSeeds.map(w => ({
                          watched: w,
                          current: seedId,
                          exactMatch: w === seedId,
                          lowerMatch: w.toLowerCase() === seedId.toLowerCase()
                      })));
  
                      if (isWatched) {
                          // Check cooldown (1 minute per item, but allow Carrot for testing)
                          const itemKey = `seed_${seedId}`;
                          const lastNotified = notifications.lastSeenTimestamps[`notified_${itemKey}`] || 0;
                          const canNotify = (now - lastNotified) > NOTIFICATION_COOLDOWN;
  
                          productionLog(`üîç [NOTIFICATIONS] ${seedId} cooldown check: lastNotified=${lastNotified}, now=${now}, diff=${now-lastNotified}, canNotify=${canNotify}`);
  
                          if (canNotify) {
                              productionLog(`üéâ [NOTIFICATIONS] RARE SEED DETECTED: ${seedId} (${newQuantity} in stock)`);
                              notifications.lastSeenTimestamps[`notified_${itemKey}`] = now;
  
                              // Track that we notified this item during restock
                              if (isRestockWindow) {
                                  seedRestockNotifiedItems.add(seedId);
                              }
  
                              MGA_saveJSON('MGA_data', UnifiedState.data);
  
                              // Collect item for batch notification instead of notifying immediately
                              detectedItems.push({
                                  type: 'seed',
                                  id: seedId,
                                  quantity: newQuantity,
                                  icon: 'üå±'
                              });
                          } else {
                              productionLog(`‚è∞ [NOTIFICATIONS] ${seedId} on cooldown, not notifying`);
                          }
                      } else {
                          productionLog(`‚ùå [NOTIFICATIONS] ${seedId} is not watched, skipping notification`);
                      }
                  } else {
                      productionLog(`‚è≠Ô∏è [NOTIFICATIONS] ${seedId} shouldCheck=false, skipping`);
                  }
              });
  
              productionLog(`‚úÖ [NOTIFICATIONS] Finished checking seeds, moving to eggs...`);
  
              // Check egg shop
              // Declare variables OUTSIDE try block to fix scope issue
              let currentEggIds = [];
              let currentEggQuantities = {};
  
              try {
                  productionLog(`ü•ö [NOTIFICATIONS] === CHECKING EGG SHOP ===`);
                  const currentEggs = targetWindow?.globalShop?.shops?.egg?.inventory || [];
                  const inStockEggs = currentEggs.filter(item => item.initialStock > 0);
                  currentEggIds = inStockEggs.map(item => item.eggId);
  
              // Always log current egg state for debugging (like seeds)
              productionLog(`ü•ö [NOTIFICATIONS] Current eggs in shop: [${currentEggIds.join(', ')}] | Previous: [${previousEggInventory.join(', ')}]`);
              productionLog(`ü•ö [NOTIFICATIONS] Raw egg inventory:`, currentEggs.map(e => `${e.eggId}(stock:${e.initialStock})`));
  
              // Debug egg shop structure
              if (currentEggs.length === 0) {
                  productionLog(`ü•ö [NOTIFICATIONS] No eggs found. Shop structure:`, {
                      hasGlobalShop: !!targetWindow?.globalShop,
                      hasShops: !!targetWindow?.globalShop?.shops,
                      hasEggShop: !!targetWindow?.globalShop?.shops?.egg,
                      hasEggInventory: !!targetWindow?.globalShop?.shops?.egg?.inventory,
                      eggInventoryLength: targetWindow?.globalShop?.shops?.egg?.inventory?.length || 0
                  });
              }
  
              // Track egg quantities (FIXED APPROACH)
              // Use the variable declared outside try block
              inStockEggs.forEach(item => {
                  currentEggQuantities[item.eggId] = item.initialStock;
              });
  
              // Initialize previous quantities if empty (first run)
              if (Object.keys(previousEggQuantities).length === 0 && !eggRestocked) {
                  productionLog(`üîß [NOTIFICATIONS] Initializing previous egg quantities...`);
                  Object.keys(currentEggQuantities).forEach(eggId => {
                      previousEggQuantities[eggId] = currentEggQuantities[eggId];
                  });
              }
  
              productionLog(`ü•ö [NOTIFICATIONS] Current egg quantities:`, currentEggQuantities, `| Previous:`, previousEggQuantities);
  
              // Find eggs with increased quantities or new items (after restock)
              Object.keys(currentEggQuantities).forEach(eggId => {
                  const oldQuantity = previousEggQuantities[eggId] || 0;
                  const newQuantity = currentEggQuantities[eggId];
  
                  // Always log each egg being processed for debugging (like seeds)
                  productionLog(`üîç [NOTIFICATIONS] Processing egg: ${eggId} (${oldQuantity}‚Üí${newQuantity})`);
  
                  // Determine if we should check for notification
                  const quantityIncreased = newQuantity > oldQuantity;
                  const isRestockWindow = eggRestocked && (now - lastEggRestock) < RESTOCK_COOLDOWN;
                  const alreadyNotifiedInRestock = eggRestockNotifiedItems.has(eggId);
  
                  productionLog(`üîç [NOTIFICATIONS] ${eggId} check logic: quantityIncreased=${quantityIncreased}, isRestockWindow=${isRestockWindow}, alreadyNotifiedInRestock=${alreadyNotifiedInRestock}`);
  
                  // Only trigger notification if:
                  // 1) First run and item is in stock, OR
                  // 2) Quantity increased AND not in restock window, OR
                  // 3) In restock window AND item hasn't been notified in this restock cycle, OR
                  // 4) New item appears (oldQuantity was 0)
                  const shouldCheck = (isFirstRun && newQuantity > 0) || (quantityIncreased && !isRestockWindow) || (isRestockWindow && !alreadyNotifiedInRestock) || (oldQuantity === 0 && newQuantity > 0);
  
                  productionLog(`üîç [NOTIFICATIONS] ${eggId} shouldCheck: ${shouldCheck}`);
  
                  if (shouldCheck) {
                      productionLog(`üÜï [NOTIFICATIONS] Egg stock change: ${eggId} (${oldQuantity}‚Üí${newQuantity}) | Restock: ${eggRestocked} | RestockWindow: ${isRestockWindow}`);
  
                      // Update last seen for ANY egg that appears or increases
                      updateLastSeen(eggId);
  
                      // Check if it's a watched egg with detailed logging
                      const isWatched = isWatchedItem(eggId, 'egg');
                      productionLog(`üîç [NOTIFICATIONS] Is ${eggId} watched? ${isWatched}`);
                      productionLog(`üîç [NOTIFICATIONS] Watched list: [${notifications.watchedEggs.join(', ')}]`);
                      productionLog(`üîç [NOTIFICATIONS] Exact match check:`, notifications.watchedEggs.map(w => ({
                          watched: w,
                          current: eggId,
                          exactMatch: w === eggId,
                          lowerMatch: w.toLowerCase() === eggId.toLowerCase()
                      })));
  
                      if (isWatched) {
                          // Check cooldown (1 minute per item, allow MythicalEgg/CommonEgg for testing)
                          const itemKey = `egg_${eggId}`;
                          const lastNotified = notifications.lastSeenTimestamps[`notified_${itemKey}`] || 0;
                          const canNotify = (now - lastNotified) > NOTIFICATION_COOLDOWN;
  
                          if (canNotify) {
                              productionLog(`üéâ [NOTIFICATIONS] RARE EGG DETECTED: ${eggId} (${newQuantity} in stock)`);
                              notifications.lastSeenTimestamps[`notified_${itemKey}`] = now;
  
                              // Track that we notified this item during restock
                              if (isRestockWindow) {
                                  eggRestockNotifiedItems.add(eggId);
                              }
  
                              MGA_saveJSON('MGA_data', UnifiedState.data);
  
                              // Collect item for batch notification instead of notifying immediately
                              detectedItems.push({
                                  type: 'egg',
                                  id: eggId,
                                  quantity: newQuantity,
                                  icon: 'ü•ö'
                              });
                          } else {
                              productionLog(`‚è∞ [NOTIFICATIONS] ${eggId} on cooldown, not notifying`);
                          }
                      } else {
                          productionLog(`‚ùå [NOTIFICATIONS] ${eggId} is not watched, skipping notification`);
                      }
                  } else {
                      productionLog(`‚è≠Ô∏è [NOTIFICATIONS] ${eggId} shouldCheck=false, skipping`);
                  }
              });
  
              productionLog(`‚úÖ [NOTIFICATIONS] Finished checking all eggs`);
  
                  // Update egg inventory and quantities INSIDE try block
                  // CRITICAL FIX: Create copies instead of reference assignment
                  previousEggInventory = [...currentEggIds];
                  previousEggQuantities = {...currentEggQuantities};
  
              } catch (eggError) {
                  console.error(`‚ùå [NOTIFICATIONS] Error checking eggs:`, eggError);
              }
  
              productionLog(`‚úÖ [NOTIFICATIONS] Finished checking eggs, moving to decor...`);
  
              // Check decor shop (hourly resets)
              let currentDecorIds = [];
              let currentDecorQuantities = {};
  
              try {
                  // Ensure watchedDecor exists (backwards compatibility)
                  if (!notifications.watchedDecor) {
                      notifications.watchedDecor = [];
                  }
  
                  productionLog(`üé® [NOTIFICATIONS] === CHECKING DECOR SHOP ===`);
                  const currentDecor = targetWindow?.globalShop?.shops?.decor?.inventory || [];
                  const inStockDecor = currentDecor.filter(item => item.initialStock > 0);
                  currentDecorIds = inStockDecor.map(item => item.decorId);
  
                  // Always log current decor state for debugging
                  productionLog(`üé® [NOTIFICATIONS] Current decor in shop: [${currentDecorIds.join(', ')}] | Previous: [${previousDecorInventory.join(', ')}]`);
                  productionLog(`üé® [NOTIFICATIONS] Raw decor inventory:`, currentDecor.map(d => `${d.decorId}(stock:${d.initialStock})`));
  
                  // Debug decor shop structure
                  if (currentDecor.length === 0) {
                      productionLog(`üé® [NOTIFICATIONS] No decor found. Shop structure:`, {
                          hasGlobalShop: !!targetWindow?.globalShop,
                          hasShops: !!targetWindow?.globalShop?.shops,
                          hasDecorShop: !!targetWindow?.globalShop?.shops?.decor,
                          hasDecorInventory: !!targetWindow?.globalShop?.shops?.decor?.inventory,
                          decorInventoryLength: targetWindow?.globalShop?.shops?.decor?.inventory?.length || 0
                      });
                  }
  
                  // Track decor quantities
                  inStockDecor.forEach(item => {
                      currentDecorQuantities[item.decorId] = item.initialStock;
                  });
  
                  // Initialize previous quantities if empty (first run)
                  if (Object.keys(previousDecorQuantities).length === 0 && !decorRestocked) {
                      productionLog(`üîß [NOTIFICATIONS] Initializing previous decor quantities...`);
                      Object.keys(currentDecorQuantities).forEach(decorId => {
                          previousDecorQuantities[decorId] = currentDecorQuantities[decorId];
                      });
                  }
  
                  productionLog(`üé® [NOTIFICATIONS] Current decor quantities:`, currentDecorQuantities, `| Previous:`, previousDecorQuantities);
  
                  // Find decor with increased quantities or new items (after restock)
                  Object.keys(currentDecorQuantities).forEach(decorId => {
                      const oldQuantity = previousDecorQuantities[decorId] || 0;
                      const newQuantity = currentDecorQuantities[decorId];
  
                      // Always log each decor being processed for debugging
                      productionLog(`üîç [NOTIFICATIONS] Processing decor: ${decorId} (${oldQuantity}‚Üí${newQuantity})`);
  
                      // Determine if we should check for notification
                      const quantityIncreased = newQuantity > oldQuantity;
                      const isRestockWindow = decorRestocked && (now - lastDecorRestock) < RESTOCK_COOLDOWN;
                      const alreadyNotifiedInRestock = decorRestockNotifiedItems.has(decorId);
  
                      productionLog(`üîç [NOTIFICATIONS] ${decorId} check logic: quantityIncreased=${quantityIncreased}, isRestockWindow=${isRestockWindow}, alreadyNotifiedInRestock=${alreadyNotifiedInRestock}`);
  
                      const shouldCheck = (isFirstRun && newQuantity > 0) || (quantityIncreased && !isRestockWindow) || (isRestockWindow && !alreadyNotifiedInRestock) || (oldQuantity === 0 && newQuantity > 0);
  
                      productionLog(`üîç [NOTIFICATIONS] ${decorId} shouldCheck: ${shouldCheck}`);
  
                      if (shouldCheck) {
                          productionLog(`üÜï [NOTIFICATIONS] Decor stock change: ${decorId} (${oldQuantity}‚Üí${newQuantity}) | Restock: ${decorRestocked} | RestockWindow: ${isRestockWindow}`);
  
                          // Update last seen for ANY decor that appears or increases
                          updateLastSeen(decorId);
  
                          // Check if it's a watched decor item
                          const isWatched = isWatchedItem(decorId, 'decor');
                          productionLog(`üîç [NOTIFICATIONS] Is ${decorId} watched? ${isWatched}`);
                          productionLog(`üîç [NOTIFICATIONS] Watched list: [${notifications.watchedDecor.join(', ')}]`);
  
                          if (isWatched) {
                              // Check cooldown (1 minute per item)
                              const itemKey = `decor_${decorId}`;
                              const lastNotified = notifications.lastSeenTimestamps[`notified_${itemKey}`] || 0;
                              const canNotify = (now - lastNotified) > NOTIFICATION_COOLDOWN;
  
                              if (canNotify) {
                                  productionLog(`üéâ [NOTIFICATIONS] WATCHED DECOR DETECTED: ${decorId} (${newQuantity} in stock)`);
                                  notifications.lastSeenTimestamps[`notified_${itemKey}`] = now;
  
                                  // Track that we notified this item during restock
                                  if (isRestockWindow) {
                                      decorRestockNotifiedItems.add(decorId);
                                  }
  
                                  MGA_saveJSON('MGA_data', UnifiedState.data);
  
                                  // Collect item for batch notification
                                  detectedItems.push({
                                      type: 'decor',
                                      id: decorId,
                                      quantity: newQuantity,
                                      icon: 'üé®'
                                  });
                              } else {
                                  productionLog(`‚è∞ [NOTIFICATIONS] ${decorId} on cooldown, not notifying`);
                              }
                          } else {
                              productionLog(`‚ùå [NOTIFICATIONS] ${decorId} is not watched, skipping notification`);
                          }
                      } else {
                          productionLog(`‚è≠Ô∏è [NOTIFICATIONS] ${decorId} shouldCheck=false, skipping`);
                      }
                  });
  
                  productionLog(`‚úÖ [NOTIFICATIONS] Finished checking all decor`);
  
                  // Update decor inventory and quantities
                  previousDecorInventory = [...currentDecorIds];
                  previousDecorQuantities = {...currentDecorQuantities};
  
              } catch (decorError) {
                  console.error(`‚ùå [NOTIFICATIONS] Error checking decor:`, decorError);
              }
  
              // Process batch notifications if any items were detected
              if (detectedItems.length > 0) {
                  productionLog(`üéâ [NOTIFICATIONS] Batch detected: ${detectedItems.length} items`);

                  // Play notification sound once for all items (custom or default)
                  const volume = UnifiedState.data.settings.notifications.volume || 0.3;
                  playShopNotificationSound(volume);
  
                  // Create notification message based on number of items
                  let notificationMessage;
                  if (detectedItems.length === 1) {
                      const item = detectedItems[0];
                      notificationMessage = `${item.icon} Rare ${item.type} in shop: ${item.id}! (${item.quantity} available)`;
                  } else {
                      notificationMessage = `üéâ Multiple items in stock:\n`;
                      detectedItems.forEach(item => {
                          notificationMessage += `${item.icon} ${item.id} (${item.quantity} available)\n`;
                      });
                  }
  
                  // Queue the batch notification
                  queueNotification(notificationMessage.trim(), notifications.requiresAcknowledgment);
                  productionLog(`üì¢ [NOTIFICATIONS] Batched notification sent for ${detectedItems.length} items`);
              }
  
              // Update previous seed inventory and quantities (seeds already succeeded if we got here)
              // CRITICAL FIX: Create copies instead of reference assignment
              previousSeedInventory = [...currentSeedIds];
              previousSeedQuantities = {...currentSeedQuantities};
  
              // Clear first run flag after first check completes
              if (isFirstRun) {
                  productionLog(`‚úÖ [NOTIFICATIONS] First run complete - will now only notify on changes`);
                  isFirstRun = false;
              }
  
          } catch (error) {
              console.error('‚ùå [NOTIFICATIONS] Error checking for watched items:', error);
              console.error('Stack trace:', error.stack);
              // Don't let errors stop the notification system - it will try again next interval
          }
      }
  
      // ==================== EVENT-DRIVEN SHOP MONITORING ====================
  
      let shopWatcherInitialized = false;
  
      // Pattern-based egg restock detection variables
      let lastEggSeconds = null;
      let eggWasDecreasing = false;
      let refreshDebounceTimer = null;
  
      // Debounced refresh function to prevent multiple rapid refreshes
      function scheduleRefresh(type, shopValue) {
          if (refreshDebounceTimer) {
              clearTimeout(refreshDebounceTimer);
          }
  
          refreshDebounceTimer = setTimeout(() => {
              productionLog(`üîÑ [SHOP-REFRESH] Refreshing ${type} shop after pattern-based restock detection`);
              checkForWatchedItems();
              refreshAllShopWindows();
              refreshDebounceTimer = null;
          }, 100);
      }
  
      function handleEggRestockDetection(curr, shopValue) {
          // first reading
          if (lastEggSeconds === null) {
              lastEggSeconds = curr;
              return;
          }
  
          // detect pattern change
          if (curr < lastEggSeconds) {
              // countdown decreasing normally
              eggWasDecreasing = true;
          } else if (eggWasDecreasing && curr > lastEggSeconds + 2) {
              // countdown started increasing again after decreasing
              productionLog('üê£ Egg restock detected (pattern-based jump)', { curr, lastEggSeconds });
  
              // reset tracker
              eggWasDecreasing = false;
              lastEggSeconds = curr;
  
              // reset local purchase tracking for egg shop
              resetLocalPurchases('egg');
  
              // trigger refresh safely (debounced)
              scheduleRefresh('egg', shopValue);
              return;
          }
  
          // keep tracking
          lastEggSeconds = curr;
      }

      // Tool shop restock detection
      let toolWasDecreasing = false;
      let lastToolSeconds = 0;

      setManagedInterval('toolRestockWatch', () => {
          const toolShop = targetWindow?.globalShop?.shops?.tool;
          if (!toolShop || !toolShop.secondsUntilRestock) return;

          const curr = toolShop.secondsUntilRestock;

          if (curr < lastToolSeconds) {
              toolWasDecreasing = true;
          } else if (toolWasDecreasing && curr > lastToolSeconds + 2) {
              productionLog('üîß Tool restock detected (pattern-based jump)', { curr, lastToolSeconds });
              toolWasDecreasing = false;
              lastToolSeconds = curr;
              resetLocalPurchases('tool');
              scheduleRefresh('tool', toolShop);
          }

          lastToolSeconds = curr;
      }, 1000);

      function initializeShopWatcher() {
          if (shopWatcherInitialized) return;
  
          productionLog('üîÑ [SHOP-WATCHER] Initializing event-driven shop monitoring...');
  
          // Try to find and watch globalShop
          function watchShopData() {
              if (!targetWindow.globalShop) {
                  productionWarn('‚ö†Ô∏è [SHOP-WATCHER] globalShop not found, will retry...');
                  setTimeout(watchShopData, 5000);
                  return;
              }
  
              productionLog('‚úÖ [SHOP-WATCHER] Found globalShop, setting up watchers...');
  
              // Store original shop data
              let lastSeedData = JSON.stringify(targetWindow.globalShop?.shops?.seed || {});
              let lastEggData = JSON.stringify(targetWindow.globalShop?.shops?.egg || {});
              let lastDecorData = JSON.stringify(targetWindow.globalShop?.shops?.decor || {});
  
              // Use lightweight restock detection instead of heavy JSON.stringify
              let lastSeedRestock = 0;
              let lastEggRestock = 0;
              let lastDecorRestock = 0;
  
              setInterval(() => {
                  try {
                      if (!targetWindow.globalShop || !targetWindow.globalShop.shops) return;
  
                      const shops = targetWindow.globalShop.shops;
  
                      // Lightweight check: only compare secondsUntilRestock (resets to high number on restock)
                      if (shops.seed) {
                          const currentRestock = shops.seed.secondsUntilRestock || 0;
                          if (lastSeedRestock > 100 && currentRestock > lastSeedRestock) {
                              // Restock detected (timer reset to high value)
                              productionLog('üîÑ [SHOP-WATCHER] Seed shop restocked');
                              resetLocalPurchases('seed');
                              setTimeout(() => {
                                  checkForWatchedItems();
                                  refreshAllShopWindows();
                              }, 0);
                          }
                          lastSeedRestock = currentRestock;
                      }
  
                      if (shops.egg) {
                          const currentRestock = shops.egg.secondsUntilRestock || 0;
  
                          // Use pattern-based detection for egg shop
                          if (typeof currentRestock === 'number') {
                              handleEggRestockDetection(currentRestock, shops.egg);
                          }
  
                          // Keep the fallback detection too
                          if (lastEggRestock > 100 && currentRestock > lastEggRestock) {
                              productionLog('üîÑ [SHOP-WATCHER] Egg shop restocked (fallback detection)');
                              resetLocalPurchases('egg');
                              setTimeout(() => {
                                  checkForWatchedItems();
                                  refreshAllShopWindows();
                              }, 0);
                          }
                          lastEggRestock = currentRestock;
                      }
  
                      if (shops.decor) {
                          const currentRestock = shops.decor.secondsUntilRestock || 0;
                          if (lastDecorRestock > 100 && currentRestock > lastDecorRestock) {
                              productionLog('üîÑ [SHOP-WATCHER] Decor shop restocked');
                              setTimeout(() => checkForWatchedItems(), 0);
                          }
                          lastDecorRestock = currentRestock;
                      }
                  } catch(e) {
                      // Silent fail
                  }
              }, 5000); // Poll every 5 seconds - lightweight check
  
              productionLog('‚úÖ [SHOP-WATCHER] Using lightweight restock detection (5s interval)');
  
              // Also watch for complete globalShop replacement
              let globalShopDescriptor = Object.getOwnPropertyDescriptor(targetWindow, 'globalShop');
              if (!globalShopDescriptor || globalShopDescriptor.configurable !== false) {
                  Object.defineProperty(targetWindow, 'globalShop', {
                      get() {
                          return this._globalShop;
                      },
                      set(newValue) {
                          productionLog('üîÑ [SHOP-WATCHER] globalShop replaced entirely!');
                          this._globalShop = newValue;
  
                          // Re-initialize watchers for the new shop
                          shopWatcherInitialized = false;
                          setTimeout(() => initializeShopWatcher(), 100);
  
                          // Trigger immediate check
                          setTimeout(() => checkForWatchedItems(), 0);
                      },
                      configurable: true
                  });
  
                  // Set initial value
                  targetWindow._globalShop = targetWindow.globalShop;
                  productionLog('‚úÖ [SHOP-WATCHER] globalShop setter installed');
              }
  
              shopWatcherInitialized = true;
          }
  
          // Start watching
          watchShopData();
  
          // DISABLED: MutationObserver causes severe FPS lag - relying on Proxy and polling only
          // if (typeof MutationObserver !== 'undefined') {
          //     const observer = new MutationObserver((mutations) => {
          //         for (const mutation of mutations) {
          //             if (mutation.target.classList?.contains('shop') ||
          //                 mutation.target.id?.includes('shop') ||
          //                 mutation.target.textContent?.includes('Restock')) {
          //                 productionLog('üîÑ [SHOP-WATCHER] Shop DOM changed, checking items...');
          //                 setTimeout(() => checkForWatchedItems(), 100);
          //                 break;
          //             }
          //         }
          //     });
          //     const gameContainer = targetDocument.querySelector('#game-container, .game-wrapper, body');
          //     if (gameContainer) {
          //         observer.observe(gameContainer, { childList: true, subtree: true, characterData: true });
          //     }
          // }
      }
  
      // ==================== PET HUNGER MONITORING ====================
  
      // Species max hunger values from wiki
      // Source: https://magicgarden.fandom.com/wiki/Pets
      const SPECIES_MAX_HUNGER = {
          'Worm': 500,
          'Snail': 1000,
          'Bee': 1500,
          'Chicken': 3000,
          'Bunny': 750,
          'Dragonfly': 250,
          'Pig': 50000,
          'Cow': 25000,
          'Turtle': 100000,
          'Goat': 20000,
          'Squirrel': 15000,
          'Capybara': 150000,
          'Butterfly': 25000,
          'Peacock': 100000
      };
  
      // Per-species hunger depletion times (milliseconds from full to 0)
      // Source: https://magicgarden.fandom.com/wiki/Pets
      const SPECIES_HUNGER_DEPLETION_TIME = {
          'Worm': 30 * 60 * 1000,
          'Snail': 60 * 60 * 1000,
          'Bee': 15 * 60 * 1000,
          'Chicken': 60 * 60 * 1000,
          'Bunny': 45 * 60 * 1000,
          'Dragonfly': 15 * 60 * 1000,
          'Pig': 60 * 60 * 1000,
          'Cow': 75 * 60 * 1000,
          'Turtle': 90 * 60 * 1000,
          'Goat': 60 * 60 * 1000,
          'Squirrel': 30 * 60 * 1000,
          'Capybara': 60 * 60 * 1000,
          'Butterfly': 30 * 60 * 1000,
          'Peacock': 60 * 60 * 1000
      };
  
      const HUNGER_BOOST_VALUES = {
          'Hunger Boost I': 0.12,   // 12% reduction per 100 STR
          'Hunger Boost II': 0.16   // 16% reduction per 100 STR
      };
  
      // Track previous hunger states for each pet
      let lastPetHungerStates = {};
      let petHungerLastAlertTime = {}; // BUGFIX: Track when we last alerted per pet (timestamp) for time-based throttle
  
      function checkPetHunger() {
          if (!UnifiedState.data.settings.notifications.petHungerEnabled) return;
  
          try {
              // BUGFIX: Use window.activePets which has the REAL atom data with full hunger values
              // UnifiedState.atoms.activePets might be stale or incomplete
              const activePets = window.activePets || UnifiedState.atoms.activePets || [];
              // Threshold is a PERCENTAGE (0-100)
              // Default: 25 = alert when pet drops below 25% full
              const thresholdPercent = UnifiedState.data.settings.notifications.petHungerThreshold || 25;
  
              activePets.forEach((pet) => {
                  if (!pet || !pet.id) return;
  
                  // BUGFIX: Check if hunger data exists before processing
                  const currentHunger = pet.hunger !== undefined ? Number(pet.hunger) : null;
                  if (currentHunger === null || isNaN(currentHunger)) {
                      productionLog(`‚ö†Ô∏è [PET-HUNGER] ${pet.petSpecies || 'Pet'} has no hunger data - skipping`);
                      return; // Skip this pet if no hunger data
                  }
  
                  const petName = pet.petSpecies || 'Pet';
  
                  // BUGFIX: Different species have different max hunger values
                  // Source: https://magicgarden.fandom.com/wiki/Pets
                  // Lower hunger = hungrier (inverse system!)
                  const estimatedMaxHunger = SPECIES_MAX_HUNGER[pet.petSpecies] || 100000;
  
                  // Calculate percentage based on species max
                  const hungerPercent = (currentHunger / estimatedMaxHunger) * 100;
  
                  // Get previous hunger percentage for comparison
                  const lastHunger = lastPetHungerStates[pet.id] ?? currentHunger;
                  const lastPercent = (lastHunger / estimatedMaxHunger) * 100;
  
                  // BUGFIX: Time-based throttle instead of boolean flag to allow re-alerting
                  const ALERT_THROTTLE_MS = 5 * 60 * 1000; // 5 minutes between alerts
                  const now = Date.now();
                  const lastAlertTime = petHungerLastAlertTime[pet.id] || 0;
                  const timeSinceLastAlert = now - lastAlertTime;
  
                  // Debug logging (only when enabled)
                  if (UnifiedState.data.settings?.debugMode) {
                      productionLog(`üêæ [PET-HUNGER-DEBUG] ${petName} (ID: ${pet.id}): ${hungerPercent.toFixed(1)}% (hunger=${currentHunger}/${estimatedMaxHunger}), threshold=${thresholdPercent}%, lastPercent=${lastPercent.toFixed(1)}%, timeSinceLastAlert=${(timeSinceLastAlert/1000).toFixed(0)}s`);
                  }
  
                  // Critical thresholds that alert every 1 minute (more urgent than normal 5 min throttle)
                  const CRITICAL_THROTTLE_MS = 60 * 1000; // 1 minute for critical alerts
                  const isCritical = hungerPercent <= 1;
                  const criticalNeedsAlert = isCritical && (timeSinceLastAlert >= CRITICAL_THROTTLE_MS || !lastAlertTime);
  
                  // Alert if below threshold and enough time has passed since last alert
                  const needsAlert = hungerPercent < thresholdPercent && hungerPercent > 1 &&
                                    (timeSinceLastAlert >= ALERT_THROTTLE_MS || !lastAlertTime);
  
                  // Also alert if hunger DROPPED below threshold since last check (crossing behavior)
                  const justCrossed = hungerPercent < thresholdPercent && lastPercent >= thresholdPercent;
  
                  if (needsAlert || justCrossed || criticalNeedsAlert) {
                      const reason = isCritical ? 'CRITICAL hunger level' :
                                    justCrossed ? 'crossed threshold' :
                                    'below threshold (throttle expired)';
                      productionLog(`üêæ [PET-HUNGER] ${petName} is getting hungry! (${hungerPercent.toFixed(1)}% < ${thresholdPercent}%) - Reason: ${reason}`);
  
                      // Play different sound for pet hunger (custom or default)
                      const volume = UnifiedState.data.settings.notifications.volume || 0.3;
                      playPetNotificationSound(volume);
  
                      // Show visual notification with percentage
                      showNotificationToast(`‚ö†Ô∏è ${petName} needs feeding! Only ${Math.round(hungerPercent)}% full`, 'warning');
  
                      // Update last alert timestamp
                      petHungerLastAlertTime[pet.id] = now;
                  }
  
                  // Reset alert timestamp if pet is fed above threshold (allows immediate alert on next drop)
                  if (hungerPercent >= thresholdPercent && lastAlertTime > 0) {
                      delete petHungerLastAlertTime[pet.id];
                      if (UnifiedState.data.settings?.debugMode) {
                          productionLog(`üêæ [PET-HUNGER-DEBUG] ${petName} fed above threshold, reset alert timer`);
                      }
                  }
  
                  // Store hunger value for next comparison
                  lastPetHungerStates[pet.id] = currentHunger;
              });
          } catch (error) {
              console.error('‚ùå [PET-HUNGER] Error checking pet hunger:', error);
          }
      }
  
      // BUGFIX: Scan all active pets and alert for any currently below threshold
      // This is called when user enables pet hunger alerts
      function scanAndAlertHungryPets() {
          if (!UnifiedState.data.settings.notifications.petHungerEnabled) return;
  
          try {
              // BUGFIX: Use window.activePets which has the REAL atom data with full hunger values
              const activePets = window.activePets || UnifiedState.atoms.activePets || [];
              const thresholdPercent = UnifiedState.data.settings.notifications.petHungerThreshold || 25;
              const MAX_HUNGER = 100000;
              const now = Date.now();
  
              let hungryCount = 0;
  
              activePets.forEach((pet) => {
                  if (!pet || !pet.id) return;
  
                  // BUGFIX: Check if hunger data exists before processing
                  const currentHunger = pet.hunger !== undefined ? Number(pet.hunger) : null;
                  if (currentHunger === null || isNaN(currentHunger)) {
                      productionLog(`‚ö†Ô∏è [PET-HUNGER] ${pet.petSpecies || 'Pet'} has no hunger data in scan - skipping`);
                      return; // Skip this pet if no hunger data
                  }
  
                  // BUGFIX: Different species have different max hunger values
                  // Source: https://magicgarden.fandom.com/wiki/Pets
                  const estimatedMaxHunger = SPECIES_MAX_HUNGER[pet.petSpecies] || 100000;
                  const hungerPercent = (currentHunger / estimatedMaxHunger) * 100;
                  const petName = pet.petSpecies || 'Pet';
  
                  // Alert for any pet currently below threshold
                  if (hungerPercent < thresholdPercent) {
                      hungryCount++;
                      productionLog(`üêæ [PET-HUNGER] Initial scan: ${petName} needs feeding! (${hungerPercent.toFixed(1)}% < ${thresholdPercent}%)`);
  
                      // Show notification for this pet
                      showNotificationToast(`‚ö†Ô∏è ${petName} needs feeding! Only ${Math.round(hungerPercent)}% full`, 'warning');
  
                      // Mark with timestamp to enable time-based throttle
                      petHungerLastAlertTime[pet.id] = now;
                      lastPetHungerStates[pet.id] = currentHunger;
                  }
              });
  
              if (hungryCount > 0) {
                  // Play sound once for all hungry pets (custom or default)
                  const volume = UnifiedState.data.settings.notifications.volume || 0.3;
                  playPetNotificationSound(volume);
                  productionLog(`üêæ [PET-HUNGER] Initial scan found ${hungryCount} hungry pet(s)`);
              } else {
                  productionLog(`üêæ [PET-HUNGER] Initial scan: All pets are well-fed`);
              }
          } catch (error) {
              console.error('‚ùå [PET-HUNGER] Error scanning for hungry pets:', error);
          }
      }
  
      // Calculate time until pet becomes hungry (returns milliseconds)
      function calculateTimeUntilHungry(pet) {
          if (!pet || typeof pet.hunger === 'undefined') return null;
  
          const currentHunger = Number(pet.hunger) || 0;
          const maxHunger = SPECIES_MAX_HUNGER[pet.petSpecies] || 100000;
          const baseDepletionTime = SPECIES_HUNGER_DEPLETION_TIME[pet.petSpecies] || 60 * 60 * 1000;
  
          // If already hungry, return 0
          if (currentHunger <= 0) return 0;
  
          // Calculate total hunger reduction from all pets' Hunger Boost abilities
          let totalHungerReduction = 0;
          const activePets = window.activePets || UnifiedState.atoms.activePets || [];
  
          // DEBUG: Log active pets and their abilities (using console.log to bypass PRODUCTION mode)
          if (UnifiedState.data.settings?.debugMode) {
              console.log('üçñ [HUNGER-CALC] Calculating for pet:', pet.petSpecies);
              console.log('üçñ [HUNGER-CALC] Active pets:', activePets.length);
              activePets.forEach((p, i) => {
                  console.log(`üçñ [HUNGER-CALC] Pet ${i}:`, {
                      species: p.petSpecies,
                      abilities: p.abilities,
                      strength: p.strength,
                      str: p.str
                  });
              });
          }
  
          activePets.forEach(p => {
              if (p.abilities && Array.isArray(p.abilities)) {
                  p.abilities.forEach(ability => {
                      if (UnifiedState.data.settings?.debugMode) {
                          console.log('üçñ [HUNGER-CALC] Checking ability:', ability);
                      }
                      // Ability can be either a string directly or an object with properties
                      const abilityType = typeof ability === 'string' ? ability : (ability.abilityType || ability.type || ability);
                      if (typeof abilityType === 'string') {
                          // Check for both "Hunger Boost" (with space) and "HungerBoost" (without space)
                          if (abilityType.includes('HungerBoost') || abilityType.includes('Hunger Boost')) {
                              // Hunger Boost I = 12% per 100 STR, Hunger Boost II = 16% per 100 STR
                              const reduction = abilityType.includes('II') ? HUNGER_BOOST_VALUES['Hunger Boost II'] : HUNGER_BOOST_VALUES['Hunger Boost I'];
                              const strength = (p.strength || p.str || 100) / 100;
                              totalHungerReduction += reduction * strength;
  
                              if (UnifiedState.data.settings?.debugMode) {
                                  console.log(`üçñ [HUNGER-CALC] Found ${abilityType} on ${p.petSpecies}, STR: ${p.strength || p.str}, reduction: ${reduction}, strength mult: ${strength}`);
                              }
                          }
                      }
                  });
              }
          });
  
          if (UnifiedState.data.settings?.debugMode && totalHungerReduction > 0) {
              console.log(`üçñ [HUNGER-CALC] Total hunger reduction: ${(totalHungerReduction * 100).toFixed(1)}%`);
          }
  
          // Cap reduction at 90% to avoid division by zero
          totalHungerReduction = Math.min(totalHungerReduction, 0.9);
  
          // Calculate time remaining: baseTime / (1 - reductions) * (current/max)
          const timeRemaining = (baseDepletionTime / Math.max(0.1, 1 - totalHungerReduction)) * (currentHunger / maxHunger);
  
          return Math.max(0, Math.round(timeRemaining));
      }
  
      // Format milliseconds as readable timer string (minutes only)
      function formatHungerTimer(milliseconds) {
          if (!milliseconds || milliseconds <= 0) return 'Hungry!';
  
          const totalMinutes = Math.ceil(milliseconds / (60 * 1000));
          return `${totalMinutes}m`;
      }
  
      // Helper function to show toast notifications
      function showNotificationToast(message, type = 'info') {
          try {
              window.devConsoleApi.executeCommand('send-notification', message);
              const toast = document.createElement('div');
              toast.textContent = message;
              toast.style.cssText = `
                  position: fixed;
                  top: 80px;
                  right: 20px;
                  padding: 12px 20px;
                  background: ${type === 'warning' ? 'rgba(255, 165, 0, 0.9)' : type === 'success' ? 'rgba(76, 175, 80, 0.9)' : 'rgba(33, 150, 243, 0.9)'};
                  color: white;
                  border-radius: 8px;
                  font-size: 14px;
                  font-weight: bold;
                  z-index: 2147483647;
                  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                  max-width: 300px;
                  word-wrap: break-word;
                  transition: opacity 0.3s ease;
              `;
  
              document.body.appendChild(toast);
  
              // Fade out and remove after 5 seconds
              setTimeout(() => {
                  toast.style.opacity = '0';
                  setTimeout(() => toast.remove(), 300);
              }, 5000);
          } catch (error) {
              console.error('‚ùå [TOAST] Error showing notification toast:', error);
          }
      }
  
      // ==================== WEATHER EVENT DETECTION ====================
  
      // Weather event tracking
      let lastWeatherState = null;
  
      function detectWeatherEvents() {
          if (!UnifiedState.data.settings.notifications.weatherNotificationsEnabled) return;
  
          try {
              // Check game state for weather (adjust based on actual game structure)
              const roomState = targetWindow?.MagicCircle_RoomConnection?.lastRoomStateJsonable;
              const currentWeather = roomState?.child?.data?.weather || roomState?.weather || null;
  
              if (currentWeather && currentWeather !== lastWeatherState) {
                  const watchedEvents = UnifiedState.data.settings.notifications.watchedWeatherEvents || [];
  
                  // Check if this is a watched weather event
                  const eventMapping = {
                      'snow': 'Snow',
                      'rain': 'Rain',
                      'amber_moon': 'AmberMoon',
                      'ambermoon': 'AmberMoon',
                      'dawn': 'Dawn'
                  };
  
                  const mappedEvent = eventMapping[currentWeather.toLowerCase()] || currentWeather;
  
                  if (watchedEvents.includes(mappedEvent)) {
                      productionLog(`üå§Ô∏è [WEATHER] ${mappedEvent} event detected!`);
  
                      // Play weather notification (custom or default)
                      const volume = UnifiedState.data.settings.notifications.volume || 0.3;
                      playWeatherNotificationSound(volume);
  
                      // Show notification
                      showNotificationToast(`üå§Ô∏è Weather Event: ${mappedEvent}`, 'info');
                  }
  
                  lastWeatherState = currentWeather;
              }
          } catch (error) {
              console.error('‚ùå [WEATHER] Error detecting weather events:', error);
          }
      }
  
      function getProtectTabContent() {
          const lockedCrops = UnifiedState.data.lockedCrops || {};
          const sellThreshold = UnifiedState.data.sellBlockThreshold || 1.0;
  
          return `
              <div class="mga-section">
                  <div class="mga-section-title">üîí Crop Protection</div>
                  <div style="padding: 12px; background: rgba(74, 158, 255, 0.30); border-radius: 6px; border-left: 3px solid #4a9eff; margin-bottom: 16px;">
                      <p style="margin-bottom: 8px; font-size: 13px;"><strong>How it works:</strong></p>
                      <p style="margin-bottom: 4px; font-size: 12px;">‚Ä¢ <strong>Lock crops</strong> to prevent accidental harvesting</p>
                      <p style="margin-bottom: 4px; font-size: 12px;">‚Ä¢ All crops are <strong>unlocked by default</strong></p>
                      <p style="margin-bottom: 4px; font-size: 12px;">‚Ä¢ Locked crops <strong>cannot be harvested</strong> until unlocked</p>
                      <p style="margin-bottom: 4px; font-size: 12px;">‚Ä¢ <strong>Lock All Mutations:</strong> Locks all mutation types at once</p>
                      <p style="margin-bottom: 4px; font-size: 12px;">‚Ä¢ <strong>Lock Only Non-Mutated:</strong> Locks ONLY crops with 0 mutations</p>
                  </div>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">üå± Lock Specific Crops</div>
                  <div style="margin-bottom: 12px;">
                      <label style="display: block; margin-bottom: 8px; font-weight: 600;">Lock by Species:</label>
                      <div id="protect-species-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 8px; margin-bottom: 12px;">
                          <!-- Species checkboxes will be generated here -->
                      </div>
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <label style="display: block; margin-bottom: 8px; font-weight: 600;">Lock by Mutations:</label>
                      <div id="protect-mutations-list" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(120px, 1fr)); gap: 8px; margin-bottom: 12px;">
                          <!-- Mutation checkboxes will be generated here -->
                      </div>
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <button id="protect-clear-all" class="mga-button" style="background: rgba(239, 68, 68, 0.48); border: 1px solid rgba(239, 68, 68, 0.4);">
                          üîì Unlock All Crops
                      </button>
                  </div>

                  <div style="margin-top: 20px; padding: 15px; background: rgba(100, 200, 255, 0.30); border-radius: 8px; border: 1px solid rgba(100,200,255,0.3);">
                      <div style="font-weight: 600; margin-bottom: 10px; color: #64b5f6;">‚Ñó Advanced Settings</div>
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px;">
                          <input type="checkbox" id="allow-frozen-pickup" class="mga-checkbox"
                                 ${UnifiedState.data.protectionSettings?.allowFrozenPickup ? 'checked' : ''}>
                          <span>Allow pickup of protected crops when frozen</span>
                      </label>
                      <div style="font-size: 11px; color: #888; margin-top: 5px; margin-left: 26px;">
                          When enabled, locked Rainbow/Gold crops can still be harvested if they're frozen
                      </div>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üí∞ Sell Protection</div>
                  <div style="margin-bottom: 12px;">
                      <label style="display: block; margin-bottom: 8px; font-weight: 600;">Minimum Friend Bonus to Allow Selling:</label>
                      <div style="display: flex; align-items: center; gap: 12px;">
                          <input type="range" id="protect-sell-threshold" min="1.0" max="1.5" step="0.05" value="${sellThreshold}"
                              style="flex: 1; height: 6px; background: rgba(74,158,255,0.3); border-radius: 3px; outline: none;">
                          <span id="protect-sell-threshold-value" style="min-width: 80px; font-weight: 600; color: #4a9eff;">${sellThreshold.toFixed(2)}x (${((sellThreshold - 1) * 100).toFixed(0)}%)</span>
                      </div>
                      <p style="font-size: 11px; color: #888; margin-top: 8px;">
                          Set to 1.0x to allow selling anytime. Max 1.5x (50% bonus). Higher values require better friend bonus.
                      </p>
                  </div>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">üìã Currently Protected</div>
                  <div id="protect-status-display" style="padding: 12px; background: rgba(0, 0, 0, 0.48); border-radius: 6px; font-size: 12px; min-height: 60px;">
                      <div style="color: #888;">No crops are currently locked.</div>
                  </div>
              </div>
          `;
      }
  
      function getHelpTabContent() {
          return `
              <div class="mga-section">
                  <div class="mga-section-title">üöÄ Getting Started</div>
                  <div style="margin-bottom: 16px;">
                      <p style="margin-bottom: 8px;"><strong>Magic Garden Unified</strong> provides a hybrid dock interface with powerful tools for managing pets, tracking abilities, shop automation, and resource monitoring.</p>
                      <p style="margin-bottom: 8px;">Click dock icons to open sidebars, or Shift+Click to open floating widgets. Drag the dock from its edges to reposition.</p>
                  </div>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">üéõÔ∏è Dock Controls</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Click Icon:</strong> Opens slide-out sidebar</li>
                      <li style="margin-bottom: 4px;"><strong>Shift+Click Icon:</strong> Opens floating popout widget</li>
                      <li style="margin-bottom: 4px;"><strong>Drag from edges:</strong> Reposition the dock (grab cursor appears near edges)</li>
                      <li style="margin-bottom: 4px;"><strong>‚Üî Icon:</strong> Toggle horizontal/vertical orientation</li>
                      <li style="margin-bottom: 4px;"><strong>‚ãØ Icon:</strong> Hover to reveal Tools, Settings, Hotkeys, Notifications, Help</li>
                  </ul>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">‚å®Ô∏è Keyboard Shortcuts</div>
                  <div class="mga-help-grid" style="display: grid; grid-template-columns: auto 1fr; gap: 8px 12px; margin-bottom: 16px;">
                      <code style="background: rgba(74, 158, 255, 0.48); padding: 2px 6px; border-radius: 3px;">Alt+B</code>
                      <span>Toggle Shop (opens/closes both seed and egg sidebars)</span>
                      <code style="background: rgba(74, 158, 255, 0.48); padding: 2px 6px; border-radius: 3px;">Escape</code>
                      <span>Close shop sidebars</span>
                      <code style="background: rgba(74, 158, 255, 0.48); padding: 2px 6px; border-radius: 3px;">Custom</code>
                      <span>Set your own hotkeys for tabs and pet presets in Hotkeys tab (‚å®Ô∏è)</span>
                  </div>
                  <p style="font-size: 11px; color: #888; margin-top: 12px; padding: 8px; background: rgba(255, 200, 100, 0.30); border-radius: 4px; border-left: 3px solid #ffc864;">
                      <strong>‚ö†Ô∏è Note:</strong> Ctrl+1-9 removed to avoid conflicts with game hotbar controls.<br>
                      Use the Hotkeys tab to set custom keys for opening tabs and loading pet presets!
                  </p>
                  <p style="font-size: 11px; color: #888; margin-top: 8px; padding: 8px; background: rgba(74, 158, 255, 0.30); border-radius: 4px; border-left: 3px solid #4a9eff;">
                      <strong>üéÆ Pet Preset Hotkeys:</strong><br>
                      ‚Ä¢ Click "Set Hotkey" button next to any preset<br>
                      ‚Ä¢ Press your desired key combination<br>
                      ‚Ä¢ Hotkey will instantly load that preset when pressed<br>
                      ‚Ä¢ Perfect for quick pet swapping during gameplay!
                  </p>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">üìä Turtle Timer & Slot Value</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Slot Value:</strong> Always shows when standing on crops (üí∞ gold text)</li>
                      <li style="margin-bottom: 4px;"><strong>Turtle Timer:</strong> Green countdown shown when turtle pet is active</li>
                      <li style="margin-bottom: 4px;"><strong>Display Location:</strong> Appears below crop growth timer in-game</li>
                      <li style="margin-bottom: 4px;"><strong>Values:</strong> Calculated from species value √ó scale √ó hybrid multiplier √ó friend bonus</li>
                  </ul>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">üî¥üü¢ Version Indicator</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Green Dot (‚óè):</strong> You're up to date! ‚úì</li>
                      <li style="margin-bottom: 4px;"><strong>Yellow Dot (‚óè):</strong> Development version (newer than GitHub)</li>
                      <li style="margin-bottom: 4px;"><strong>Red Dot (‚óè):</strong> Update available</li>
                      <li style="margin-bottom: 4px;"><strong>Orange Dot (‚óè):</strong> Version check failed (network/404 error)</li>
                      <li style="margin-bottom: 4px;"><strong>Click Dot:</strong> Manually refresh version check (bypasses GitHub cache)</li>
                      <li style="margin-bottom: 4px;"><strong>Shift+Click Dot:</strong> Open script on GitHub (when red/orange)</li>
                      <li style="margin-bottom: 4px;"><strong>Location:</strong> Hover ‚ãØ icon in dock to reveal version dot</li>
                      <li style="margin-bottom: 4px;"><strong>How it works:</strong> Checks GitHub for version.json or magicgardenunified.user.js (tries main/master branches with cache-busting)</li>
                      <li style="margin-bottom: 4px;"><strong>Cache delay:</strong> GitHub CDN caches files ~2-5 min, click dot to force refresh</li>
                  </ul>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">üêæ Pet Management</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Save Presets:</strong> Store your current pet setup with a custom name</li>
                      <li style="margin-bottom: 4px;"><strong>Load Presets:</strong> Quickly deploy saved pet configurations</li>
                      <li style="margin-bottom: 4px;"><strong>Reorder Presets:</strong> Use ‚Üë‚Üì arrows or drag-and-drop to organize your preset list</li>
                  </ul>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">üîí Crop Protection</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Lock Species:</strong> Prevent harvesting specific crop types (e.g., Pepper, Starweaver)</li>
                      <li style="margin-bottom: 4px;"><strong>Lock Mutations:</strong> Block harvesting crops with certain mutations (Rainbow, Frozen)</li>
                      <li style="margin-bottom: 4px;"><strong>All Unlocked by Default:</strong> Crops can be harvested normally until you lock them</li>
                      <li style="margin-bottom: 4px;"><strong>Sell Protection:</strong> Set minimum friend bonus threshold (1.0x-1.5x / 0%-50%) before selling allowed</li>
                      <li style="margin-bottom: 4px;"><strong>Smart Blocking:</strong> Prevents both manual and automated harvesting of locked crops</li>
                      <li style="margin-bottom: 4px;"><strong>Real-time Updates:</strong> Changes take effect immediately without reload</li>
                      <li style="margin-bottom: 4px;"><strong>Status Display:</strong> View all currently protected crops at a glance</li>
                  </ul>
                  <p style="font-size: 11px; color: #888; margin-top: 12px; padding: 8px; background: rgba(74, 158, 255, 0.30); border-radius: 4px; border-left: 3px solid #4a9eff;">
                      <strong>üí° Pro Tip:</strong> Use crop protection to safeguard valuable mutations while auto-harvesting everything else. Set sell protection to 1.5x (50% bonus) to ensure you only sell during maximum friend bonus!
                  </p>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">‚ö° Ability Tracking</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Automatic Logging:</strong> All pet abilities are tracked automatically</li>
                      <li style="margin-bottom: 4px;"><strong>Filter by Category:</strong> View specific types of abilities (XP, Selling, etc.)</li>
                      <li style="margin-bottom: 4px;"><strong>Filter by Pet:</strong> See abilities from specific pet species</li>
                      <li style="margin-bottom: 4px;"><strong>Detailed Timestamps:</strong> Enable to show HH:MM:SS format timestamps</li>
                      <li style="margin-bottom: 4px;"><strong>Export Data:</strong> Download ability logs as CSV for analysis</li>
                  </ul>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">üå± Seeds & Automation</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Mass Deletion:</strong> Select multiple seed types for bulk deletion</li>
                      <li style="margin-bottom: 4px;"><strong>Auto-Delete:</strong> Automatically remove unwanted seeds as they appear</li>
                      <li style="margin-bottom: 4px;"><strong>Value Calculation:</strong> See total value of selected seeds before deletion</li>
                      <li style="margin-bottom: 4px;"><strong>Quick Selection:</strong> Use preset buttons for common seed types</li>
                  </ul>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">üõí Shop Interface</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Dual Sidebars:</strong> Seeds on left, eggs on right (both open together)</li>
                      <li style="margin-bottom: 4px;"><strong>Color-Coded Names:</strong> Item rarity shown by text color (rainbow for celestial)</li>
                      <li style="margin-bottom: 4px;"><strong>Auto-Restock Detection:</strong> Purchase tracking resets when shop restocks</li>
                      <li style="margin-bottom: 4px;"><strong>Sort & Filter:</strong> Show available only, sort by value</li>
                      <li style="margin-bottom: 4px;"><strong>Quick Purchase:</strong> Buy 1 or All buttons for each item</li>
                  </ul>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">üîî Notifications</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Shop Monitoring:</strong> Get alerts when rare seeds/eggs appear</li>
                      <li style="margin-bottom: 4px;"><strong>Multiple Notifications:</strong> Single click dismisses all pending alerts</li>
                      <li style="margin-bottom: 4px;"><strong>Continuous Mode:</strong> Must be enabled via checkbox for persistent alerts</li>
                      <li style="margin-bottom: 4px;"><strong>Sound Types:</strong> Choose from beep, alarm, fanfare, or continuous alerts</li>
                  </ul>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">üé® Customization</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Themes:</strong> Switch between normal, dark, and other visual themes</li>
                      <li style="margin-bottom: 4px;"><strong>Compact Modes:</strong> Use compact or ultra-compact layouts to save space</li>
                      <li style="margin-bottom: 4px;"><strong>Overlays:</strong> Pop out tabs into separate in-game overlays</li>
                      <li style="margin-bottom: 4px;"><strong>Crop Highlighting:</strong> Visually highlight specific crops in your garden</li>
                  </ul>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">‚ùì Troubleshooting</div>
                  <ul style="margin-left: 16px; margin-bottom: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Crop Highlighting Not Working:</strong> Ensure the game is fully loaded before using highlighting</li>
                      <li style="margin-bottom: 4px;"><strong>Notifications Not Playing:</strong> Check volume settings and browser audio permissions</li>
                      <li style="margin-bottom: 4px;"><strong>Pet Presets Not Saving:</strong> Wait for success confirmation before switching tabs</li>
                      <li style="margin-bottom: 4px;"><strong>Performance Issues:</strong> Try compact mode or disable debug logging in settings</li>
                  </ul>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">üí° Tips & Best Practices</div>
                  <ul style="margin-left: 16px;">
                      <li style="margin-bottom: 4px;"><strong>Regular Backups:</strong> Export ability logs periodically for data safety</li>
                      <li style="margin-bottom: 4px;"><strong>Preset Organization:</strong> Use descriptive names and reorder presets by frequency of use</li>
                      <li style="margin-bottom: 4px;"><strong>Notification Management:</strong> Enable continuous mode only for critical alerts</li>
                      <li style="margin-bottom: 4px;"><strong>Resource Monitoring:</strong> Use the Values tab to track inventory and garden worth</li>
                  </ul>
              </div>
          `;
      }
  
      function getHotkeysTabContent() {
          const hotkeys = UnifiedState.data.hotkeys;
          let currentlyRecording = null;
  
          return `
              <div class="mga-section">
                  <div class="mga-section-title">üéÆ Custom Hotkeys</div>
                  <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                      Click any key button to set a custom keybind. Press ESC to cancel.
                  </p>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px;">
                          <input type="checkbox" id="hotkeys-enabled" class="mga-checkbox"
                                 ${hotkeys.enabled ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>Enable custom hotkeys</span>
                      </label>
                  </div>
  
                  <div class="mga-section">
                      <div class="mga-section-title" style="font-size: 13px;">Game Controls</div>
                      ${Object.entries(hotkeys.gameKeys).map(([key, config]) => `
                          <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px; padding: 5px; background: rgba(255, 255, 255, 0.05); border-radius: 4px;">
                              <span style="font-size: 12px; flex: 1;">${config.name}</span>
                              <button class="hotkey-button" data-key="${key}" style="
                                  padding: 4px 8px;
                                  background: ${config.custom ? 'rgba(100, 255, 100, 0.48)' : 'rgba(74, 158, 255, 0.48)'};
                                  border: 1px solid ${config.custom ? '#64ff64' : '#4a9eff'};
                                  border-radius: 4px;
                                  color: white;
                                  font-size: 11px;
                                  min-width: 80px;
                                  cursor: pointer;
                              ">
                                  ${config.custom ? `${config.original.toUpperCase()} ‚Üí ${config.custom.toUpperCase()}` : config.original.toUpperCase()}
                              </button>
                              ${config.custom ? `
                                  <button class="hotkey-reset" data-key="${key}" style="
                                      margin-left: 5px;
                                      padding: 2px 6px;
                                      background: rgba(255, 100, 100, 0.48);
                                      border: 1px solid #ff6464;
                                      border-radius: 3px;
                                      color: white;
                                      font-size: 10px;
                                      cursor: pointer;
                                  ">‚Ü∫</button>
                              ` : ''}
                          </div>
                      `).join('')}
                  </div>
  
                  <div style="display: flex; gap: 10px; margin-top: 15px;">
                      <button id="hotkeys-reset-all" class="mga-button" style="flex: 1;">
                          Reset All
                      </button>
                      <button id="hotkeys-export" class="mga-button" style="flex: 1;">
                          Export Config
                      </button>
                  </div>
              </div>
          `;
      }
  
      function getNotificationsTabContent() {
          const settings = UnifiedState.data.settings;
  
          // Ensure new notification properties exist (for backwards compatibility with old saved data)
          if (!settings.notifications.petHungerEnabled && settings.notifications.petHungerEnabled !== false) {
              settings.notifications.petHungerEnabled = false;
          }
          if (!settings.notifications.petHungerThreshold) {
              settings.notifications.petHungerThreshold = 20;
          }
          if (!settings.notifications.abilityNotificationsEnabled && settings.notifications.abilityNotificationsEnabled !== false) {
              settings.notifications.abilityNotificationsEnabled = false;
          }
          if (!settings.notifications.watchedAbilities) {
              settings.notifications.watchedAbilities = [];
          }
          if (!settings.notifications.watchedAbilityCategories) {
              settings.notifications.watchedAbilityCategories = {
                  xpBoost: true,
                  cropSizeBoost: true,
                  selling: true,
                  harvesting: true,
                  growthSpeed: true,
                  specialMutations: true,
                  other: true
              };
          }
          if (!settings.notifications.weatherNotificationsEnabled && settings.notifications.weatherNotificationsEnabled !== false) {
              settings.notifications.weatherNotificationsEnabled = false;
          }
          if (!settings.notifications.watchedDecor) {
              settings.notifications.watchedDecor = [];
          }
          if (!settings.notifications.watchedWeatherEvents) {
              settings.notifications.watchedWeatherEvents = ['Snow', 'Rain', 'AmberMoon', 'Dawn'];
          }
          if (!settings.notifications.abilityNotificationSound) {
              settings.notifications.abilityNotificationSound = 'single';
          }
          if (settings.notifications.abilityNotificationVolume === undefined) {
              settings.notifications.abilityNotificationVolume = 0.2;
          }
          // Ensure continuousEnabled is explicitly false if undefined
          if (settings.notifications.continuousEnabled === undefined || settings.notifications.continuousEnabled === null) {
              settings.notifications.continuousEnabled = false;
          }
          // Ensure debugMode exists
          if (settings.debugMode === undefined) {
              settings.debugMode = false;
          }
  
          return `
              <div class="mga-section">
                  <div class="mga-section-title">üîî Shop Alert Notifications</div>
                  <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                      Get audio and visual alerts when rare seeds or eggs appear in the shop.
                  </p>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="notifications-enabled-checkbox" class="mga-checkbox"
                                 ${settings.notifications.enabled ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üîä Enable Notifications</span>
                      </label>
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <button id="notification-quick-toggle" class="mga-button" style="padding: 8px 16px; background: ${settings.notifications.enabled ? '#4a9eff' : '#666'}; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 14px;">
                          ${settings.notifications.enabled ? 'üîä Turn OFF Notifications' : 'üîá Turn ON Notifications'}
                      </button>
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Volume: ${Math.round(settings.notifications.volume * 100)}%
                      </label>
                      <input type="range" class="mga-slider" id="notification-volume-slider"
                             min="0" max="100" value="${settings.notifications.volume * 100}"
                             style="width: 100%; accent-color: #4a9eff;">
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="notification-continuous-checkbox" class="mga-checkbox"
                                 ${settings.notifications.continuousEnabled ? 'checked' : ''}
                                 style="accent-color: #ff9900;">
                          <span>‚ö†Ô∏è Enable Continuous Mode</span>
                      </label>
                      <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                          Allows selection of continuous notification type that plays until acknowledged.
                      </p>
                  </div>
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Notification Sound Type
                      </label>
                      <select class="mga-select" id="notification-type-select">
                          <option value="simple" ${settings.notifications.notificationType === 'simple' ? 'selected' : ''}>üîä Simple Beep</option>
                          <option value="triple" ${settings.notifications.notificationType === 'triple' ? 'selected' : ''}>üîî Triple Beep</option>
                          <option value="alarm" ${settings.notifications.notificationType === 'alarm' ? 'selected' : ''}>üö® Alarm Siren</option>
                          <option value="epic" ${settings.notifications.notificationType === 'epic' ? 'selected' : ''}>üéµ Epic Fanfare</option>
                          <option value="continuous" ${settings.notifications.notificationType === 'continuous' ? 'selected' : ''} ${!settings.notifications.continuousEnabled ? 'disabled' : ''}>‚ö†Ô∏è Continuous (Until Acknowledged)</option>
                      </select>
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="notification-acknowledgment-checkbox" class="mga-checkbox"
                                 ${settings.notifications.requiresAcknowledgment ? 'checked' : ''}
                                 style="accent-color: #ff4444;">
                          <span>üö® Require acknowledgment (persistent alert)</span>
                      </label>
                      <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                          When enabled, notifications will show a modal that must be clicked to dismiss.
                      </p>
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <button class="mga-btn mga-btn-sm" id="test-notification-btn" style="background: #4a5568;">
                          üîî Test Notification
                      </button>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üéµ Custom Notification Sounds</div>
                  <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                      Upload your own .mp3/.wav/.ogg files to replace default beep sounds. Max 2MB per file.
                  </p>

                  <div id="custom-sounds-container" style="display: grid; gap: 12px;">
                      <!-- Custom sound upload controls will be populated by setupNotificationsTabHandlers -->
                  </div>
              </div>

              <div class="mga-section">
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px;">
                          Watched Seeds
                      </label>
                      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 4px;">
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-carrot" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Carrot') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>ü•ï Carrot</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-strawberry" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Strawberry') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üçì Strawberry</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-aloe" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Aloe') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåø Aloe</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-blueberry" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Blueberry') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>ü´ê Blueberry</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-apple" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Apple') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üçé Apple</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-tulip" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Tulip') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üå∑ Tulip</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-tomato" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Tomato') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üçÖ Tomato</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-daffodil" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Daffodil') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåº Daffodil</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-corn" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Corn') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåΩ Corn</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-watermelon" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Watermelon') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üçâ Watermelon</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-pumpkin" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Pumpkin') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üéÉ Pumpkin</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-echeveria" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Echeveria') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>ü™¥ Echeveria</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-coconut" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Coconut') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>ü•• Coconut</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-banana" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Banana') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üçå Banana</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-lily" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Lily') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üå∫ Lily</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-burrostail" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('BurrosTail') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üå± Burro's Tail</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-mushroom" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Mushroom') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üçÑ Mushroom</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-cactus" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Cactus') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåµ Cactus</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-bamboo" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Bamboo') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üéã Bamboo</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-grape" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Grape') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üçá Grape</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-pepper" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Pepper') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üå∂Ô∏è Pepper</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-lemon" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Lemon') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üçã Lemon</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-passionfruit" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('PassionFruit') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üß° PassionFruit</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-dragonfruit" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('DragonFruit') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üêâ DragonFruit</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-lychee" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Lychee') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üçá Lychee</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-sunflower" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Sunflower') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåª Sunflower</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-starweaver" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Starweaver') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>‚≠ê Starweaver</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-dawnbinder" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Dawnbinder') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåÖ Dawnbinder</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-moonbinder" class="mga-checkbox"
                                     ${settings.notifications.watchedSeeds.includes('Moonbinder') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåô Moonbinder</span>
                          </label>
                      </div>
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px;">
                          Watched Eggs
                      </label>
                      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 4px;">
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-common-egg" class="mga-checkbox"
                                     ${settings.notifications.watchedEggs.includes('CommonEgg') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>ü•ö Common Egg</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-uncommon-egg" class="mga-checkbox"
                                     ${settings.notifications.watchedEggs.includes('UncommonEgg') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>ü•ö Uncommon Egg</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-rare-egg" class="mga-checkbox"
                                     ${settings.notifications.watchedEggs.includes('RareEgg') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>ü•ö Rare Egg</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-legendary-egg" class="mga-checkbox"
                                     ${settings.notifications.watchedEggs.includes('LegendaryEgg') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>ü•ö Legendary Egg</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-mythical-egg" class="mga-checkbox"
                                     ${settings.notifications.watchedEggs.includes('MythicalEgg') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>ü•ö‚ú® Mythical Egg</span>
                          </label>
                      </div>
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px;">
                          Watched Decor (Hourly Shop)
                      </label>
                      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 4px;">
                          ${DECOR_ITEMS.map(decor => `
                              <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                                  <input type="checkbox" id="watch-decor-${decor.id.toLowerCase()}" class="mga-checkbox"
                                         ${settings.notifications.watchedDecor.includes(decor.id) ? 'checked' : ''}
                                         style="accent-color: #4a9eff; transform: scale(0.8);">
                                  <span>üé® ${decor.name}</span>
                              </label>
                          `).join('')}
                      </div>
                  </div>
  
                  <div style="margin-bottom: 12px; padding: 10px; background: rgba(255,255,255,0.15); border-radius: 4px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px; font-size: 12px;">
                          Last Seen
                      </label>
                      <div id="last-seen-display" style="font-size: 11px; color: #888; line-height: 1.3;">
                          Loading...
                      </div>
                  </div>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">üêæ Pet Hunger Alerts</div>
                  <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                      Get notified when your pets' hunger drops below a threshold.
                  </p>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="pet-hunger-enabled" class="mga-checkbox"
                                 ${settings.notifications.petHungerEnabled ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üîä Enable Pet Hunger Notifications</span>
                      </label>
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Alert when hunger below: ${settings.notifications.petHungerThreshold || 20}%
                      </label>
                      <input type="range" class="mga-slider" id="pet-hunger-threshold"
                             min="5" max="50" step="5" value="${settings.notifications.petHungerThreshold || 20}"
                             style="width: 100%; accent-color: #ff9900;">
                  </div>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">‚ú® Ability Trigger Alerts</div>
                  <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                      Get notified when your pets trigger abilities. Leave all unchecked to be notified for all abilities.
                  </p>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="ability-notifications-enabled" class="mga-checkbox"
                                 ${settings.notifications.abilityNotificationsEnabled ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üîä Enable Ability Notifications</span>
                      </label>
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Ability Sound Type
                      </label>
                      <select class="mga-select" id="ability-notification-sound-select"
                              style="width: 100%; padding: 8px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255, 255, 255, 0.57); border-radius: 4px; color: white; font-size: 12px;">
                          <option value="single" ${settings.notifications.abilityNotificationSound === 'single' ? 'selected' : ''}>üîä Single Beep (Subtle)</option>
                          <option value="double" ${settings.notifications.abilityNotificationSound === 'double' ? 'selected' : ''}>üîî Double Beep</option>
                          <option value="triple" ${settings.notifications.abilityNotificationSound === 'triple' ? 'selected' : ''}>üéµ Triple Beep</option>
                          <option value="chime" ${settings.notifications.abilityNotificationSound === 'chime' ? 'selected' : ''}>üéê Chime (Pleasant)</option>
                          <option value="alert" ${settings.notifications.abilityNotificationSound === 'alert' ? 'selected' : ''}>üö® Alert (Urgent)</option>
                          <option value="buzz" ${settings.notifications.abilityNotificationSound === 'buzz' ? 'selected' : ''}>üì≥ Buzz (Energetic)</option>
                          <option value="ding" ${settings.notifications.abilityNotificationSound === 'ding' ? 'selected' : ''}>üîî Ding (Clear)</option>
                          <option value="chirp" ${settings.notifications.abilityNotificationSound === 'chirp' ? 'selected' : ''}>üê¶ Chirp (Cute)</option>
                      </select>
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Ability Alert Volume: ${Math.round((settings.notifications.abilityNotificationVolume || 0.2) * 100)}%
                      </label>
                      <input type="range" class="mga-slider" id="ability-notification-volume-slider"
                             min="0" max="100" value="${(settings.notifications.abilityNotificationVolume || 0.2) * 100}"
                             style="width: 100%; accent-color: #9f7aea;">
                  </div>
  
                  <div style="margin-bottom: 16px; padding-top: 12px; border-top: 1px solid rgba(255, 255, 255, 0.57);">
                      <label class="mga-label" style="display: block; margin-bottom: 8px; font-weight: 600;">
                          üìã Which Abilities to Notify For
                      </label>
                      <p style="font-size: 11px; color: #888; margin-bottom: 8px;">
                          Select individual abilities that will trigger notifications. All abilities start enabled by default.
                      </p>
  
                      <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                          <button id="select-all-individual-abilities" class="mga-btn mga-btn-secondary" style="flex: 1; padding: 6px; font-size: 11px;">Select All</button>
                          <button id="select-none-individual-abilities" class="mga-btn mga-btn-secondary" style="flex: 1; padding: 6px; font-size: 11px;">Select None</button>
                      </div>
  
                      <input type="text" id="ability-search-box" placeholder="üîç Search abilities..."
                             style="width: 100%; padding: 8px; margin-bottom: 12px; background: rgba(255,255,255,0.15); border: 1px solid rgba(255, 255, 255, 0.57); border-radius: 4px; color: #fff; font-size: 12px;">
  
                      <div id="individual-abilities-notification-list" style="display: grid; grid-template-columns: 1fr; gap: 4px; max-height: 400px; overflow-y: auto; padding: 4px;">
                          ${(() => {
                              // Comprehensive list of all abilities organized by category
                              const abilities = [
                                  // XP Boosts
                                  { name: 'XP Boost I', category: 'üí´ XP Boosts' },
                                  { name: 'XP Boost II', category: 'üí´ XP Boosts' },
                                  { name: 'XP Boost III', category: 'üí´ XP Boosts' },
                                  { name: 'XP Boost IV', category: 'üí´ XP Boosts' },
                                  { name: 'Hatch XP Boost', category: 'üí´ XP Boosts' },
                                  // Crop Size Boosts (only I and II exist in game)
                                  { name: 'Crop Size Boost I', category: 'üìà Crop Size Boosts' },
                                  { name: 'Crop Size Boost II', category: 'üìà Crop Size Boosts' },
                                  // Selling
                                  { name: 'Sell Boost I', category: 'üí∞ Selling' },
                                  { name: 'Sell Boost II', category: 'üí∞ Selling' },
                                  { name: 'Sell Boost III', category: 'üí∞ Selling' },
                                  { name: 'Sell Boost IV', category: 'üí∞ Selling' },
                                  { name: 'Selling Refund', category: 'üí∞ Selling' },
                                  // Harvesting
                                  { name: 'Double Harvest', category: 'üåæ Harvesting' },
                                  // Growth Speed
                                  { name: 'Plant Growth Boost I', category: 'üê¢ Growth Speed' },
                                  { name: 'Plant Growth Boost II', category: 'üê¢ Growth Speed' },
                                  { name: 'Plant Growth Boost III', category: 'üê¢ Growth Speed' },
                                  // Special Mutations
                                  { name: 'Rainbow Mutation', category: 'üåà Special' },
                                  { name: 'Gold Mutation', category: 'üåà Special' },
                                  // Other
                                  { name: 'Seed Finder I', category: 'üîß Other' },
                                  { name: 'Seed Finder II', category: 'üîß Other' },
                                  { name: 'Hunger Boost I', category: 'üîß Other' },
                                  { name: 'Hunger Boost II', category: 'üîß Other' },
                                  { name: 'Max Strength Boost I', category: 'üîß Other' },
                                  { name: 'Max Strength Boost II', category: 'üîß Other' },
                                  { name: 'Crop Eater', category: 'üîß Other' }
                              ];
  
                              const watchedAbilities = settings.notifications.watchedAbilities || [];
  
                              // Group abilities by category
                              const grouped = {};
                              abilities.forEach(ability => {
                                  if (!grouped[ability.category]) grouped[ability.category] = [];
                                  grouped[ability.category].push(ability.name);
                              });
  
                              let html = '';
                              Object.keys(grouped).sort().forEach(category => {
                                  html += `<div class="ability-category-group" style="margin-bottom: 8px;">
                                      <div style="font-size: 11px; font-weight: 600; color: #aaa; margin-bottom: 4px; padding: 4px 8px; background: rgba(255,255,255,0.03); border-radius: 4px;">${category}</div>`;
  
                                  grouped[category].forEach(abilityName => {
                                      const isChecked = watchedAbilities.length === 0 || watchedAbilities.includes(abilityName);
                                      html += `
                                          <label class="mga-checkbox-group ability-checkbox-item" data-ability="${abilityName}" style="display: flex; align-items: center; gap: 8px; padding: 6px 12px; cursor: pointer; transition: background 0.2s; border-radius: 4px;">
                                              <input type="checkbox"
                                                     class="mga-checkbox individual-ability-checkbox"
                                                     data-ability-name="${abilityName}"
                                                     ${isChecked ? 'checked' : ''}
                                                     style="accent-color: #4a9eff;">
                                              <span style="font-size: 11px; color: #ddd;">${abilityName}</span>
                                          </label>`;
                                  });
                                  html += '</div>';
                              });
  
                              return html;
                          })()}
                      </div>
                  </div>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">üå§Ô∏è Weather Event Alerts</div>
                  <p style="font-size: 11px; color: #aaa; margin-bottom: 12px;">
                      Get notified when weather events occur in the game.
                  </p>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="weather-notifications-enabled" class="mga-checkbox"
                                 ${settings.notifications.weatherNotificationsEnabled ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üîä Enable Weather Notifications</span>
                      </label>
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px;">
                          Watched Weather Events
                      </label>
                      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 4px;">
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-snow" class="mga-checkbox"
                                     ${settings.notifications.watchedWeatherEvents.includes('Snow') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>‚ùÑÔ∏è Snow</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-rain" class="mga-checkbox"
                                     ${settings.notifications.watchedWeatherEvents.includes('Rain') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåßÔ∏è Rain</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-amber-moon" class="mga-checkbox"
                                     ${settings.notifications.watchedWeatherEvents.includes('AmberMoon') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåô Amber Moon</span>
                          </label>
                          <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 4px; font-size: 12px;">
                              <input type="checkbox" id="watch-dawn" class="mga-checkbox"
                                     ${settings.notifications.watchedWeatherEvents.includes('Dawn') ? 'checked' : ''}
                                     style="accent-color: #4a9eff; transform: scale(0.8);">
                              <span>üåÖ Dawn</span>
                          </label>
                      </div>
                  </div>
              </div>
          `;
      }
  
      function getSettingsTabContent() {
          const settings = UnifiedState.data.settings;
  
          return `
              <div class="mga-section">
                  <div class="mga-section-title">Appearance</div>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Main HUD Opacity: ${settings.opacity}%
                      </label>
                      <input type="range" class="mga-slider" id="opacity-slider"
                             min="0" max="100" value="${settings.opacity}"
                             style="width: 100%; accent-color: #4a9eff;">
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 4px;">
                          Pop-out Opacity: ${settings.popoutOpacity}%
                      </label>
                      <input type="range" class="mga-slider" id="popout-opacity-slider"
                             min="0" max="100" value="${settings.popoutOpacity}"
                             style="width: 100%; accent-color: #4a9eff;">
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px;">
                          Gradient Style
                      </label>
                      <select class="mga-select" id="gradient-select" style="margin-bottom: 8px;">
                          <optgroup label="‚ö´ Black Accent Themes">
                              <option value="black-crimson" ${settings.gradientStyle === 'black-crimson' ? 'selected' : ''}>‚ö´üî¥ Midnight Crimson</option>
                              <option value="black-emerald" ${settings.gradientStyle === 'black-emerald' ? 'selected' : ''}>‚ö´üíö Shadow Emerald</option>
                              <option value="black-royal" ${settings.gradientStyle === 'black-royal' ? 'selected' : ''}>‚ö´üíú Void Royal</option>
                              <option value="black-gold" ${settings.gradientStyle === 'black-gold' ? 'selected' : ''}>‚ö´üíõ Obsidian Gold</option>
                              <option value="black-ice" ${settings.gradientStyle === 'black-ice' ? 'selected' : ''}>‚ö´üíô Carbon Ice</option>
                              <option value="black-flame" ${settings.gradientStyle === 'black-flame' ? 'selected' : ''}>‚ö´üß° Inferno Black</option>
                              <option value="black-toxic" ${settings.gradientStyle === 'black-toxic' ? 'selected' : ''}>‚ö´‚ò¢Ô∏è Toxic Shadow</option>
                              <option value="black-pink" ${settings.gradientStyle === 'black-pink' ? 'selected' : ''}>‚ö´üíó Noir Pink</option>
                              <option value="black-matrix" ${settings.gradientStyle === 'black-matrix' ? 'selected' : ''}>‚ö´üü¢ Matrix Black</option>
                              <option value="black-sunset" ${settings.gradientStyle === 'black-sunset' ? 'selected' : ''}>‚ö´üåÖ Eclipse Sunset</option>
                              <option value="black-blood" ${settings.gradientStyle === 'black-blood' ? 'selected' : ''}>‚ö´ü©∏ Midnight Blood</option>
                              <option value="black-neon" ${settings.gradientStyle === 'black-neon' ? 'selected' : ''}>‚ö´‚ö° Shadow Neon</option>
                              <option value="black-storm" ${settings.gradientStyle === 'black-storm' ? 'selected' : ''}>‚ö´‚õàÔ∏è Obsidian Storm</option>
                              <option value="black-sapphire" ${settings.gradientStyle === 'black-sapphire' ? 'selected' : ''}>‚ö´üí† Void Sapphire</option>
                              <option value="black-aqua" ${settings.gradientStyle === 'black-aqua' ? 'selected' : ''}>‚ö´üåä Dark Aqua</option>
                              <option value="black-phantom" ${settings.gradientStyle === 'black-phantom' ? 'selected' : ''}>‚ö´ü™ô Phantom Silver</option>
                          </optgroup>
                          <optgroup label="üåà Classic Themes">
                              <option value="blue-purple" ${settings.gradientStyle === 'blue-purple' ? 'selected' : ''}>üåå Blue-Purple</option>
                              <option value="green-blue" ${settings.gradientStyle === 'green-blue' ? 'selected' : ''}>üåä Green-Blue</option>
                              <option value="red-orange" ${settings.gradientStyle === 'red-orange' ? 'selected' : ''}>üî• Red-Orange</option>
                              <option value="purple-pink" ${settings.gradientStyle === 'purple-pink' ? 'selected' : ''}>üíú Purple-Pink</option>
                              <option value="gold-yellow" ${settings.gradientStyle === 'gold-yellow' ? 'selected' : ''}>üëë Gold-Yellow</option>
                          </optgroup>
                          <optgroup label="‚ú® Vibrant Themes">
                              <option value="electric-neon" ${settings.gradientStyle === 'electric-neon' ? 'selected' : ''}>‚ö° Electric Neon</option>
                              <option value="sunset-fire" ${settings.gradientStyle === 'sunset-fire' ? 'selected' : ''}>üåÖ Sunset Fire</option>
                              <option value="emerald-cyan" ${settings.gradientStyle === 'emerald-cyan' ? 'selected' : ''}>üíé Emerald Cyan</option>
                              <option value="royal-gold" ${settings.gradientStyle === 'royal-gold' ? 'selected' : ''}>üèÜ Royal Gold</option>
                              <option value="crimson-blaze" ${settings.gradientStyle === 'crimson-blaze' ? 'selected' : ''}>üî• Crimson Blaze</option>
                              <option value="ocean-deep" ${settings.gradientStyle === 'ocean-deep' ? 'selected' : ''}>üåä Ocean Deep</option>
                              <option value="forest-mystique" ${settings.gradientStyle === 'forest-mystique' ? 'selected' : ''}>üå≤ Forest Mystique</option>
                              <option value="cosmic-purple" ${settings.gradientStyle === 'cosmic-purple' ? 'selected' : ''}>üåå Cosmic Purple</option>
                              <option value="rainbow-burst" ${settings.gradientStyle === 'rainbow-burst' ? 'selected' : ''}>üåà Rainbow Burst</option>
                          </optgroup>
                          <optgroup label="üõ°Ô∏è Metallic Themes">
                              <option value="steel-blue" ${settings.gradientStyle === 'steel-blue' ? 'selected' : ''}>üõ°Ô∏è Steel Blue</option>
                              <option value="chrome-silver" ${settings.gradientStyle === 'chrome-silver' ? 'selected' : ''}>‚ö™ Chrome Silver</option>
                              <option value="titanium-gray" ${settings.gradientStyle === 'titanium-gray' ? 'selected' : ''}>üå´Ô∏è Titanium Gray</option>
                              <option value="platinum-white" ${settings.gradientStyle === 'platinum-white' ? 'selected' : ''}>üíç Platinum White</option>
                          </optgroup>
                      </select>
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px;">
                          Effect Style
                      </label>
                      <select class="mga-select" id="effect-select">
                          <option value="none" ${settings.effectStyle === 'none' ? 'selected' : ''}>‚ú® None</option>
                          <option value="metallic" ${settings.effectStyle === 'metallic' ? 'selected' : ''}>‚ö° Metallic</option>
                          <option value="glass" ${settings.effectStyle === 'glass' ? 'selected' : ''}>üíé Glass</option>
                          <option value="neon" ${settings.effectStyle === 'neon' ? 'selected' : ''}>üåü Neon Glow</option>
                          <option value="plasma" ${settings.effectStyle === 'plasma' ? 'selected' : ''}>üî• Plasma</option>
                          <option value="aurora" ${settings.effectStyle === 'aurora' ? 'selected' : ''}>üåå Aurora</option>
                          <option value="crystal" ${settings.effectStyle === 'crystal' ? 'selected' : ''}>üí† Crystal</option>
                          <option value="steel" ${settings.effectStyle === 'steel' ? 'selected' : ''}>üõ°Ô∏è Steel</option>
                          <option value="chrome" ${settings.effectStyle === 'chrome' ? 'selected' : ''}>‚ö™ Chrome</option>
                          <option value="titanium" ${settings.effectStyle === 'titanium' ? 'selected' : ''}>üå´Ô∏è Titanium</option>
                      </select>
                  </div>

                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px;">
                          Texture Overlay
                      </label>
                      <select class="mga-select" id="texture-select">
                          <option value="none" ${settings.textureStyle === 'none' || !settings.textureStyle ? 'selected' : ''}>üö´ None</option>

                          <optgroup label="üåü Modern Glass">
                              <option value="frosted-glass" ${settings.textureStyle === 'frosted-glass' ? 'selected' : ''}>‚ùÑÔ∏è Frosted Glass</option>
                              <option value="crystal-prism" ${settings.textureStyle === 'crystal-prism' ? 'selected' : ''}>üíé Crystal Prism</option>
                              <option value="ice-frost" ${settings.textureStyle === 'ice-frost' ? 'selected' : ''}>üßä Ice Frost</option>
                              <option value="smoke-flow" ${settings.textureStyle === 'smoke-flow' ? 'selected' : ''}>üí® Smoke Flow</option>
                              <option value="water-ripple" ${settings.textureStyle === 'water-ripple' ? 'selected' : ''}>üåä Water Ripple</option>
                          </optgroup>

                          <optgroup label="‚öôÔ∏è Premium Materials">
                              <option value="carbon-fiber-pro" ${settings.textureStyle === 'carbon-fiber-pro' ? 'selected' : ''}>üèÅ Carbon Fiber Pro</option>
                              <option value="brushed-aluminum" ${settings.textureStyle === 'brushed-aluminum' ? 'selected' : ''}>‚ö™ Brushed Aluminum</option>
                              <option value="brushed-titanium" ${settings.textureStyle === 'brushed-titanium' ? 'selected' : ''}>‚ö´ Brushed Titanium</option>
                              <option value="leather-grain" ${settings.textureStyle === 'leather-grain' ? 'selected' : ''}>üß≥ Leather Grain</option>
                              <option value="fabric-weave" ${settings.textureStyle === 'fabric-weave' ? 'selected' : ''}>üßµ Fabric Weave</option>
                              <option value="wood-grain" ${settings.textureStyle === 'wood-grain' ? 'selected' : ''}>ü™µ Wood Grain</option>
                          </optgroup>

                          <optgroup label="‚ö° Tech/Futuristic">
                              <option value="circuit-board" ${settings.textureStyle === 'circuit-board' ? 'selected' : ''}>üîå Circuit Board</option>
                              <option value="hexagon-grid-pro" ${settings.textureStyle === 'hexagon-grid-pro' ? 'selected' : ''}>‚¨° Hexagon Grid Pro</option>
                              <option value="hologram-scan" ${settings.textureStyle === 'hologram-scan' ? 'selected' : ''}>üì° Hologram Scan</option>
                              <option value="matrix-rain" ${settings.textureStyle === 'matrix-rain' ? 'selected' : ''}>üíö Matrix Rain</option>
                              <option value="energy-waves" ${settings.textureStyle === 'energy-waves' ? 'selected' : ''}>‚ö° Energy Waves</option>
                              <option value="cyberpunk-grid" ${settings.textureStyle === 'cyberpunk-grid' ? 'selected' : ''}>üî∑ Cyberpunk Grid</option>
                          </optgroup>

                          <optgroup label="üìê Geometric Clean">
                              <option value="dots-pro" ${settings.textureStyle === 'dots-pro' ? 'selected' : ''}>‚ö´ Dots Professional</option>
                              <option value="grid-pro" ${settings.textureStyle === 'grid-pro' ? 'selected' : ''}>‚¨ú Grid Professional</option>
                              <option value="diagonal-pro" ${settings.textureStyle === 'diagonal-pro' ? 'selected' : ''}>üìê Diagonal Pro</option>
                              <option value="waves" ${settings.textureStyle === 'waves' ? 'selected' : ''}>„Ä∞Ô∏è Waves</option>
                              <option value="triangles" ${settings.textureStyle === 'triangles' ? 'selected' : ''}>üî∫ Triangles</option>
                              <option value="crosshatch" ${settings.textureStyle === 'crosshatch' ? 'selected' : ''}>‚úñÔ∏è Crosshatch</option>
                          </optgroup>

                          <optgroup label="üé™ Special Effects">
                              <option value="perlin-noise" ${settings.textureStyle === 'perlin-noise' ? 'selected' : ''}>üì∫ Perlin Noise</option>
                              <option value="gradient-mesh" ${settings.textureStyle === 'gradient-mesh' ? 'selected' : ''}>üåà Gradient Mesh</option>
                          </optgroup>
                      </select>
                  </div>

                  <!-- Texture Intensity Slider -->
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                          <span>Texture Intensity</span>
                          <span id="texture-intensity-value" style="color: #4a9eff; font-weight: 600;">${settings.textureIntensity !== undefined ? settings.textureIntensity : 75}%</span>
                      </label>
                      <input type="range" id="texture-intensity-slider" min="0" max="100" value="${settings.textureIntensity !== undefined ? settings.textureIntensity : 75}"
                             style="width: 100%; height: 6px; border-radius: 3px; background: linear-gradient(90deg, rgba(74, 158, 255, 0.48) 0%, rgba(74,158,255,0.8) 100%); outline: none; cursor: pointer;">
                  </div>

                  <!-- Texture Scale Control -->
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px;">
                          Texture Scale
                      </label>
                      <div style="display: flex; gap: 8px;">
                          <button class="mga-btn mga-btn-sm texture-scale-btn" data-scale="small" style="flex: 1; ${(settings.textureScale === 'small') ? 'background: #4a9eff; color: white;' : ''}">Small</button>
                          <button class="mga-btn mga-btn-sm texture-scale-btn" data-scale="medium" style="flex: 1; ${(settings.textureScale === 'medium' || !settings.textureScale) ? 'background: #4a9eff; color: white;' : ''}">Medium</button>
                          <button class="mga-btn mga-btn-sm texture-scale-btn" data-scale="large" style="flex: 1; ${(settings.textureScale === 'large') ? 'background: #4a9eff; color: white;' : ''}">Large</button>
                      </div>
                  </div>

                  <!-- Blend Mode Selector -->
                  <div style="margin-bottom: 12px;">
                      <label class="mga-label" style="display: block; margin-bottom: 8px;">
                          Blend Mode
                      </label>
                      <select class="mga-select" id="texture-blend-mode">
                          <option value="overlay" ${(settings.textureBlendMode === 'overlay' || !settings.textureBlendMode) ? 'selected' : ''}>Overlay (Balanced)</option>
                          <option value="multiply" ${settings.textureBlendMode === 'multiply' ? 'selected' : ''}>Multiply (Darken)</option>
                          <option value="screen" ${settings.textureBlendMode === 'screen' ? 'selected' : ''}>Screen (Lighten)</option>
                          <option value="soft-light" ${settings.textureBlendMode === 'soft-light' ? 'selected' : ''}>Soft Light (Subtle)</option>
                      </select>
                  </div>

                  <!-- Animation Toggle -->
                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="texture-animated-checkbox" class="mga-checkbox" ${settings.textureAnimated ? 'checked' : ''}>
                          <span>‚ú® Enable Animation (where supported)</span>
                      </label>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">Quick Presets</div>
                  <div class="mga-grid">
                      <button class="mga-btn mga-btn-sm" data-preset="gaming">üéÆ Gaming</button>
                      <button class="mga-btn mga-btn-sm" data-preset="minimal">‚ö™ Minimal</button>
                      <button class="mga-btn mga-btn-sm" data-preset="vibrant">üåà Vibrant</button>
                      <button class="mga-btn mga-btn-sm" data-preset="dark">‚ö´ Dark</button>
                      <button class="mga-btn mga-btn-sm" data-preset="luxury">‚ú® Luxury</button>
                      <button class="mga-btn mga-btn-sm" data-preset="steel">üõ°Ô∏è Steel</button>
                      <button class="mga-btn mga-btn-sm" data-preset="chrome">‚ö™ Chrome</button>
                      <button class="mga-btn mga-btn-sm" data-preset="titanium">üå´Ô∏è Titanium</button>
                      <button class="mga-btn mga-btn-sm" data-preset="reset">üîÑ Reset</button>
                  </div>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">UI Mode</div>
                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="ultra-compact-checkbox" class="mga-checkbox"
                                 ${settings.ultraCompactMode ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üì± Ultra-compact mode</span>
                      </label>
                      <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                          Maximum space efficiency with condensed layouts and smaller text.
                      </p>
                  </div>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">Pop-out Behavior</div>
                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="use-overlays-checkbox" class="mga-checkbox"
                                 ${settings.useInGameOverlays ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üéÆ Use in-game overlays instead of separate windows</span>
                      </label>
                      <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                          When enabled, tabs will open as draggable overlays within the game window instead of separate browser windows.
                      </p>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">üõ°Ô∏è Compatibility Mode</div>
                  <div style="margin-bottom: 16px;">
                      <div style="display: flex; align-items: center; justify-content: space-between; padding: 12px;
                                  background: ${typeof CompatibilityMode !== 'undefined' && CompatibilityMode.flags.enabled ? 'rgba(34, 197, 94, 0.30)' : 'rgba(255, 255, 255, 0.05)'};
                                  border: 1px solid ${typeof CompatibilityMode !== 'undefined' && CompatibilityMode.flags.enabled ? 'rgba(34, 197, 94, 0.3)' : 'rgba(255, 255, 255, 0.57)'};
                                  border-radius: 8px; margin-bottom: 12px;">
                          <div>
                              <div style="font-weight: 600; margin-bottom: 4px;">
                                  ${typeof CompatibilityMode !== 'undefined' && CompatibilityMode.flags.enabled ? '‚úÖ Enabled' : '‚ö™ Disabled'}
                              </div>
                              <div style="font-size: 11px; color: #aaa;">
                                  ${typeof CompatibilityMode !== 'undefined' && CompatibilityMode.flags.enabled
                                      ? ('Reason: ' + (CompatibilityMode.detectionReason || 'manual'))
                                      : 'Auto-detects CSP restrictions'}
                              </div>
                          </div>
                          <button id="compat-toggle-btn" class="mga-btn mga-btn-sm"
                                  style="padding: 8px 16px; font-size: 12px; min-width: 100px;">
                              ${typeof CompatibilityMode !== 'undefined' && CompatibilityMode.flags.enabled ? 'Disable' : 'Force Enable'}
                          </button>
                      </div>
                      <p style="font-size: 11px; color: #aaa; line-height: 1.6;">
                          <strong>What it does:</strong><br>
                          ‚Ä¢ Bypasses CSP restrictions for Discord/managed devices<br>
                          ‚Ä¢ Uses system fonts instead of Google Fonts<br>
                          ‚Ä¢ Forces WebSocket reconnection even when tab is hidden<br>
                          ‚Ä¢ Uses GM_xmlhttpRequest for external network requests<br>
                          <br>
                          <strong>When to use:</strong><br>
                          ‚Ä¢ Playing in Discord Activities<br>
                          ‚Ä¢ Work/school computers with strict security policies<br>
                          ‚Ä¢ Browser extensions or embeds<br>
                          <br>
                          <em style="opacity: 0.7;">Note: Changes require page refresh</em>
                      </p>
                  </div>
              </div>

              <div class="mga-section">
                  <div class="mga-section-title">Developer Options</div>
                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="debug-mode-checkbox" class="mga-checkbox"
                                 ${settings.debugMode ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üêõ Enable Debug Mode</span>
                      </label>
                      <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                          Shows detailed console logs for troubleshooting pet hunger, notifications, and more.
                      </p>
                  </div>
  
                  <div style="margin-bottom: 12px;">
                      <label class="mga-checkbox-label" style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                          <input type="checkbox" id="hide-weather-checkbox" class="mga-checkbox"
                                 ${settings.hideWeather ? 'checked' : ''}
                                 style="accent-color: #4a9eff;">
                          <span>üåßÔ∏è Hide Weather Effects</span>
                      </label>
                      <p style="font-size: 11px; color: #aaa; margin: 4px 0 0 26px;">
                          Hide visual weather effects like snow, rain, and other weather animations for better performance.
                      </p>
                  </div>
              </div>
  
              <div class="mga-section">
                  <div class="mga-section-title">Data Management</div>
                  <div style="display: flex; gap: 8px; flex-wrap: wrap;">
                      <button class="mga-btn mga-btn-sm" id="export-settings-btn">Export Settings</button>
                      <button class="mga-btn mga-btn-sm" id="import-settings-btn">Import Settings</button>
                      <button class="mga-btn mga-btn-sm" id="reset-loadouts-btn" style="background: #dc2626;">üîÑ Reset Pet Loadouts</button>
                  </div>
                  <p style="font-size: 11px; color: #aaa; margin-top: 4px;">
                      Reset button will clear all saved pet loadouts while preserving other settings.
                  </p>
              </div>
          `;
      }
  
      // Helper function to refresh separate window popouts
      function refreshSeparateWindowPopouts(tabName) {
          try{
              UnifiedState.data.popouts.windows.forEach((windowRef, popoutTabName) => {
                  if (windowRef && !windowRef.closed && popoutTabName === tabName) {
                      // Force update pets data first for pets tab
                      if (tabName === 'pets') {
                          updateActivePetsFromRoomState();
                      }
  
                      // Trigger refresh in the separate window
                      if (windowRef.refreshPopoutContent) {
                          windowRef.refreshPopoutContent(tabName);
                          productionLog(`üîÑ [POPOUT] Refreshed ${tabName} window popout`);
                      } else if (windowRef.location) {
                          // Fallback: force reload if refresh function not available
                          productionWarn(`‚ö†Ô∏è [POPOUT] No refresh function for ${tabName}, reloading window`);
                          windowRef.location.reload();
                      }
                  }
              });
          } catch (error) {
              debugError('OVERLAY_LIFECYCLE', 'Failed to refresh separate window popouts', error, { tabName });
          }
      }
  
      // Place a pet preset - used by both main tab and popout Place buttons
      function placePetPreset(presetName) {
          const preset = UnifiedState.data.petPresets[presetName];
          if (!preset) {
              productionWarn(`[PETS] Preset "${presetName}" not found`);
              return;
          }
  
          // Store current pets
          (UnifiedState.atoms.activePets || []).forEach(p => {
              safeSendMessage({
                  scopePath: ["Room", "Quinoa"],
                  type: "StorePet",
                  itemId: p.id
              });
          });
  
          // Place preset pets with delays
          preset.forEach((p, i) => {
              setTimeout(() => {
                  safeSendMessage({
                      scopePath: ["Room", "Quinoa"],
                      type: "PlacePet",
                      itemId: p.id,
                      position: { x: 17 + i * 2, y: 13 },
                      localTileIndex: 64,
                      tileType: "Boardwalk"
                  });
              }, i * 50);
          });
  
          // Update all displays after pets are placed (with backup refresh)
          const refreshAllPetDisplays = () => {
              // Force update from room state
              updateActivePetsFromRoomState();
  
              // Update main tab if active
              if (UnifiedState.activeTab === 'pets') {
                  updateTabContent();
              }
  
              // Update overlays
              UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                  if (overlay && document.contains(overlay) && tabName === 'pets') {
                      if (overlay.className.includes('mga-overlay-content-only')) {
                          updatePureOverlayContent(overlay, tabName);
                      }
                  }
              });
  
              // Update separate window popouts
              refreshSeparateWindowPopouts('pets');
          };
  
          // First refresh after 1.5 seconds
          setTimeout(() => {
              refreshAllPetDisplays();
              productionLog(`‚úÖ [PETS] Placed preset "${presetName}" and updated displays (first refresh)`);
          }, preset.length * 50 + 1500);
  
          // Backup refresh after 2.5 seconds to catch slow updates
          setTimeout(() => {
              refreshAllPetDisplays();
              productionLog(`‚úÖ [PETS] Backup refresh for preset "${presetName}"`);
          }, preset.length * 50 + 2500);
      }
  
      // ==================== PETS UI HELPER FUNCTIONS ====================
      function updatePetPresetDropdown(context) {
          const select = context.querySelector('#preset-quick-select');
          if (!select) return;
  
          // Preserve current selection
          const currentValue = select.value;
  
          // Clear existing options except the first one
          select.innerHTML = '<option value="">-- Select Preset --</option>';
  
          // Add all presets
          Object.keys(UnifiedState.data.petPresets).forEach(name => {
              const preset = UnifiedState.data.petPresets[name];
              const option = targetDocument.createElement('option');
              option.value = name;
              option.textContent = `${name} (${preset.map(p => p.petSpecies).join(', ')})`;
              select.appendChild(option);
          });
  
          // Restore selection if it still exists
          if (currentValue && UnifiedState.data.petPresets[currentValue]) {
              select.value = currentValue;
          }
  
          debugLog('PETS_UI', 'Updated preset dropdown without full refresh');
      }
  
      function updateActivePetsDisplay(context = document, retryCount = 0) {
          // Only log in debug mode to reduce console spam
          if (UnifiedState.data.settings?.debugMode) {
              productionLog('üêæ [ACTIVE-PETS] Updating display', {
                  retryCount,
                  unifiedStateActivePets: UnifiedState.atoms.activePets?.length || 0,
                  windowActivePets: window.activePets?.length || 0,
                  context: context === document ? 'document' : 'overlay'
              });
          }
  
          // Try multiple sources for pet data (React timing issue workaround)
          let activePets = UnifiedState.atoms.activePets || window.activePets || [];
  
          // If no pets found and this is first try, wait and retry (DOM timing fix)
          if (activePets.length === 0 && retryCount < 3) {
              if (UnifiedState.data.settings?.debugMode) {
                  productionLog(`üêæ [ACTIVE-PETS] No pets found, retrying in ${100 * (retryCount + 1)}ms...`);
              }
              setTimeout(() => updateActivePetsDisplay(context, retryCount + 1), 100 * (retryCount + 1));
              return;
          }
  
          // Find all Active Pets display elements in the given context
          const activePetsDisplays = context.querySelectorAll('.mga-active-pets-display');
  
          activePetsDisplays.forEach(display => {
              const innerHTML = activePets.length > 0 ? `
                  <div class="mga-active-pets-header">Currently Equipped:</div>
                  <div class="mga-active-pets-list">
                      ${activePets.map((p, index) => {
                          const timeUntilHungry = calculateTimeUntilHungry(p);
                          const timerText = formatHungerTimer(timeUntilHungry);
                          const timerColor = timeUntilHungry === null ? '#999' :
                                             timeUntilHungry <= 0 ? '#8B0000' :
                                             timeUntilHungry < 5 * 60 * 1000 ? '#ff4444' :
                                             timeUntilHungry < 15 * 60 * 1000 ? '#ffa500' : '#4caf50';
                          return `
                              <div class="mga-pet-slot" style="display: flex; flex-direction: column; align-items: center; gap: 4px; margin-bottom: 8px;">
                                  <span class="mga-pet-badge">${p.petSpecies}</span>
                                  <span class="mga-hunger-timer" data-pet-index="${index}" style="font-size: 12px; color: ${timerColor}; font-weight: bold;">${timerText}</span>
                              </div>
                          `;
                      }).join('')}
                  </div>
              ` : `
                  <div class="mga-empty-state">
                      <div class="mga-empty-state-icon">‚Äî</div>
                      <div class="mga-empty-state-description">No pets currently active</div>
                  </div>
              `;
  
              display.innerHTML = innerHTML;
          });
  
          if (UnifiedState.data.settings?.debugMode) {
              productionLog('üêæ [ACTIVE-PETS] Updated display elements:', {
                  elementsFound: activePetsDisplays.length,
                  activePetsCount: activePets.length
              });
          }
      }
  
      // Initialize preset order array if not exists
      function ensurePresetOrder() {
          if (!UnifiedState.data.petPresetsOrder || !Array.isArray(UnifiedState.data.petPresetsOrder)) {
              UnifiedState.data.petPresetsOrder = Object.keys(UnifiedState.data.petPresets);
          } else {
              // Ensure all existing presets are in the order array
              Object.keys(UnifiedState.data.petPresets).forEach(name => {
                  if (!UnifiedState.data.petPresetsOrder.includes(name)) {
                      UnifiedState.data.petPresetsOrder.push(name);
                  }
              });
              // Remove any presets from order array that no longer exist
              UnifiedState.data.petPresetsOrder = UnifiedState.data.petPresetsOrder.filter(name =>
                  UnifiedState.data.petPresets.hasOwnProperty(name)
              );
          }
      }
  
      // Move preset up or down in the order
      function movePreset(presetName, direction, context) {
          productionLog(`üö® [CRITICAL] movePreset called: ${presetName} ${direction}`);
          productionLog(`üö® [CRITICAL] Current order:`, UnifiedState.data.petPresetsOrder);
          ensurePresetOrder();
          const currentIndex = UnifiedState.data.petPresetsOrder.indexOf(presetName);
  
          if (currentIndex === -1) return;
  
          let newIndex;
          if (direction === 'up' && currentIndex > 0) {
              newIndex = currentIndex - 1;
          } else if (direction === 'down' && currentIndex < UnifiedState.data.petPresetsOrder.length - 1) {
              newIndex = currentIndex + 1;
          } else {
              return; // Can't move
          }
  
          // Swap elements
          const temp = UnifiedState.data.petPresetsOrder[currentIndex];
          UnifiedState.data.petPresetsOrder[currentIndex] = UnifiedState.data.petPresetsOrder[newIndex];
          UnifiedState.data.petPresetsOrder[newIndex] = temp;
  
          // Save the new order
          MGA_saveJSON('MGA_petPresetsOrder', UnifiedState.data.petPresetsOrder);
  
          // Force UI refresh after reorder
          productionLog(`üö® [CRITICAL] Order after swap:`, UnifiedState.data.petPresetsOrder);
  
          // Refresh the preset list display
          refreshPresetsList(context);
  
          // Refresh popout windows
          refreshSeparateWindowPopouts('pets');
  
          // Also update main tab content if needed
          if (UnifiedState.activeTab === 'pets') {
              updateTabContent();
          }
  
          productionLog(`üìã [PET-PRESETS] Moved preset "${presetName}" ${direction}`);
      }
  
      // Refresh the presets list with new order
      // Helper function for drag and drop positioning
      function getDragAfterElement(container, y) {
          const draggableElements = [...container.querySelectorAll('.mga-preset:not(.dragging)')];
  
          return draggableElements.reduce((closest, child) => {
              const box = child.getBoundingClientRect();
              const offset = y - box.top - box.height / 2;
  
              if (offset < 0 && offset > closest.offset) {
                  return { offset: offset, element: child };
              } else {
                  return closest;
              }
          }, { offset: Number.NEGATIVE_INFINITY }).element;
      }
  
      function refreshPresetsList(context) {
          const presetsList = context.querySelector('#presets-list');
          if (!presetsList) return;
  
          // Clear current list
          presetsList.innerHTML = '';
  
          // Re-add presets in order
          ensurePresetOrder();
          UnifiedState.data.petPresetsOrder.forEach(name => {
              if (UnifiedState.data.petPresets[name]) {
                  addPresetToList(context, name, UnifiedState.data.petPresets[name]);
              }
          });
      }
  
      function addPresetToList(context, name, preset) {
          const presetsList = context.querySelector('#presets-list');
          if (!presetsList) return;
  
          // Create new preset element
          const presetDiv = targetDocument.createElement('div');
          presetDiv.className = 'mga-preset';
          presetDiv.draggable = true;
          presetDiv.dataset.presetName = name;
          const hotkey = UnifiedState.data.petPresetHotkeys[name];
          presetDiv.innerHTML = `
              <div class="mga-preset-header" style="cursor: move;">
                  <span class="mga-preset-name">‚ãÆ‚ãÆ ${name}</span>
                  <button class="mga-hotkey-btn" data-preset="${name}" style="margin-left: auto; padding: 2px 8px; font-size: 11px; background: rgba(100, 200, 255, 0.48); border: 1px solid #4a9eff; border-radius: 4px; color: white; cursor: pointer;">
                      ${hotkey || 'Set Hotkey'}
                  </button>
              </div>
              <div class="mga-preset-pets">${preset.map(p => p.petSpecies).join(', ')}</div>
              <div class="mga-preset-actions">
                  <div style="display: flex; gap: 4px; margin-bottom: 4px;">
                      <button class="mga-btn mga-btn-sm" data-action="move-up" data-preset="${name}" style="background: #6b7280; padding: 4px 8px;">‚Üë</button>
                      <button class="mga-btn mga-btn-sm" data-action="move-down" data-preset="${name}" style="background: #6b7280; padding: 4px 8px;">‚Üì</button>
                      <button class="mga-btn mga-btn-sm" data-action="save" data-preset="${name}">Save Current</button>
                  </div>
                  <div style="display: flex; gap: 4px;">
                      <button class="mga-btn mga-btn-sm" data-action="place" data-preset="${name}">Place</button>
                      <button class="mga-btn mga-btn-sm" data-action="remove" data-preset="${name}">Remove</button>
                  </div>
              </div>
          `;
  
          // Add drag-and-drop handlers
          presetDiv.addEventListener('dragstart', (e) => {
              e.dataTransfer.effectAllowed = 'move';
              e.dataTransfer.setData('text/plain', name);
              presetDiv.style.opacity = '0.5';
          });
  
          presetDiv.addEventListener('dragend', (e) => {
              presetDiv.style.opacity = '';
          });
  
          presetDiv.addEventListener('dragover', (e) => {
              e.preventDefault();
              e.dataTransfer.dropEffect = 'move';
              const afterElement = getDragAfterElement(presetsList, e.clientY);
              if (afterElement == null) {
                  presetsList.appendChild(presetDiv);
              } else {
                  presetsList.insertBefore(presetDiv, afterElement);
              }
          });
  
          presetDiv.addEventListener('drop', (e) => {
              e.preventDefault();
              const draggedPresetName = e.dataTransfer.getData('text/plain');
              if (draggedPresetName && draggedPresetName !== name) {
                  // Update order array based on current DOM order
                  const newOrder = Array.from(presetsList.children).map(el => el.dataset.presetName).filter(Boolean);
                  UnifiedState.data.petPresetsOrder = newOrder;
                  MGA_saveJSON('MGA_petPresetsOrder', UnifiedState.data.petPresetsOrder);
                  refreshPresetsList(context);
              }
          });
  
          // Add hotkey button handler
          const hotkeyBtn = presetDiv.querySelector('.mga-hotkey-btn');
          if (hotkeyBtn) {
              hotkeyBtn.addEventListener('click', (e) => {
                  e.stopPropagation();
                  showHotkeyRecordingModal(name, context);
              });
          }
  
          // Add event handlers to new buttons
          presetDiv.querySelectorAll('[data-action]').forEach(btn => {
              btn.setAttribute('data-handler-setup', 'true');
              btn.addEventListener('click', (e) => {
                  e.preventDefault();
                  const action = e.target.dataset.action;
                  const presetName = e.target.dataset.preset;
  
                  if (action === 'save') {
                      UnifiedState.data.petPresets[presetName] = (UnifiedState.atoms.activePets || []).slice(0, 3);
  
                      // Use safe save with user feedback for critical pet preset data
                      const result = MGA_safeSave('MGA_petPresets', UnifiedState.data.petPresets, {
                          description: `pet preset "${presetName}"`,
                          criticalData: true,
                          showUserAlert: true
                      });
  
                      if (result.success) {
                          productionLog(`‚úÖ [PET-PRESETS] Successfully saved preset "${presetName}"`);
                      } else {
                          console.error(`‚ùå [PET-PRESETS] Failed to save preset "${presetName}":`, result.error);
                      }
  
                      updatePetPresetDropdown(context);
                      refreshSeparateWindowPopouts('pets');
                      debugLog('BUTTON_INTERACTIONS', `Saved preset: ${presetName} (from added element)`);
                  } else if (action === 'place') {
                      // CRITICAL: Stop event propagation to prevent game clicks
                      e.stopPropagation();
                      e.preventDefault();
  
                      const preset = UnifiedState.data.petPresets[presetName];
                      if (!preset) return;
  
                      // Store current pets then place preset pets
                      (UnifiedState.atoms.activePets || []).forEach(p => {
                          safeSendMessage({
                              scopePath: ["Room", "Quinoa"],
                              type: "StorePet",
                              itemId: p.id
                          });
                      });
  
                      // CRITICAL FIX: Add delay between pet placements to prevent accidental clicks
                      preset.forEach((p, i) => {
                          setTimeout(() => {
                              safeSendMessage({
                                  scopePath: ["Room", "Quinoa"],
                                  type: "PlacePet",
                                  itemId: p.id,
                                  position: { x: 17 + i * 2, y: 13 },
                                  localTileIndex: 64,
                                  tileType: "Boardwalk"
                              });
                          }, i * 50); // 50ms delay between each pet placement
                      });
  
                      // Update pets display after all pets placed
                      setTimeout(() => {
                          // Force update pets from room state first
                          updateActivePetsFromRoomState();
  
                          // Then refresh the tab if it's active
                          if (UnifiedState.activeTab === 'pets') {
                              updateTabContent();
                          }
  
                          // Update all pet overlays after placing
                          UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                              if (overlay && document.contains(overlay) && tabName === 'pets') {
                                  if (overlay.className.includes('mga-overlay-content-only')) {
                                      updatePureOverlayContent(overlay, tabName);
                                      debugLog('OVERLAY_LIFECYCLE', 'Updated pure pets overlay after placing preset');
                                  }
                              }
                          });
  
                          // Update separate window popouts
                          refreshSeparateWindowPopouts('pets');
                      }, preset.length * 50 + 1000); // Wait for all pets + extra time for game to update
  
                      debugLog('BUTTON_INTERACTIONS', `Placed preset: ${presetName} (from added element)`);
                  } else if (action === 'remove') {
                      delete UnifiedState.data.petPresets[presetName];
  
                      // Remove from order array
                      ensurePresetOrder();
                      const orderIndex = UnifiedState.data.petPresetsOrder.indexOf(presetName);
                      if (orderIndex !== -1) {
                          UnifiedState.data.petPresetsOrder.splice(orderIndex, 1);
                          MGA_saveJSON('MGA_petPresetsOrder', UnifiedState.data.petPresetsOrder);
                      }
  
                      // Use safe save for critical pet preset removal
                      const result = MGA_safeSave('MGA_petPresets', UnifiedState.data.petPresets, {
                          description: `pet preset deletion "${presetName}"`,
                          criticalData: true,
                          showUserAlert: true
                      });
  
                      if (result.success) {
                          productionLog(`‚úÖ [PET-PRESETS] Successfully removed preset "${presetName}"`);
                          presetDiv.remove();
                      } else {
                          console.error(`‚ùå [PET-PRESETS] Failed to remove preset "${presetName}":`, result.error);
                          // Restore the preset in memory since save failed
                          UnifiedState.data.petPresets[presetName] = UnifiedState.data.petPresets[presetName] || [];
                          // Also restore to order array
                          if (orderIndex !== -1 && !UnifiedState.data.petPresetsOrder.includes(presetName)) {
                              UnifiedState.data.petPresetsOrder.splice(orderIndex, 0, presetName);
                          }
                      }
                      updatePetPresetDropdown(context);
                      refreshSeparateWindowPopouts('pets');
                      debugLog('BUTTON_INTERACTIONS', `Removed preset: ${presetName} (from added element)`);
                  } else if (action === 'move-up') {
                      productionLog(`üö® [CRITICAL] Move up button clicked for ${presetName}`);
                      movePreset(presetName, 'up', context);
                  } else if (action === 'move-down') {
                      productionLog(`üö® [CRITICAL] Move down button clicked for ${presetName}`);
                      movePreset(presetName, 'down', context);
                  }
              });
          });
  
          presetsList.appendChild(presetDiv);
          debugLog('PETS_UI', `Added preset ${name} to list without full refresh`);
      }
  
      // ==================== EVENT HANDLERS ====================
      function setupPetsTabHandlers(context = document) {
          productionLog('üö® [CRITICAL] Setting up pet preset handlers');
  
          // Use event delegation on the parent container for all preset buttons
          const presetsContainer = context.querySelector('#presets-list');
          if (presetsContainer) {
              productionLog('üö® [CRITICAL] Found presets container, adding delegation');
  
              // Remove old listener if it exists
              if (presetsContainer._mgaClickHandler) {
                  presetsContainer.removeEventListener('click', presetsContainer._mgaClickHandler);
              }
  
              // Create new handler
              presetsContainer._mgaClickHandler = (e) => {
                  const btn = e.target.closest('[data-action]');
                  if (!btn) return;
  
                  e.preventDefault();
                  e.stopPropagation();
  
                  const action = btn.dataset.action;
                  const presetName = btn.dataset.preset;
  
                  productionLog(`üö® [CRITICAL] Delegated click: action=${action}, preset=${presetName}`);
  
                  if (action === 'move-up') {
                      productionLog(`üö® [CRITICAL] Moving ${presetName} UP`);
                      movePreset(presetName, 'up', context);
                  } else if (action === 'move-down') {
                      productionLog(`üö® [CRITICAL] Moving ${presetName} DOWN`);
                      movePreset(presetName, 'down', context);
                  } else if (action === 'save') {
                      productionLog(`üö® [CRITICAL] Saving preset ${presetName}`);
                      UnifiedState.data.petPresets[presetName] = (UnifiedState.atoms.activePets || []).slice(0, 3);
                      MGA_saveJSON('MGA_petPresets', UnifiedState.data.petPresets);
                      refreshPresetsList(context);
                  } else if (action === 'place') {
                      productionLog(`üö® [CRITICAL] Placing preset ${presetName}`);
                      placePetPreset(presetName);
                  } else if (action === 'remove') {
                      productionLog(`üö® [CRITICAL] Removing preset ${presetName}`);
                      delete UnifiedState.data.petPresets[presetName];
                      MGA_saveJSON('MGA_petPresets', UnifiedState.data.petPresets);
                      refreshPresetsList(context);
                  }
              };
  
              // Add the handler
              presetsContainer.addEventListener('click', presetsContainer._mgaClickHandler);
              productionLog('üö® [CRITICAL] Event delegation handler attached successfully');
  
              // Handle hotkey button clicks
              context.querySelectorAll('.mga-hotkey-btn').forEach(btn => {
                  btn.addEventListener('click', (e) => {
                      e.stopPropagation();
                      const presetName = btn.dataset.preset;
                      showHotkeyRecordingModal(presetName, context);
                  });
              });
          } else {
              productionLog('üö® [CRITICAL] ERROR: presets container not found!')
          }
  
          const input = context.querySelector('#preset-name-input');
          if (input) {
              // Comprehensive input isolation to prevent game key interference and modal detection
  
              let handlingEvent = false;
  
              // Add additional isolation layer for the input container
              // Note: Removed aggressive event blocking that was preventing UI interactions
  
              // Create input isolation system
              function createInputIsolation(inputElement) {
                  // Prevent ALL game key interference when input is focused
                  const isolateKeyEvent = (e) => {
                      if (document.activeElement === inputElement) {
                          // Stop all propagation to prevent game from receiving keys
                          e.stopImmediatePropagation();
                          e.stopPropagation();
  
                          // Handle special keys
                          if (e.key === 'Escape') {
                              e.preventDefault();
                              inputElement.blur(); // Allow user to return to game
                              return;
                          }
  
                          // Allow Enter to submit
                          if (e.key === 'Enter') {
                              e.preventDefault();
                              const addBtn = context.querySelector('#add-preset-btn');
                              if (addBtn) addBtn.click();
                              return;
                          }
  
                          // For other keys, let the input handle them naturally
                          // but prevent game from seeing them
                      }
                  };
  
                  // Capture ALL key events before they reach the game
                  ['keydown', 'keyup', 'keypress'].forEach(eventType => {
                      inputElement.addEventListener(eventType, isolateKeyEvent, {
                          capture: true,
                          passive: false
                      });
                  });
  
                  // Also isolate focus/blur events
                  inputElement.addEventListener('focus', (e) => {
                      if (UnifiedState.data.settings.debugMode) {
                          productionLog('üîí Input focused - Game keys isolated');
                      }
                      e.stopPropagation();
                  });
  
                  inputElement.addEventListener('blur', (e) => {
                      if (UnifiedState.data.settings.debugMode) {
                          productionLog('üîì Input blurred - Game keys restored');
                      }
                      e.stopPropagation();
                  });
              }
  
              // Apply input isolation
              createInputIsolation(input);
  
              // Existing click handlers with improved event handling
              input.addEventListener('mousedown', (e) => {
                  if (handlingEvent) return;
                  handlingEvent = true;
                  e.stopPropagation();
  
                  setTimeout(() => {
                      handlingEvent = false;
                  }, 50);
              });
  
              input.addEventListener('click', (e) => {
                  if (handlingEvent) return;
                  e.stopPropagation();
  
                  // Only select all if the input is empty or user clicked when not focused
                  if (input.value === '' || document.activeElement !== input) {
                      setTimeout(() => {
                          input.focus();
                          input.select();
                      }, 0);
                  }
              });
          }
  
          // Quick Load Button Handler
          const quickLoadBtn = context.querySelector('#quick-load-btn');
          if (quickLoadBtn && !quickLoadBtn.hasAttribute('data-handler-setup')) {
              quickLoadBtn.setAttribute('data-handler-setup', 'true');
              quickLoadBtn.addEventListener('click', () => {
                  const select = context.querySelector('#preset-quick-select');
                  const presetName = select.value;
  
                  if (!presetName) {
                      productionWarn('[PETS] No preset selected');
                      return;
                  }
  
                  if (!UnifiedState.data.petPresets[presetName]) {
                      productionWarn('[PETS] Preset not found:', presetName);
                      return;
                  }
  
                  const preset = UnifiedState.data.petPresets[presetName];
  
                  // Validate preset
                  if (!preset || !Array.isArray(preset) || preset.length === 0) {
                      productionWarn('[PETS] Preset is empty or invalid:', preset);
                      return;
                  }
  
                  // Store current pets FIRST
                  const currentPets = UnifiedState.atoms.activePets || [];
                  currentPets.forEach(p => {
                      safeSendMessage({
                          scopePath: ["Room", "Quinoa"],
                          type: "StorePet",
                          itemId: p.id
                      });
                  });
  
                  // Wait for store operations to complete, then place preset pets
                  const baseDelay = currentPets.length > 0 ? 300 : 100;
                  preset.forEach((p, i) => {
                      setTimeout(() => {
                          safeSendMessage({
                              scopePath: ["Room", "Quinoa"],
                              type: "PlacePet",
                              itemId: p.id,
                              position: { x: 17 + i * 2, y: 13 },
                              localTileIndex: 64,
                              tileType: "Boardwalk"
                          });
                      }, baseDelay + (i * 100));
                  });
  
                  // Multiple refresh waves to catch all pet placements
                  const totalDelay = baseDelay + (preset.length * 100);
  
                  setTimeout(() => {
                      updateActivePetsFromRoomState();
                      updateActivePetsDisplay(context);
                  }, totalDelay + 200);
  
                  setTimeout(() => {
                      updateActivePetsFromRoomState();
                      updateActivePetsDisplay(context);
                  }, totalDelay + 600);
  
                  setTimeout(() => {
                      updateActivePetsFromRoomState();
                      updateActivePetsDisplay(context);
                      refreshSeparateWindowPopouts('pets');
                      UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                          if (overlay && document.contains(overlay) && tabName === 'pets') {
                              if (overlay.className.includes('mga-overlay-content-only')) {
                                  updatePureOverlayContent(overlay, tabName);
                              }
                          }
                      });
                  }, totalDelay + 1000);
              });
          }
  
          // Add/Save Preset Button Handler
          const addBtn = context.querySelector('#add-preset-btn');
          if (addBtn && !addBtn.hasAttribute('data-handler-setup')) {
              addBtn.setAttribute('data-handler-setup', 'true');
              addBtn.addEventListener('click', () => {
                  const input = context.querySelector('#preset-name-input');
                  const name = input.value.trim();
                  if (name && UnifiedState.atoms.activePets && UnifiedState.atoms.activePets.length) {
                      UnifiedState.data.petPresets[name] = UnifiedState.atoms.activePets.slice(0, 3).map(p => ({
                          id: p.id,
                          petSpecies: p.petSpecies,
                          mutations: p.mutations || []
                      }));
                      MGA_saveJSON('MGA_petPresets', UnifiedState.data.petPresets);
                      input.value = ''; // Clear input after successful add
  
                      // Add preset name to order array
                      ensurePresetOrder();
                      if (!UnifiedState.data.petPresetsOrder.includes(name)) {
                          UnifiedState.data.petPresetsOrder.push(name);
                          MGA_saveJSON('MGA_petPresetsOrder', UnifiedState.data.petPresetsOrder);
                      }
  
                      // Refresh preset list to show in correct order
                      refreshPresetsList(context);
  
                      // Update dropdown
                      updatePetPresetDropdown(context);
  
                      // Update popouts
                      refreshSeparateWindowPopouts('pets');
                      UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                          if (overlay && document.contains(overlay) && tabName === 'pets') {
                              if (overlay.className.includes('mga-overlay-content-only')) {
                                  updatePureOverlayContent(overlay, tabName);
                              }
                          }
                      });
  
                      debugLog('BUTTON_INTERACTIONS', `Created new preset: ${name} without full DOM refresh`);
                  } else if (!name) {
                      input.focus(); // Focus input if name is empty
                  }
              });
          }
  
          // Prevent duplicate event listeners by checking if already handled
          context.querySelectorAll('[data-action]').forEach(btn => {
              if (btn.hasAttribute('data-handler-setup')) {
                  return; // Skip if already has event listener
              }
              btn.setAttribute('data-handler-setup', 'true');
  
              btn.addEventListener('click', (e) => {
                  e.preventDefault();
                  debugLog('BUTTON_INTERACTIONS', `Button clicked: ${e.target.dataset.action}`, {
                      preset: e.target.dataset.preset,
                      buttonText: e.target.textContent
                  });
  
                  const action = e.target.dataset.action;
                  const presetName = e.target.dataset.preset;
  
                  if (action === 'save') {
                      UnifiedState.data.petPresets[presetName] = (UnifiedState.atoms.activePets || []).slice(0, 3);
                      MGA_saveJSON('MGA_petPresets', UnifiedState.data.petPresets);
  
                      // Update only the quick select dropdown without full refresh
                      updatePetPresetDropdown(context);
  
                      // Update all pet overlays (they need full updates for popouts)
                      UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                          if (overlay && document.contains(overlay) && tabName === 'pets') {
                              if (overlay.className.includes('mga-overlay-content-only')) {
                                  updatePureOverlayContent(overlay, tabName);
                                  debugLog('OVERLAY_LIFECYCLE', 'Updated pure pets overlay after saving preset');
                              }
                          }
                      });
  
                      // Update separate window popouts
                      refreshSeparateWindowPopouts('pets');
  
                      debugLog('BUTTON_INTERACTIONS', `Saved preset: ${presetName} without full DOM refresh`);
                  } else if (action === 'place') {
                      const preset = UnifiedState.data.petPresets[presetName];
                      if (!preset) return;
  
                      // Store current pets
                      (UnifiedState.atoms.activePets || []).forEach(p => {
                          safeSendMessage({
                              scopePath: ["Room", "Quinoa"],
                              type: "StorePet",
                              itemId: p.id
                          });
                      });
  
                      // Place preset pets
                      preset.forEach((p, i) => {
                          safeSendMessage({
                              scopePath: ["Room", "Quinoa"],
                              type: "PlacePet",
                              itemId: p.id,
                              position: { x: 17 + i * 2, y: 13 },
                              localTileIndex: 64,
                              tileType: "Boardwalk"
                          });
                      });
  
                      // Update pets display after placement (with delay for game to update)
                      setTimeout(() => {
                          // Force update pets from room state first
                          updateActivePetsFromRoomState();
  
                          // Update main tab if pets tab is active
                          if (UnifiedState.activeTab === 'pets') {
                              updateTabContent();
                          }
  
                          // Update all pet overlays after placing
                          UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                              if (overlay && document.contains(overlay) && tabName === 'pets') {
                                  if (overlay.className.includes('mga-overlay-content-only')) {
                                      updatePureOverlayContent(overlay, tabName);
                                      debugLog('OVERLAY_LIFECYCLE', 'Updated pure pets overlay after placing preset');
                                  }
                              }
                          });
  
                          // Update separate window popouts
                          refreshSeparateWindowPopouts('pets');
                      }, 1000); // Increased from 100ms to 1000ms to give game time to update
                  } else if (action === 'remove') {
                      delete UnifiedState.data.petPresets[presetName];
                      MGA_saveJSON('MGA_petPresets', UnifiedState.data.petPresets);
  
                      // Remove the preset element from DOM without full refresh
                      const presetElement = e.target.closest('.mga-preset');
                      if (presetElement) {
                          presetElement.remove();
                      }
  
                      // Update the dropdown
                      updatePetPresetDropdown(context);
  
                      // Update all pet overlays
                      UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                          if (overlay && document.contains(overlay) && tabName === 'pets') {
                              if (overlay.className.includes('mga-overlay-content-only')) {
                                  updatePureOverlayContent(overlay, tabName);
                                  debugLog('OVERLAY_LIFECYCLE', 'Updated pure pets overlay after removing preset');
                              }
                          }
                      });
  
                      // Update separate window popouts
                      refreshSeparateWindowPopouts('pets');
  
                      debugLog('BUTTON_INTERACTIONS', `Removed preset: ${presetName} without full DOM refresh`);
                  }
              });
          });
  
          // Handle popout preset buttons (simplified interface)
          context.querySelectorAll('[data-preset]').forEach(btn => {
              if (btn.hasAttribute('data-handler-setup')) return;
              btn.setAttribute('data-handler-setup', 'true');
  
              btn.addEventListener('click', (e) => {
                  e.preventDefault();
                  const presetName = e.target.dataset.preset;
                  const preset = UnifiedState.data.petPresets[presetName];
  
                  if (!preset || !preset.length) {
                      productionWarn(`‚ö†Ô∏è Preset "${presetName}" not found or empty!`);
                      return;
                  }
  
                  debugLog('BUTTON_INTERACTIONS', `Loading preset from popout: ${presetName}`, { preset });
  
                  // Clear existing pets
                  (UnifiedState.atoms.activePets || []).forEach(p => {
                      safeSendMessage({
                          scopePath: ["Room", "Quinoa"],
                          type: "RemovePet",
                          itemId: p.id
                      });
                  });
  
                  // Place preset pets
                  preset.forEach((p, i) => {
                      safeSendMessage({
                          scopePath: ["Room", "Quinoa"],
                          type: "PlacePet",
                          itemId: p.id,
                          position: { x: 17 + i * 2, y: 13 },
                          localTileIndex: 64,
                          tileType: "Boardwalk"
                      });
                  });
  
                  // Update popouts after loading (changed from 100ms to 1000ms for game to update)
                  setTimeout(() => {
                      updateActivePetsFromRoomState();
                      refreshSeparateWindowPopouts('pets');
                      UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                          if (overlay && document.contains(overlay) && tabName === 'pets') {
                              if (overlay.className.includes('mga-overlay-content-only')) {
                                  updatePureOverlayContent(overlay, tabName);
                              }
                          }
                      });
                  }, 1000);
              });
          });
  
          // Pet management handlers will be added here when we detect actual Magic Garden pets
      }
  
      // ==================== MAGIC GARDEN PET HELPERS ====================
      // Pet helpers for actual Magic Garden pets (not generic fantasy pets)
  
      class ResourceDashboard {
          constructor() {
              this.resourceHistory = JSON.parse(localStorage.getItem('MGA_resourceHistory') || '[]');
              this.resourceAlerts = JSON.parse(localStorage.getItem('MGA_resourceAlerts') || '{}');
  
              // Initialize resource tracking if not exists
              if (!UnifiedState.data.resources) {
                  UnifiedState.data.resources = {
                      coins: 0,
                      gems: 0,
                      seeds: {},
                      tiles: 0,
                      lastUpdate: Date.now()
                  };
              }
          }
  
          updateResourceHistory() {
              try {
                  const currentResources = {
                      timestamp: Date.now(),
                      coins: UnifiedState.atoms.coinCount || 0,
                      gems: UnifiedState.atoms.gems || 0,
                      seeds: Object.keys(UnifiedState.atoms.seedInventory || {}).length,
                      tiles: UnifiedState.atoms.tiles || 0
                  };
  
                  this.resourceHistory.push(currentResources);
                  if (this.resourceHistory.length > 100) {
                      this.resourceHistory = this.resourceHistory.slice(-100);
                  }
                  localStorage.setItem('MGA_resourceHistory', JSON.stringify(this.resourceHistory));
              } catch (error) {
                  console.error('Error updating resource history:', error);
              }
          }
  
          generateDashboard() {
              const latest = this.resourceHistory[this.resourceHistory.length - 1];
              if (!latest) {
                  return `<div class="mga-section"><div class="mga-section-title">üìä Resource Dashboard</div><div style="color: rgba(255,255,255,0.6); text-align: center; padding: 20px;">No resource data available yet.</div></div>`;
              }
  
              return `
                  <div class="mga-section">
                      <div class="mga-section-title">üìä Resource Dashboard</div>
                      <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 12px; margin: 15px 0;">
                          <div style="background: rgba(255,255,255,0.15); padding: 12px; border-radius: 8px;">
                              <div style="color: #F59E0B; font-size: 24px; font-weight: bold;">${latest.coins.toLocaleString()}</div>
                              <div style="color: rgba(255,255,255,0.7); font-size: 12px;">üí∞ Coins</div>
                          </div>
                          <div style="background: rgba(255,255,255,0.15); padding: 12px; border-radius: 8px;">
                              <div style="color: #8B5CF6; font-size: 24px; font-weight: bold;">${latest.gems.toLocaleString()}</div>
                              <div style="color: rgba(255,255,255,0.7); font-size: 12px;">üíé Gems</div>
                          </div>
                          <div style="background: rgba(255,255,255,0.15); padding: 12px; border-radius: 8px;">
                              <div style="color: #10B981; font-size: 24px; font-weight: bold;">${latest.seeds}</div>
                              <div style="color: rgba(255,255,255,0.7); font-size: 12px;">üå± Seeds</div>
                          </div>
                      </div>
                  </div>
              `;
          }
  
          setupDashboardHandlers(context = document) {
              // Resource dashboard handlers
          }
      }
  
      // Create global instance
      window.resourceDashboard = new ResourceDashboard();
  
      function setupAbilitiesTabHandlers(context = document) {
          debugLog('ABILITY_LOGS', 'Setting up abilities tab handlers with context', {
              isDocument: context === document,
              className: context.className || 'unknown'
          });
  
          // Set up ability logs handlers
          const clearBtn = context.querySelector('#clear-ability-logs');
          if (clearBtn && !clearBtn.hasAttribute('data-handler-setup')) {
              clearBtn.setAttribute('data-handler-setup', 'true');
              clearBtn.addEventListener('click', () => {
                  if (confirm('Clear all ability logs? This cannot be undone!')) {
                      UnifiedState.data.petAbilityLogs = [];
                      MGA_saveJSON('MGA_petAbilityLogs', []);
                      updateAbilityLogDisplay(context);
                  }
              });
          }
      }
  
      // Duplicate function removed - using enhanced version later in file
  
      // ==================== LOADING STATE UTILITIES ====================
      window.MGA_LoadingStates = {
          show: (element, text = 'Loading...') => {
              if (!element) return;
              const loadingHtml = `
                  <div class="mga-loading">
                      <div class="mga-loading-spinner"></div>
                      <span>${text}</span>
                  </div>
              `;
              element.innerHTML = loadingHtml;
          },
  
          showSkeleton: (element, lines = 3) => {
              if (!element) return;
              const skeletonLines = Array(lines).fill(0).map(() =>
                  `<div class="mga-skeleton" style="height: 20px; margin-bottom: 8px; width: ${Math.floor(Math.random() * 40 + 60)}%;"></div>`
              ).join('');
              element.innerHTML = `<div style="padding: 20px;">${skeletonLines}</div>`;
          },
  
          hide: (element, content, fadeIn = true) => {
              if (!element) return;
              element.innerHTML = content;
              if (fadeIn) {
                  element.classList.add('mga-fade-in');
                  setTimeout(() => element.classList.remove('mga-fade-in'), 300);
              }
          }
      };
  
  
      function setupAbilitiesTabHandlers(context = document) {
          debugLog('ABILITY_LOGS', 'Setting up abilities tab handlers with context', {
              isDocument: context === document,
              className: context.className || 'document'
          });
  
          // Filter mode switching
          const categoriesBtn = context.querySelector('#filter-mode-categories');
          const byPetBtn = context.querySelector('#filter-mode-bypet');
          const customBtn = context.querySelector('#filter-mode-custom');
  
          if (categoriesBtn && !categoriesBtn.hasAttribute('data-handler-setup')) {
              categoriesBtn.setAttribute('data-handler-setup', 'true');
              categoriesBtn.addEventListener('click', () => switchFilterMode('categories'));
          }
          if (byPetBtn && !byPetBtn.hasAttribute('data-handler-setup')) {
              byPetBtn.setAttribute('data-handler-setup', 'true');
              byPetBtn.addEventListener('click', () => switchFilterMode('byPet'));
          }
          if (customBtn && !customBtn.hasAttribute('data-handler-setup')) {
              customBtn.setAttribute('data-handler-setup', 'true');
              customBtn.addEventListener('click', () => switchFilterMode('custom'));
          }
  
          // All/None filter buttons (context-aware)
          const selectAllBtn = context.querySelector('#select-all-filters');
          const selectNoneBtn = context.querySelector('#select-none-filters');
  
          if (selectAllBtn && !selectAllBtn.hasAttribute('data-handler-setup')) {
              selectAllBtn.setAttribute('data-handler-setup', 'true');
              selectAllBtn.addEventListener('click', () => {
                  const mode = UnifiedState.data.filterMode || 'categories';
                  selectAllFilters(mode);
              });
          }
  
          if (selectNoneBtn && !selectNoneBtn.hasAttribute('data-handler-setup')) {
              selectNoneBtn.setAttribute('data-handler-setup', 'true');
              selectNoneBtn.addEventListener('click', () => {
                  const mode = UnifiedState.data.filterMode || 'categories';
                  selectNoneFilters(mode);
              });
          }
  
          // Category filter checkboxes - USE CONTEXT-AWARE SELECTORS
          context.querySelectorAll('#category-filters .mga-checkbox[data-filter]').forEach(checkbox => {
              if (!checkbox.hasAttribute('data-handler-setup')) {
                  checkbox.setAttribute('data-handler-setup', 'true');
                  checkbox.addEventListener('change', (e) => {
                      const filterKey = e.target.dataset.filter;
                      UnifiedState.data.abilityFilters[filterKey] = e.target.checked;
                      MGA_saveJSON('MGA_abilityFilters', UnifiedState.data.abilityFilters);
  
                      // PERFORMANCE: Use CSS visibility toggle instead of DOM rebuild
                      updateAllLogVisibility();
                      debugLog('ABILITY_LOGS', `Filter ${filterKey} changed to ${e.target.checked}, updated visibility via CSS`);
                  });
              }
          });
  
          // Basic action buttons
          const clearLogsBtn = context.querySelector('#clear-logs-btn');
          if (clearLogsBtn && !clearLogsBtn.hasAttribute('data-handler-setup')) {
              clearLogsBtn.setAttribute('data-handler-setup', 'true');
              clearLogsBtn.addEventListener('click', () => {
                  logDebug('ABILITY-LOGS', 'Starting comprehensive ability log clear...');
  
                  // BEFORE CLEAR: Show what exists in each storage
                  const beforeClear = {
                      memory: UnifiedState.data.petAbilityLogs?.length || 0,
                      gmMain: (() => { try { const v = GM_getValue('MGA_petAbilityLogs', null); return v ? JSON.parse(v).length : 0; } catch(e) { return 0; }})(),
                      gmArchive: (() => { try { const v = GM_getValue('MGA_petAbilityLogs_archive', null); return v ? JSON.parse(v).length : 0; } catch(e) { return 0; }})(),
                      lsMain: (() => { try { const v = window.localStorage?.getItem('MGA_petAbilityLogs'); return v ? JSON.parse(v).length : 0; } catch(e) { return 0; }})(),
                      lsArchive: (() => { try { const v = window.localStorage?.getItem('MGA_petAbilityLogs_archive'); return v ? JSON.parse(v).length : 0; } catch(e) { return 0; }})()
                  };
  
                  logDebug('ABILITY-LOGS', 'üìä BEFORE CLEAR - Log counts:', beforeClear);
  
                  // Show individual logs from memory (to identify which one won't delete)
                  if (UnifiedState.data.petAbilityLogs?.length > 0) {
                      logDebug('ABILITY-LOGS', 'üìã Current logs in memory:');
                      UnifiedState.data.petAbilityLogs.forEach((log, i) => {
                          logDebug('ABILITY-LOGS', `  ${i + 1}. ${log.abilityType} - ${log.petName} - ${new Date(log.timestamp).toLocaleString()}`);
                      });
                  }
  
                  // 1. Clear memory
                  UnifiedState.data.petAbilityLogs = [];
                  logDebug('ABILITY-LOGS', '  ‚úì Cleared UnifiedState memory');
  
                  // 2. Clear GM storage (Tampermonkey)
                  MGA_saveJSON('MGA_petAbilityLogs', []);
                  MGA_saveJSON('MGA_petAbilityLogs_archive', []);
                  logDebug('ABILITY-LOGS', '  ‚úì Cleared GM storage (main + archive)');
  
                  // 3. Clear window.localStorage directly (bypass sync logic)
                  try {
                      window.localStorage?.removeItem('MGA_petAbilityLogs');
                      window.localStorage?.removeItem('MGA_petAbilityLogs_archive');
                      logDebug('ABILITY-LOGS', '  ‚úì Cleared window.localStorage');
                  } catch (e) {
                      logWarn('ABILITY-LOGS', '  ‚ö†Ô∏è Could not clear window.localStorage:', e.message);
                  }
  
                  // 4. Clear targetWindow.localStorage (if different from window)
                  try {
                      if (typeof targetWindow !== 'undefined' && targetWindow && targetWindow !== window) {
                          targetWindow.localStorage?.removeItem('MGA_petAbilityLogs');
                          targetWindow.localStorage?.removeItem('MGA_petAbilityLogs_archive');
                          logDebug('ABILITY-LOGS', '  ‚úì Cleared targetWindow.localStorage');
                      }
                  } catch (e) {
                      logWarn('ABILITY-LOGS', '  ‚ö†Ô∏è Could not clear targetWindow.localStorage:', e.message);
                  }
  
                  // 5. Clear compatibility array (old mainscript.txt)
                  try {
                      if (typeof window.petAbilityLogs !== 'undefined') {
                          window.petAbilityLogs = [];
                          logDebug('ABILITY-LOGS', '  ‚úì Cleared window.petAbilityLogs compatibility array');
                      }
                  } catch (e) {
                      logWarn('ABILITY-LOGS', '  ‚ö†Ô∏è Could not clear compatibility array:', e.message);
                  }
  
                  // 6. Set comprehensive clear flags with timestamp-based session lock
                  const clearTimestamp = Date.now();
                  localStorage.setItem('MGA_logs_manually_cleared', clearTimestamp.toString());
                  localStorage.setItem('MGA_logs_clear_session', clearTimestamp.toString());
                  try {
                      GM_setValue('MGA_logs_manually_cleared', clearTimestamp.toString());
                  } catch(e) {
                      logWarn('ABILITY-LOGS', '  ‚ö†Ô∏è Could not set GM clear flag:', e.message);
                  }
                  logDebug('ABILITY-LOGS', '  ‚úì Set manual clear flags (session + GM + timestamp)');
  
                  // 7. AFTER CLEAR: Comprehensive verification
                  const verifyMain = MGA_loadJSON('MGA_petAbilityLogs', null);
                  const verifyArchive = MGA_loadJSON('MGA_petAbilityLogs_archive', null);
                  const verifyLS = window.localStorage?.getItem('MGA_petAbilityLogs');
                  const verifyCompat = typeof window.petAbilityLogs !== 'undefined' ? window.petAbilityLogs?.length : 'N/A';
  
                  // Recount all sources after clear
                  const afterClear = {
                      memory: UnifiedState.data.petAbilityLogs?.length || 0,
                      gmMain: verifyMain?.length || 0,
                      gmArchive: verifyArchive?.length || 0,
                      lsMain: verifyLS ? (() => { try { return JSON.parse(verifyLS).length; } catch(e) { return 'parse-error'; }})() : 0,
                      lsArchive: (() => { try { const v = window.localStorage?.getItem('MGA_petAbilityLogs_archive'); return v ? JSON.parse(v).length : 0; } catch(e) { return 0; }})(),
                      compatArray: verifyCompat
                  };
  
                  logDebug('ABILITY-LOGS', 'üìä AFTER CLEAR - Log counts:', afterClear);
                  logDebug('ABILITY-LOGS', 'üìä COMPARISON:', {
                      before: beforeClear,
                      after: afterClear,
                      clearedFlag: localStorage.getItem('MGA_logs_manually_cleared')
                  });
  
                  // If ANY logs remain, show which ones
                  const totalRemaining = Object.values(afterClear).reduce((sum, val) =>
                      sum + (typeof val === 'number' ? val : 0), 0
                  );
  
                  if (totalRemaining > 0) {
                      productionWarn(`‚ö†Ô∏è [ABILITIES] ${totalRemaining} log(s) persist after clear!`);
                      logDebug('ABILITY-LOGS', 'üîç Logs that persisted - check these sources:', afterClear);
  
                      // Show which specific logs remain (if any)
                      if (verifyMain && verifyMain.length > 0) {
                          logDebug('ABILITY-LOGS', '‚ùå PERSISTENT LOGS IN GM STORAGE:');
                          verifyMain.forEach((log, i) => {
                              logDebug('ABILITY-LOGS', `  ${i + 1}. ${log.abilityType} - ${log.petName} - ${new Date(log.timestamp).toLocaleString()}`);
                          });
                      }
                  } else {
                      productionLog('‚úÖ [ABILITIES] Successfully cleared all ability logs from all storage locations');
                  }
  
                  lastLogCount = 0; // Reset log count tracker
                  updateTabContent();
                  updateAllAbilityLogDisplays();
              });
          }
  
          const exportLogsBtn = context.querySelector('#export-logs-btn');
          if (exportLogsBtn && !exportLogsBtn.hasAttribute('data-handler-setup')) {
              exportLogsBtn.setAttribute('data-handler-setup', 'true');
              exportLogsBtn.addEventListener('click', () => {
                  exportAbilityLogs();
              });
          }
  
          // Diagnose logs button (only visible when debug mode is enabled)
          const diagnoseLogsBtn = context.querySelector('#diagnose-logs-btn');
          if (diagnoseLogsBtn && !diagnoseLogsBtn.hasAttribute('data-handler-setup')) {
              diagnoseLogsBtn.setAttribute('data-handler-setup', 'true');
              diagnoseLogsBtn.addEventListener('click', () => {
                  console.log('üîç Running ability logs storage diagnostic...');
                  const report = MGA_diagnoseAbilityLogStorage();
  
                  // Show a user-friendly notification
                  const totalWithLogs = report.summary.totalLocationsWithLogs;
                  if (totalWithLogs === 0) {
                      showNotificationToast('‚úÖ No ability logs found in any storage location', 'success');
                  } else {
                      showNotificationToast(`üìä Found logs in ${totalWithLogs} storage location(s). Check console for details.`, 'info');
                  }
              });
          }
  
          // Detailed timestamps checkbox
          const detailedTimestampsCheckbox = context.querySelector('#detailed-timestamps-checkbox');
          if (detailedTimestampsCheckbox && !detailedTimestampsCheckbox.hasAttribute('data-handler-setup')) {
              detailedTimestampsCheckbox.setAttribute('data-handler-setup', 'true');
              detailedTimestampsCheckbox.addEventListener('change', (e) => {
                  UnifiedState.data.settings.detailedTimestamps = e.target.checked;
                  MGA_saveJSON('MGA_data', UnifiedState.data);
  
                  // Clear timestamp cache and force full rebuild for timestamp format change
                  MGA_AbilityCache.timestamps.clear();
  
                  // BUGFIX: Force overlay refresh to show new timestamp format
                  // Update all overlays first to ensure they show the new format
                  UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                      if (tabName === 'abilities' && overlay && overlay.offsetParent !== null) {
                          updateAbilityLogDisplay(overlay);
                          debugLog('ABILITY_LOGS', 'Updated overlay with new timestamp format');
                      }
                  });
  
                  // Then update main displays
                  updateAllAbilityLogDisplays(true);
                  productionLog(`üïê [ABILITIES] Detailed timestamps: ${e.target.checked ? 'enabled' : 'disabled'}`);
              });
          }
  
          // Test Abilities button removed - function kept for potential debugging use
  
          // Initialize the current filter mode display
          const currentMode = UnifiedState.data.filterMode || 'categories';
          setTimeout(() => populateFilterModeContent(currentMode), 100);
      }
  
      // PERFORMANCE OPTIMIZATION: Caching for expensive operations
      const MGA_AbilityCache = {
          categories: new Map(),
          timestamps: new Map(),
          normalizedNames: new Map(),
          lastTimestampUpdate: 0
      };
  
      // Clear timestamp cache every minute (timestamps change over time)
      setInterval(() => {
          MGA_AbilityCache.timestamps.clear();
          MGA_AbilityCache.lastTimestampUpdate = Date.now();
      }, 60000);
  
      // Comprehensive ability categorization logic based on Pet Ability Logs 4
      function categorizeAbility(abilityType) {
          const cleanType = (abilityType || '').toLowerCase();
  
          // üí´ XP Boost (for pet experience)
          if (cleanType.includes('xp') && cleanType.includes('boost')) {
              return 'xp-boost';
          }
          if (cleanType.includes('hatch') && cleanType.includes('xp')) {
              return 'xp-boost';
          }
  
          // üìà Crop Size Boost (for scaling crops)
          if (cleanType.includes('crop') && (cleanType.includes('size') || cleanType.includes('scale'))) {
              return 'crop-size-boost';
          }
  
          // üí∞ Selling (for selling crops/pets)
          if (cleanType.includes('sell') && cleanType.includes('boost')) {
              return 'selling';
          }
          if (cleanType.includes('refund')) {
              return 'selling';
          }
  
          // üåæ Harvesting (for harvesting crops)
          if (cleanType.includes('double') && cleanType.includes('harvest')) {
              return 'harvesting';
          }
  
          // üê¢ Growth Speed (plant and egg growth)
          if (cleanType.includes('growth') && cleanType.includes('boost')) {
              return 'growth-speed';
          }
          if (cleanType.includes('plant') && cleanType.includes('growth')) {
              return 'growth-speed';
          }
          if (cleanType.includes('egg') && cleanType.includes('growth')) {
              return 'growth-speed';
          }
  
          // üåà‚ú® Special Mutations (Rainbow/Gold conversion)
          if (cleanType.includes('rainbow') || cleanType.includes('gold')) {
              return 'special-mutations';
          }
  
          // üîß Other (passive abilities, pet management, etc.)
          return 'other';
      }
  
      function updateAbilityLogDisplay(context = document) {
          const abilityLogs = context.querySelector('#ability-logs');
          if (!abilityLogs) {
              debugLog('ABILITY_LOGS', 'No ability logs element found in context', {
                  isDocument: context === document,
                  className: context.className || 'unknown'
              });
              return;
          }
  
          // Preserve drag state if this is a content-only overlay being updated
          const isOverlay = context.classList?.contains('mga-overlay-content-only');
          const isDragInProgress = context.getAttribute?.('data-dragging') === 'true';
          if (isOverlay && isDragInProgress) {
              debugLog('ABILITY_LOGS', 'Skipping content update during drag operation', {
                  overlayId: context.id
              });
              return;
          }
  
          const logs = MGA_getAllLogs(); // Show all logs including archived - user requested 100% persistence
          const filteredLogs = logs.filter(log => {
              return shouldLogAbility(log.abilityType, log.petName);
          });
  
          debugLog('ABILITY_LOGS', 'Updating ability log display', {
              totalLogs: logs.length,
              filteredLogs: filteredLogs.length,
              filterMode: UnifiedState.data.filterMode
          });
  
          const htmlParts = [];
          filteredLogs.forEach((log, index) => {
              const category = categorizeAbilityToFilterKey(log.abilityType);
              const categoryData = {
                  xpBoost: { icon: 'üí´', color: '#4a9eff', label: 'XP Boost' },
                  cropSizeBoost: { icon: 'üìà', color: '#10b981', label: 'Crop Size' },
                  selling: { icon: 'üí∞', color: '#f59e0b', label: 'Selling' },
                  harvesting: { icon: 'üåæ', color: '#84cc16', label: 'Harvesting' },
                  growthSpeed: { icon: 'üê¢', color: '#06b6d4', label: 'Growth Speed' },
                  specialMutations: { icon: 'üåà‚ú®', color: '#8b5cf6', label: 'Special' },
                  other: { icon: 'üîß', color: '#6b7280', label: 'Other' }
              };
  
              const catData = categoryData[category] || categoryData.other;
              const formattedTime = formatTimestamp(log.timestamp);
              const isRecent = (Date.now() - log.timestamp) < 10000; // Less than 10 seconds ago
              const displayAbilityName = normalizeAbilityName(log.abilityType);
  
              htmlParts.push(`
                  <div class="mga-log-item ${isRecent ? 'mga-log-recent' : ''}" data-category="${category}" data-ability-type="${log.abilityType}" data-pet-name="${log.petName}" style="--category-color: ${catData.color}">
                      <div class="mga-log-header">
                          <span class="mga-log-icon">${catData.icon}</span>
                          <span class="mga-log-meta">
                              <span class="mga-log-pet" style="color: ${catData.color}; font-weight: 600;">${log.petName}</span>
                              <span class="mga-log-time">${formattedTime}</span>
                          </span>
                      </div>
                      <div class="mga-log-ability">${displayAbilityName}</div>
                      ${log.data && Object.keys(log.data).length > 0 ?
                          `<div class="mga-log-details">${formatLogData(log.data)}</div>` : ''}
                  </div>
              `);
          });
  
          // PERFORMANCE: Use DocumentFragment for batch DOM updates
          const fragment = targetDocument.createDocumentFragment();
          const tempContainer = targetDocument.createElement('div');
  
          if (htmlParts.length === 0) {
              const mode = UnifiedState.data.filterMode || 'categories';
              const modeText = mode === 'categories' ? 'category filters' :
                              mode === 'byPet' ? 'pet filters' :
                              'custom filters';
              tempContainer.innerHTML = `<div class="mga-log-empty">
                  <div style="color: #888; text-align: center; padding: 20px;">
                      <div style="font-size: 24px; margin-bottom: 8px;">üìã</div>
                      <div>No abilities match the current ${modeText}</div>
                      <div style="font-size: 11px; margin-top: 4px; opacity: 0.7;">Try adjusting your filter settings</div>
                  </div>
              </div>`;
          } else {
              tempContainer.innerHTML = htmlParts.join('');
              // Auto-scroll to newest if there are new entries
              setTimeout(() => {
                  if (abilityLogs.scrollHeight > abilityLogs.clientHeight) {
                      abilityLogs.scrollTop = 0; // Scroll to top (newest entries)
                  }
              }, 100);
          }
  
          // Move all children to fragment, then update DOM once
          while (tempContainer.firstChild) {
              fragment.appendChild(tempContainer.firstChild);
          }
  
          abilityLogs.innerHTML = '';
          abilityLogs.appendChild(fragment);
  
          // Add enhanced log styles if not already present
          if (!context.querySelector('#mga-log-styles')) {
              const logStyles = targetDocument.createElement('style');
              logStyles.id = 'mga-log-styles';
              logStyles.textContent = `
                  .mga-log-item {
                      margin: 4px 0;
                      padding: 8px;
                      border-radius: 4px;
                      background: rgba(255, 255, 255, 0.02);
                      border-left: 2px solid var(--category-color, #6b7280);
                      transition: all 0.2s ease;
                      font-size: 11px;
                      line-height: 1.3;
                  }
  
                  .mga-log-item:hover {
                      background: rgba(255, 255, 255, 0.05);
                      transform: translateX(2px);
                  }
  
                  .mga-log-recent {
                      background: rgba(74, 158, 255, 0.30);
                      border-color: #4a9eff;
                      box-shadow: 0 0 8px rgba(74, 158, 255, 0.3);
                      animation: mgaLogPulse 2s ease-out;
                  }
  
                  @keyframes mgaLogPulse {
                      0% { box-shadow: 0 0 8px rgba(74, 158, 255, 0.6); }
                      100% { box-shadow: 0 0 8px rgba(74, 158, 255, 0.3); }
                  }
  
                  .mga-log-header {
                      display: flex;
                      align-items: center;
                      gap: 6px;
                      margin-bottom: 2px;
                  }
  
                  .mga-log-icon {
                      font-size: 12px;
                  }
  
                  .mga-log-meta {
                      display: flex;
                      align-items: center;
                      gap: 8px;
                      flex: 1;
                  }
  
                  .mga-log-pet {
                      font-weight: 600;
                      font-size: 11px;
                  }
  
                  .mga-log-time {
                      font-size: 9px;
                      color: rgba(255, 255, 255, 0.6);
                      margin-left: auto;
                  }
  
                  .mga-log-ability {
                      color: rgba(255, 255, 255, 0.9);
                      font-size: 10px;
                      margin: 2px 0 0 18px;
                  }
  
                  .mga-log-details {
                      font-size: 9px;
                      color: rgba(255, 255, 255, 0.5);
                      margin: 2px 0 0 18px;
                      font-style: italic;
                  }
  
                  .mga-log-empty {
                      text-align: center;
                      padding: 20px;
                      color: #888;
                  }
              `;
              (context.head || context.querySelector('head') || targetDocument.head).appendChild(logStyles);
          }
      }
  
      function formatRelativeTime(timestamp) {
          const now = Date.now();
          const diff = now - timestamp;
  
          if (diff < 60000) { // Less than 1 minute
              const seconds = Math.floor(diff / 1000);
              return `${seconds}s ago`;
          } else if (diff < 3600000) { // Less than 1 hour
              const minutes = Math.floor(diff / 60000);
              return `${minutes}m ago`;
          } else if (diff < 86400000) { // Less than 1 day
              const hours = Math.floor(diff / 3600000);
              return `${hours}h ago`;
          } else {
              return new Date(timestamp).toLocaleDateString();
          }
      }
  
      function formatLogData(data) {
          if (!data || typeof data !== 'object') return '';
  
          const formatted = Object.entries(data)
              .filter(([key, value]) => value !== null && value !== undefined)
              .map(([key, value]) => `${key}: ${value}`)
              .join(', ');
  
          return formatted.length > 60 ? formatted.substring(0, 60) + '...' : formatted;
      }
  
      // Update ability logs across ALL overlays and contexts
      // OPTIMIZED: Track log count to skip unnecessary updates
      let lastLogCount = 0;
  
      function updateAllAbilityLogDisplays(force = false) {
          // OPTIMIZED: Skip if no new logs (unless forced by settings change)
          const currentLogCount = UnifiedState.data.petAbilityLogs?.length || 0;
          if (!force && currentLogCount === lastLogCount) {
              debugLog('ABILITY_LOGS', 'Skipping update - no new logs');
              return;
          }
          lastLogCount = currentLogCount;
  
          debugLog('ABILITY_LOGS', 'Updating ability logs across all contexts');
  
          // Update main document context
          updateAbilityLogDisplay(document);
  
          // OPTIMIZED: Only query DOM once and filter for visible overlays and widgets
          const allOverlays = targetDocument.querySelectorAll('.mga-overlay-content-only, .mga-overlay, .mgh-popout');
          allOverlays.forEach(overlay => {
              // Skip if hidden
              if (overlay.offsetParent === null) return;
  
              if (overlay.querySelector('#ability-logs')) {
                  updateAbilityLogDisplay(overlay);
                  debugLog('ABILITY_LOGS', 'Updated overlay/widget ability logs', { overlayId: overlay.id || overlay.className });
              }
          });
  
          // BUGFIX: Update separate window pop-outs in real-time
          UnifiedState.data.popouts.windows.forEach((windowRef, tabName) => {
              if (windowRef && !windowRef.closed && tabName === 'abilities') {
                  try {
                      // Method 1: Direct DOM manipulation (most reliable)
                      const popoutContent = windowRef.document?.getElementById('popout-content');
                      if (popoutContent) {
                          // Get fresh content from main window
                          const freshContent = getAbilitiesTabContent();
                          popoutContent.innerHTML = freshContent;
  
                          // Re-run handlers in the pop-out window context
                          if (typeof setupAbilitiesTabHandlers === 'function') {
                              setupAbilitiesTabHandlers.call(window, windowRef.document);
                          }
                          debugLog('ABILITY_LOGS', 'Updated pop-out via direct DOM manipulation');
                      } else {
                          debugLog('ABILITY_LOGS', 'Pop-out content element not found, trying fallback');
  
                          // Fallback: Try to call the refresh function if it exists
                          if (windowRef.refreshPopoutContent && typeof windowRef.refreshPopoutContent === 'function') {
                              windowRef.refreshPopoutContent('abilities');
                              debugLog('ABILITY_LOGS', 'Updated pop-out via refresh function');
                          }
                      }
                  } catch (e) {
                      debugLog('ABILITY_LOGS', 'Error updating separate window:', e.message);
  
                      // Last resort: Force reload (disruptive but ensures fresh data)
                      try {
                          windowRef.location.reload();
                          debugLog('ABILITY_LOGS', 'Forced pop-out refresh via reload');
                      } catch (e2) {
                          // Window is truly dead, clean up reference
                          debugLog('ABILITY_LOGS', 'Window is dead, removing reference');
                          UnifiedState.data.popouts.windows.delete(tabName);
                      }
                  }
              }
          });
      }
  
      // PERFORMANCE OPTIMIZATION: CSS-based filtering instead of DOM rebuild
      function updateLogVisibility(context = document) {
          const abilityLogs = context.querySelector('#ability-logs');
          if (!abilityLogs) return;
  
          const filterMode = UnifiedState.data.filterMode || 'categories';
          const logItems = abilityLogs.querySelectorAll('.mga-log-item');
  
          debugLog('ABILITY_LOGS', 'Updating log visibility via CSS', {
              filterMode,
              totalItems: logItems.length
          });
  
          logItems.forEach(item => {
              let shouldShow = false;
  
              if (filterMode === 'categories') {
                  const category = item.dataset.category;
                  shouldShow = UnifiedState.data.abilityFilters[category] || false;
              } else if (filterMode === 'byPet') {
                  const petName = item.dataset.petName;
                  shouldShow = UnifiedState.data.petFilters.selectedPets[petName] || false;
              } else if (filterMode === 'custom') {
                  const abilityType = item.dataset.abilityType;
                  shouldShow = UnifiedState.data.customAbilityFilters[abilityType] || false;
              }
  
              item.style.display = shouldShow ? '' : 'none';
          });
      }
  
      // Apply visibility update to all contexts
      function updateAllLogVisibility() {
          debugLog('ABILITY_LOGS', 'Updating log visibility across all contexts');
  
          updateLogVisibility(document);
  
          const allOverlays = targetDocument.querySelectorAll('.mga-overlay-content-only, .mga-overlay');
          allOverlays.forEach(overlay => {
              if (overlay.offsetParent === null) return;
              if (overlay.querySelector('#ability-logs')) {
                  updateLogVisibility(overlay);
              }
          });
      }
  
      function addTestAbilities() {
          const testLogs = [
              // üí´ XP Boost
              { petName: 'Goat', abilityType: 'XP Boost I', timestamp: Date.now() - 1000 },
              { petName: 'Peacock', abilityType: 'XP Boost II', timestamp: Date.now() - 2000 },
              { petName: 'Pig', abilityType: 'Hatch XP Boost I', timestamp: Date.now() - 3000 },
              { petName: 'Goat', abilityType: 'Hatch XP Boost II', timestamp: Date.now() - 4000 },
  
              // üìà Crop Size Boost
              { petName: 'Bee', abilityType: 'Crop Size Boost I', timestamp: Date.now() - 5000 },
              { petName: 'Butterfly', abilityType: 'Crop Size Boost II', timestamp: Date.now() - 6000 },
  
              // üí∞ Selling
              { petName: 'Bunny', abilityType: 'Sell Boost I', timestamp: Date.now() - 7000 },
              { petName: 'Pig', abilityType: 'Sell Boost II', timestamp: Date.now() - 8000 },
              { petName: 'Squirrel', abilityType: 'Sell Boost III', timestamp: Date.now() - 9000 },
              { petName: 'Peacock', abilityType: 'Sell Boost IV', timestamp: Date.now() - 10000 },
              { petName: 'Capybara', abilityType: 'Crop Refund', timestamp: Date.now() - 11000 },
              { petName: 'Chicken', abilityType: 'Pet Refund I', timestamp: Date.now() - 12000 },
  
              // üåæ Harvesting
              { petName: 'Capybara', abilityType: 'Double Harvest', timestamp: Date.now() - 13000 },
  
              // üê¢ Growth Speed
              { petName: 'Cow', abilityType: 'Plant Growth Boost I', timestamp: Date.now() - 14000 },
              { petName: 'Turtle', abilityType: 'Plant Growth Boost II', timestamp: Date.now() - 15000 },
              { petName: 'Chicken', abilityType: 'Egg Growth Boost I', timestamp: Date.now() - 16000 },
              { petName: 'Turtle', abilityType: 'Egg Growth Boost II', timestamp: Date.now() - 17000 },
  
              // üåà‚ú® Special Mutations
              { petName: 'Test Pet', abilityType: 'Rainbow Granter', timestamp: Date.now() - 18000 },
              { petName: 'Test Pet', abilityType: 'Gold Granter', timestamp: Date.now() - 19000 },
  
              // üîß Other
              { petName: 'Snail', abilityType: 'Coin Finder I', timestamp: Date.now() - 20000 },
              { petName: 'Bunny', abilityType: 'Coin Finder II', timestamp: Date.now() - 21000 },
              { petName: 'Squirrel', abilityType: 'Coin Finder III', timestamp: Date.now() - 22000 },
              { petName: 'Worm', abilityType: 'Seed Finder I', timestamp: Date.now() - 23000 },
              { petName: 'Cow', abilityType: 'Seed Finder II', timestamp: Date.now() - 24000 },
              { petName: 'Butterfly', abilityType: 'Seed Finder III', timestamp: Date.now() - 25000 },
              { petName: 'Worm', abilityType: 'Crop Eater', timestamp: Date.now() - 26000 },
              { petName: 'Cow', abilityType: 'Hunger Boost I', timestamp: Date.now() - 27000 },
              { petName: 'Turtle', abilityType: 'Hunger Boost II', timestamp: Date.now() - 28000 },
              { petName: 'Pig', abilityType: 'Max Strength Boost I', timestamp: Date.now() - 29000 },
              { petName: 'Goat', abilityType: 'Max Strength Boost II', timestamp: Date.now() - 30000 }
          ];
  
          testLogs.forEach(log => {
              log.timeString = new Date(log.timestamp).toLocaleTimeString();
              UnifiedState.data.petAbilityLogs.unshift(log);
          });
  
          // Apply memory management to keep recent logs in memory, archive older ones
          UnifiedState.data.petAbilityLogs = MGA_manageLogMemory(UnifiedState.data.petAbilityLogs);
  
          // Use debounced save to reduce I/O operations
          // Only save if not in clear session
          const clearSession = localStorage.getItem('MGA_logs_clear_session');
          if (!clearSession || (Date.now() - parseInt(clearSession, 10)) > 86400000) {
              MGA_debouncedSave('MGA_petAbilityLogs', UnifiedState.data.petAbilityLogs);
          } else {
              logDebug('ABILITY-LOGS', '‚è∏Ô∏è Skipping save - clear session active');
          }
          productionLog('Added comprehensive test abilities covering all 7 categories!');
      }
  
      // PAL4 Filter System Functions
      function switchFilterMode(mode) {
          UnifiedState.data.filterMode = mode;
          MGA_saveJSON('MGA_filterMode', mode);
  
          // Update button states
          targetDocument.querySelectorAll('[id^="filter-mode-"]').forEach(btn => btn.classList.remove('active'));
          document.getElementById(`filter-mode-${mode === 'byPet' ? 'bypet' : mode}`)?.classList.add('active');
  
          // Update description
          const descriptions = {
              categories: 'Filter by ability categories',
              byPet: 'Filter by pet species',
              custom: 'Filter by individual abilities'
          };
          const descEl = document.getElementById('filter-mode-description');
          if (descEl) descEl.textContent = descriptions[mode];
  
          // Show/hide appropriate filter sections
          document.getElementById('category-filters').style.display = mode === 'categories' ? 'grid' : 'none';
          document.getElementById('pet-filters').style.display = mode === 'byPet' ? 'block' : 'none';
          document.getElementById('custom-filters').style.display = mode === 'custom' ? 'block' : 'none';
  
          // Populate content for the selected mode
          populateFilterModeContent(mode);
          // PERFORMANCE: Use CSS visibility toggle instead of DOM rebuild
          updateAllLogVisibility();
      }
  
      function populateFilterModeContent(mode) {
          if (mode === 'byPet') {
              populatePetSpeciesList();
          } else if (mode === 'custom') {
              populateIndividualAbilities();
          }
      }
  
      function populatePetSpeciesList() {
          const container = document.getElementById('pet-species-list');
          if (!container) return;
  
          const pets = getAllUniquePets();
          container.innerHTML = '';
  
          if (pets.length === 0) {
              container.innerHTML = '<div style="color: #888; text-align: center;">No pet species found in logs</div>';
              return;
          }
  
          pets.forEach(pet => {
              const label = targetDocument.createElement('label');
              label.className = 'mga-checkbox-group';
              label.style.display = 'block';
              label.style.marginBottom = '4px';
  
              const checkbox = targetDocument.createElement('input');
              checkbox.type = 'checkbox';
              checkbox.className = 'mga-checkbox';
              checkbox.checked = UnifiedState.data.petFilters.selectedPets[pet] || false;
  
              checkbox.addEventListener('change', (e) => {
                  UnifiedState.data.petFilters.selectedPets[pet] = e.target.checked;
                  MGA_saveJSON('MGA_petFilters', UnifiedState.data.petFilters);
                  // PERFORMANCE: Use CSS visibility toggle instead of DOM rebuild
                  updateAllLogVisibility();
              });
  
              const span = targetDocument.createElement('span');
              span.className = 'mga-label';
              span.textContent = ` ${pet}`;
  
              label.appendChild(checkbox);
              label.appendChild(span);
              container.appendChild(label);
          });
      }
  
      function populateIndividualAbilities() {
          const container = document.getElementById('individual-abilities-list');
          if (!container) return;
  
          const abilities = getAllUniqueAbilities();
          container.innerHTML = '';
  
          if (abilities.length === 0) {
              container.innerHTML = '<div style="color: #888; text-align: center;">No individual abilities found in logs</div>';
              return;
          }
  
          abilities.forEach(ability => {
              const label = targetDocument.createElement('label');
              label.className = 'mga-checkbox-group';
              label.style.display = 'block';
              label.style.marginBottom = '4px';
  
              const checkbox = targetDocument.createElement('input');
              checkbox.type = 'checkbox';
              checkbox.className = 'mga-checkbox';
              checkbox.checked = UnifiedState.data.customMode.selectedAbilities[ability] || false;
  
              checkbox.addEventListener('change', (e) => {
                  UnifiedState.data.customMode.selectedAbilities[ability] = e.target.checked;
                  MGA_saveJSON('MGA_customMode', UnifiedState.data.customMode);
                  // PERFORMANCE: Use CSS visibility toggle instead of DOM rebuild
                  updateAllLogVisibility();
              });
  
              const span = targetDocument.createElement('span');
              span.className = 'mga-label';
              span.textContent = ` ${normalizeAbilityName(ability)}`;
  
              label.appendChild(checkbox);
              label.appendChild(span);
              container.appendChild(label);
          });
      }
  
      function getAllUniquePets() {
          const pets = new Set();
          UnifiedState.data.petAbilityLogs.forEach(log => {
              if (log.petName && log.petName !== 'Test Pet') {
                  pets.add(log.petName);
              }
          });
          return Array.from(pets).sort();
      }
  
      function getAllUniqueAbilities() {
          const abilities = new Set();
          UnifiedState.data.petAbilityLogs.forEach(log => {
              if (log.abilityType) {
                  abilities.add(log.abilityType);
              }
          });
          return Array.from(abilities).sort();
      }
  
      function selectAllFilters(mode) {
          if (mode === 'categories') {
              Object.keys(UnifiedState.data.abilityFilters).forEach(key => {
                  UnifiedState.data.abilityFilters[key] = true;
                  const checkbox = targetDocument.querySelector(`[data-filter="${key}"]`);
                  if (checkbox) checkbox.checked = true;
              });
              MGA_saveJSON('MGA_abilityFilters', UnifiedState.data.abilityFilters);
          } else if (mode === 'byPet') {
              const pets = getAllUniquePets();
              pets.forEach(pet => {
                  UnifiedState.data.petFilters.selectedPets[pet] = true;
              });
              MGA_saveJSON('MGA_petFilters', UnifiedState.data.petFilters);
              populatePetSpeciesList();
          } else if (mode === 'custom') {
              const abilities = getAllUniqueAbilities();
              abilities.forEach(ability => {
                  UnifiedState.data.customMode.selectedAbilities[ability] = true;
              });
              MGA_saveJSON('MGA_customMode', UnifiedState.data.customMode);
              populateIndividualAbilities();
          }
          // PERFORMANCE: Use CSS visibility toggle instead of DOM rebuild
          updateAllLogVisibility();
      }
  
      function selectNoneFilters(mode) {
          if (mode === 'categories') {
              Object.keys(UnifiedState.data.abilityFilters).forEach(key => {
                  UnifiedState.data.abilityFilters[key] = false;
                  const checkbox = targetDocument.querySelector(`[data-filter="${key}"]`);
                  if (checkbox) checkbox.checked = false;
              });
              MGA_saveJSON('MGA_abilityFilters', UnifiedState.data.abilityFilters);
          } else if (mode === 'byPet') {
              UnifiedState.data.petFilters.selectedPets = {};
              MGA_saveJSON('MGA_petFilters', UnifiedState.data.petFilters);
              populatePetSpeciesList();
          } else if (mode === 'custom') {
              UnifiedState.data.customMode.selectedAbilities = {};
              MGA_saveJSON('MGA_customMode', UnifiedState.data.customMode);
              populateIndividualAbilities();
          }
          // PERFORMANCE: Use CSS visibility toggle instead of DOM rebuild
          updateAllLogVisibility();
      }
  
      // Enhanced shouldLogAbility function matching PAL4 logic
      function shouldLogAbility(abilityType, petName = null) {
          // Filter out ProduceMutationBoost abilities - user doesn't want these logged
          if (abilityType && (
              abilityType.includes('ProduceMutationBoost') ||
              abilityType.includes('PetMutationBoost')
          )) {
              return false;
          }
  
          const mode = UnifiedState.data.filterMode || 'categories';
  
          if (mode === 'custom') {
              return UnifiedState.data.customMode.selectedAbilities[abilityType] || false;
          }
  
          if (mode === 'byPet') {
              if (!petName) return false;
              return UnifiedState.data.petFilters.selectedPets[petName] || false;
          }
  
          // Categories mode - use existing categorizeAbility logic
          const category = categorizeAbilityToFilterKey(abilityType);
          return UnifiedState.data.abilityFilters[category] || false;
      }
  
      // Normalize old ability names to current game names
      // This ensures old logged abilities display with their current in-game names
      function normalizeAbilityName(abilityType) {
          if (!abilityType) return abilityType;
  
          // PERFORMANCE: Check cache first
          if (MGA_AbilityCache.normalizedNames.has(abilityType)) {
              return MGA_AbilityCache.normalizedNames.get(abilityType);
          }
  
          // Known ability name changes:
          // "Produce Scale Boost" ‚Üí "Crop Size Boost" (game renamed this ability)
          const normalized = abilityType.replace(/produce\s*scale\s*boost/gi, 'Crop Size Boost');
  
          // PERFORMANCE: Cache result
          MGA_AbilityCache.normalizedNames.set(abilityType, normalized);
  
          return normalized;
      }
  
      function categorizeAbilityToFilterKey(abilityType) {
          // PERFORMANCE: Check cache first
          if (MGA_AbilityCache.categories.has(abilityType)) {
              return MGA_AbilityCache.categories.get(abilityType);
          }
  
          const cleanType = (abilityType || '').toLowerCase();
  
          let category = 'other';
          if (cleanType.includes('xp') && cleanType.includes('boost')) category = 'xpBoost';
          else if (cleanType.includes('hatch') && cleanType.includes('xp')) category = 'xpBoost';
          else if (cleanType.includes('crop') && (cleanType.includes('size') || cleanType.includes('scale'))) category = 'cropSizeBoost';
          else if (cleanType.includes('sell') && cleanType.includes('boost')) category = 'selling';
          else if (cleanType.includes('refund')) category = 'selling';
          else if (cleanType.includes('double') && cleanType.includes('harvest')) category = 'harvesting';
          else if (cleanType.includes('growth') && cleanType.includes('boost')) category = 'growthSpeed';
          else if (cleanType.includes('rainbow') || cleanType.includes('gold')) category = 'specialMutations';
  
          // PERFORMANCE: Cache result
          MGA_AbilityCache.categories.set(abilityType, category);
  
          return category;
      }
  
      function setupSeedsTabHandlers(context = document) {
          // Seed ID mapping for initialization
          const seedIdMap = {
              "Carrot": "Carrot", "Strawberry": "Strawberry", "Aloe": "Aloe",
              "Blueberry": "Blueberry", "Apple": "Apple", "Tulip": "OrangeTulip",
              "Tomato": "Tomato", "Daffodil": "Daffodil", "Sunflower": "Sunflower", "Corn": "Corn",
              "Watermelon": "Watermelon", "Pumpkin": "Pumpkin", "Echeveria": "Echeveria",
              "Coconut": "Coconut", "Banana": "Banana", "Lily": "Lily",
              "BurrosTail": "BurrosTail", "Mushroom": "Mushroom", "Cactus": "Cactus",
              "Bamboo": "Bamboo", "Grape": "Grape", "Pepper": "Pepper",
              "Lemon": "Lemon", "PassionFruit": "PassionFruit", "DragonFruit": "DragonFruit",
              "Lychee": "Lychee", "Starweaver": "Starweaver", "Moonbinder": "Moonbinder", "Dawnbinder": "Dawnbinder"
          };
  
          context.querySelectorAll('.seed-checkbox').forEach(checkbox => {
              // Prevent duplicate event listeners
              if (checkbox.hasAttribute('data-handler-setup')) {
                  return;
              }
              checkbox.setAttribute('data-handler-setup', 'true');
  
              // Initialize checkbox state based on saved seedsToDelete
              const seed = checkbox.dataset.seed;
              const internalId = seedIdMap[seed] || seed;
              if (UnifiedState.data.seedsToDelete.includes(internalId)) {
                  checkbox.checked = true;
              }
  
              checkbox.addEventListener('change', (e) => {
                  const seed = e.target.dataset.seed;
  
                  // Prevent adding protected seeds to deletion list
                  if (e.target.checked && ['Starweaver', 'Moonbinder', 'Dawnbinder', 'Sunflower'].includes(seed)) {
                      e.target.checked = false;
                      const seedType = seed === 'Sunflower' ? 'Divine' : 'Celestial';
                      productionWarn(`‚ùå ${seed} is a protected ${seedType} seed and cannot be deleted!`);
                      return;
                  }
  
                  // Map display name to internal ID for storage (using seedIdMap from function scope)
                  const internalId = seedIdMap[seed] || seed;
  
                  if (e.target.checked) {
                      if (!UnifiedState.data.seedsToDelete.includes(internalId)) {
                          UnifiedState.data.seedsToDelete.push(internalId);
                      }
                  } else {
                      UnifiedState.data.seedsToDelete = UnifiedState.data.seedsToDelete.filter(s => s !== internalId);
                  }
  
                  // Use safe save for critical seed selection data
                  const result = MGA_safeSave('MGA_seedsToDelete', UnifiedState.data.seedsToDelete, {
                      description: `seed selection for "${seed}"`,
                      criticalData: true,
                      showUserAlert: true
                  });
  
                  if (result.success) {
                      productionLog(`‚úÖ [SEED-SELECTION] Successfully saved seed selection change for "${seed}"`);
                  } else {
                      console.error(`‚ùå [SEED-SELECTION] Failed to save seed selection for "${seed}":`, result.error);
                  }
  
                  debugLog('BUTTON_INTERACTIONS', `Seed checkbox changed: ${seed}`, {
                      checked: e.target.checked,
                      seedsToDelete: UnifiedState.data.seedsToDelete
                  });
              });
          });
  
          const autoDeleteCheckbox = context.querySelector('#auto-delete-checkbox');
          if (autoDeleteCheckbox && !autoDeleteCheckbox.hasAttribute('data-handler-setup')) {
              autoDeleteCheckbox.setAttribute('data-handler-setup', 'true');
              autoDeleteCheckbox.addEventListener('change', (e) => {
                  if (e.target.checked) {
                      // Confirmation dialog for enabling auto-delete
                      const selectedSeedsText = UnifiedState.data.seedsToDelete.length > 0 ? UnifiedState.data.seedsToDelete.join(', ') : 'No seeds currently selected';
                      const confirmMessage = `‚ö†Ô∏è WARNING: Auto-Delete will IRREVERSIBLY delete seeds!\n\nSelected seeds for auto-deletion:\n${selectedSeedsText}\n\nAuto-delete will continuously remove these seed types from your inventory as soon as they appear. This action cannot be undone.\n\nAre you sure you want to enable Auto-Delete?`;
  
                      if (!confirm(confirmMessage)) {
                          e.target.checked = false; // Uncheck the box if user cancels
                          return;
                      }
                  }
                  UnifiedState.data.autoDeleteEnabled = e.target.checked;
                  MGA_saveJSON('MGA_autoDeleteEnabled', e.target.checked);
                  if (e.target.checked) {
                      startAutoDelete();
                  }
                  debugLog('BUTTON_INTERACTIONS', `Auto-delete toggled: ${e.target.checked}`);
              });
  
              // Initialize checkbox state from saved settings
              autoDeleteCheckbox.checked = UnifiedState.data.autoDeleteEnabled;
              if (UnifiedState.data.autoDeleteEnabled) {
                  startAutoDelete();
              }
          }
  
          const deleteSelectedBtn = context.querySelector('#delete-selected-btn');
          if (deleteSelectedBtn && !deleteSelectedBtn.hasAttribute('data-handler-setup')) {
              deleteSelectedBtn.setAttribute('data-handler-setup', 'true');
              deleteSelectedBtn.addEventListener('click', () => {
                  deleteSelectedSeeds();
                  debugLog('BUTTON_INTERACTIONS', 'Delete selected seeds button clicked', {
                      seedsToDelete: UnifiedState.data.seedsToDelete
                  });
              });
          }
  
          // Select All Seeds Button
          const selectAllBtn = context.querySelector('#select-all-seeds');
          if (selectAllBtn && !selectAllBtn.hasAttribute('data-handler-setup')) {
              selectAllBtn.setAttribute('data-handler-setup', 'true');
              selectAllBtn.addEventListener('click', () => {
                  context.querySelectorAll('.seed-checkbox').forEach(checkbox => {
                      const seed = checkbox.dataset.seed;
  
                      // Skip protected seeds
                      if (['Starweaver', 'Moonbinder', 'Dawnbinder', 'Sunflower'].includes(seed)) {
                          checkbox.checked = false;
                          return;
                      }
  
                      checkbox.checked = true;
                      // Map to internal ID for storage (using seedIdMap from function scope)
                      const internalId = seedIdMap[seed] || seed;
                      if (!UnifiedState.data.seedsToDelete.includes(internalId)) {
                          UnifiedState.data.seedsToDelete.push(internalId);
                      }
                  });
                  MGA_saveJSON('MGA_seedsToDelete', UnifiedState.data.seedsToDelete);
                  debugLog('BUTTON_INTERACTIONS', 'Selected all seeds');
              });
          }
  
          // Select None Seeds Button
          const selectNoneBtn = context.querySelector('#select-none-seeds');
          if (selectNoneBtn && !selectNoneBtn.hasAttribute('data-handler-setup')) {
              selectNoneBtn.setAttribute('data-handler-setup', 'true');
              selectNoneBtn.addEventListener('click', () => {
                  context.querySelectorAll('.seed-checkbox').forEach(checkbox => {
                      checkbox.checked = false;
                  });
                  UnifiedState.data.seedsToDelete = [];
                  debugLog('BUTTON_INTERACTIONS', 'Deselected all seeds');
              });
          }
  
          // Select Common Seeds Button
          const selectCommonBtn = context.querySelector('#select-common');
          if (selectCommonBtn && !selectCommonBtn.hasAttribute('data-handler-setup')) {
              selectCommonBtn.setAttribute('data-handler-setup', 'true');
              selectCommonBtn.addEventListener('click', () => {
                  const commonSeeds = ["Carrot", "Strawberry", "Aloe"];
                  selectSeedsByList(context, commonSeeds);
                  debugLog('BUTTON_INTERACTIONS', 'Selected common seeds');
              });
          }
  
          // Select Uncommon Seeds Button
          const selectUncommonBtn = context.querySelector('#select-uncommon');
          if (selectUncommonBtn && !selectUncommonBtn.hasAttribute('data-handler-setup')) {
              selectUncommonBtn.setAttribute('data-handler-setup', 'true');
              selectUncommonBtn.addEventListener('click', () => {
                  const uncommonSeeds = ["Apple", "Tulip", "Tomato", "Blueberry"];
                  selectSeedsByList(context, uncommonSeeds);
                  debugLog('BUTTON_INTERACTIONS', 'Selected uncommon seeds');
              });
          }
  
          // Select Rare+ Seeds Button
          const selectRareBtn = context.querySelector('#select-rare');
          if (selectRareBtn && !selectRareBtn.hasAttribute('data-handler-setup')) {
              selectRareBtn.setAttribute('data-handler-setup', 'true');
              selectRareBtn.addEventListener('click', () => {
                  const rareSeeds = ["Daffodil", "Corn", "Watermelon", "Pumpkin", "Echeveria", "Coconut", "Banana", "Lily", "BurrosTail", "Mushroom", "Cactus", "Bamboo", "Grape", "Pepper", "Lemon", "PassionFruit", "DragonFruit", "Lychee"];
                  selectSeedsByList(context, rareSeeds);
                  debugLog('BUTTON_INTERACTIONS', 'Selected rare+ seeds');
              });
          }
  
          // Calculate Value Button
          const calculateValueBtn = context.querySelector('#calculate-value-btn');
          if (calculateValueBtn && !calculateValueBtn.hasAttribute('data-handler-setup')) {
              calculateValueBtn.setAttribute('data-handler-setup', 'true');
              calculateValueBtn.addEventListener('click', () => {
                  calculateSelectedSeedsValue(context);
                  debugLog('BUTTON_INTERACTIONS', 'Calculate seeds value clicked');
              });
          }
      }
  
      // Helper function to select seeds by list
      function selectSeedsByList(context, seedList) {
          // First, clear all selections
          context.querySelectorAll('.seed-checkbox').forEach(checkbox => {
              checkbox.checked = false;
          });
          UnifiedState.data.seedsToDelete = [];
  
          // Then select the specified seeds (excluding protected seeds)
          context.querySelectorAll('.seed-checkbox').forEach(checkbox => {
              const seed = checkbox.dataset.seed;
  
              // Skip protected seeds
              if (['Starweaver', 'Moonbinder', 'Dawnbinder', 'Sunflower'].includes(seed)) {
                  checkbox.checked = false;
                  return;
              }
  
              if (seedList.includes(seed)) {
                  checkbox.checked = true;
                  UnifiedState.data.seedsToDelete.push(seed);
              }
          });
          MGA_saveJSON('MGA_seedsToDelete', UnifiedState.data.seedsToDelete);
      }
  
      // Helper function to calculate selected seeds value
      function calculateSelectedSeedsValue(context) {
          const seedValues = {
              // Common seeds
              "Carrot": 10, "Strawberry": 12, "Aloe": 15,
              // Uncommon seeds
              "Apple": 25, "Tulip": 30, "Tomato": 35, "Blueberry": 40,
              // Rare seeds
              "Daffodil": 75, "Sunflower": 85, "Corn": 80, "Watermelon": 90, "Pumpkin": 100,
              // Legendary seeds
              "Echeveria": 200, "Coconut": 250, "Banana": 300, "Lily": 350, "BurrosTail": 400,
              // Mythical seeds
              "Mushroom": 500, "Cactus": 600, "Bamboo": 750, "Grape": 800,
              // Divine seeds
              "Pepper": 1000, "Lemon": 1200, "PassionFruit": 1500, "DragonFruit": 2000, "Lychee": 2500, "Sunflower": 3000,
              // Celestial seeds
              "Starweaver": 5000, "Moonbinder": 7500, "Dawnbinder": 10000
          };
  
          if (!UnifiedState.atoms.inventory || !UnifiedState.atoms.inventory.items) {
              return;
          }
  
          let totalValue = 0;
          const inventory = UnifiedState.atoms.inventory.items;
  
          UnifiedState.data.seedsToDelete.forEach(seedType => {
              const inventoryItem = inventory.find(item =>
                  item && item.species && (item.species === seedType || item.species === seedType.replace('Tulip', 'OrangeTulip'))
              );
  
              if (inventoryItem) {
                  const quantity = inventoryItem.quantity || 0;
                  const unitValue = seedValues[seedType] || 1;
                  totalValue += quantity * unitValue;
              }
          });
  
          // Show the value display
          const valueDisplay = context.querySelector('#seed-value-display');
          const valueSpan = context.querySelector('#selected-seeds-value');
  
          if (valueDisplay && valueSpan) {
              valueSpan.textContent = totalValue.toLocaleString();
              valueDisplay.style.display = 'block';
  
              // Hide after 5 seconds
              setTimeout(() => {
                  valueDisplay.style.display = 'none';
              }, 5000);
          }
  
          debugLog('BUTTON_INTERACTIONS', `Calculated seeds value: ${totalValue}`, {
              selectedSeeds: UnifiedState.data.seedsToDelete,
              totalValue
          });
      }
  
      // Track current hotkey recording state
      let currentlyRecordingHotkey = null;
  
      function startRecordingHotkey(key, buttonElement) {
          if (currentlyRecordingHotkey) return; // Already recording
  
          currentlyRecordingHotkey = key;
          const originalText = buttonElement.textContent;
          buttonElement.textContent = 'Press any key...';
          buttonElement.style.background = '#ff9900';
  
          // Add one-time key listener
          const recordHandler = (e) => {
              e.preventDefault();
              e.stopPropagation();
  
              // Skip modifier-only keys
              if (['Control', 'Alt', 'Shift', 'Meta'].includes(e.key)) return;
  
              // Allow ESC to cancel
              if (e.key === 'Escape') {
                  stopRecordingHotkey(buttonElement, originalText);
                  document.removeEventListener('keydown', recordHandler, true);
                  return;
              }
  
              // Build key combination string
              let keyCombo = '';
              if (e.ctrlKey) keyCombo += 'ctrl+';
              if (e.altKey) keyCombo += 'alt+';
              if (e.shiftKey) keyCombo += 'shift+';
  
              // Handle special keys
              const keyName = e.key === ' ' ? 'space' : e.key.toLowerCase();
              keyCombo += keyName;
  
              // Check for conflicts
              const conflicts = [];
              Object.entries(UnifiedState.data.hotkeys.gameKeys).forEach(([k, config]) => {
                  if (k !== key && config.custom && config.custom === keyCombo) {
                      conflicts.push(config.name);
                  }
              });
  
              if (conflicts.length > 0) {
                  alert(`Key "${keyCombo}" is already assigned to: ${conflicts.join(', ')}`);
                  stopRecordingHotkey(buttonElement, originalText);
                  document.removeEventListener('keydown', recordHandler, true);
                  return;
              }
  
              // Save the new key
              UnifiedState.data.hotkeys.gameKeys[key].custom = keyCombo;
              MGA_saveJSON('MGA_hotkeys', UnifiedState.data.hotkeys);
  
              stopRecordingHotkey(buttonElement, null);
              updateTabContent(); // Refresh display to show new key and reset button
              document.removeEventListener('keydown', recordHandler, true);
  
              productionLog(`üéÆ [HOTKEYS] Remapped ${key}: ${UnifiedState.data.hotkeys.gameKeys[key].original} ‚Üí ${keyCombo}`);
          };
  
          document.addEventListener('keydown', recordHandler, true);
      }
  
      function stopRecordingHotkey(buttonElement, originalText) {
          if (!currentlyRecordingHotkey) return;
  
          if (originalText) {
              buttonElement.textContent = originalText;
          }
          buttonElement.style.background = '';
          currentlyRecordingHotkey = null;
      }
  
      // ==================== HOTKEY INTERCEPTION & SIMULATION ====================
  
      function isTypingInInput() {
          const active = document.activeElement;
          return active && (
              active.tagName === 'INPUT' ||
              active.tagName === 'TEXTAREA' ||
              active.isContentEditable
          );
      }
  
      function parseKeyCombo(combo) {
          const parts = combo.toLowerCase().split('+');
          return {
              ctrl: parts.includes('ctrl'),
              alt: parts.includes('alt'),
              shift: parts.includes('shift'),
              key: parts[parts.length - 1] === 'space' ? ' ' : parts[parts.length - 1]
          };
      }
  
      function getProperKeyCode(key) {
          // Handle special keys
          const codeMap = {
              ' ': 'Space',
              'space': 'Space',
              'enter': 'Enter',
              'tab': 'Tab',
              'escape': 'Escape',
              'backspace': 'Backspace',
              'delete': 'Delete',
              'arrowup': 'ArrowUp',
              'arrowdown': 'ArrowDown',
              'arrowleft': 'ArrowLeft',
              'arrowright': 'ArrowRight',
              'home': 'Home',
              'end': 'End',
              'pageup': 'PageUp',
              'pagedown': 'PageDown',
              '-': 'Minus',
              '=': 'Equal',
              '[': 'BracketLeft',
              ']': 'BracketRight',
              ';': 'Semicolon',
              "'": 'Quote',
              ',': 'Comma',
              '.': 'Period',
              '/': 'Slash',
              '\\': 'Backslash',
              '`': 'Backquote'
          };
  
          const lowerKey = key.toLowerCase();
  
          // Check special keys map
          if (codeMap[lowerKey]) return codeMap[lowerKey];
  
          // F-keys
          if (/^f([1-9]|1[0-2])$/.test(lowerKey)) {
              return 'F' + lowerKey.substring(1);
          }
  
          // Numbers
          if (/^[0-9]$/.test(key)) {
              return 'Digit' + key;
          }
  
          // Letters
          if (/^[a-z]$/i.test(key)) {
              return 'Key' + key.toUpperCase();
          }
  
          // Fallback - just capitalize
          return key.charAt(0).toUpperCase() + key.slice(1);
      }
  
      function matchesKeyCombo(event, combo) {
          const parsed = parseKeyCombo(combo);
          const eventKey = event.key.toLowerCase();
  
          return (
              event.ctrlKey === parsed.ctrl &&
              event.altKey === parsed.alt &&
              event.shiftKey === parsed.shift &&
              (eventKey === parsed.key || (parsed.key === ' ' && eventKey === ' '))
          );
      }
  
      // Track which remapped keys are currently held down
      const heldRemappedKeys = new Map(); // customKey ‚Üí originalKey
  
      function simulateKeyDown(keyCombo) {
          const parsed = parseKeyCombo(keyCombo);
  
          // Create keydown event
          const downEvent = new KeyboardEvent('keydown', {
              key: parsed.key,
              code: getProperKeyCode(parsed.key),
              ctrlKey: parsed.ctrl,
              altKey: parsed.alt,
              shiftKey: parsed.shift,
              bubbles: true,
              cancelable: true,
              repeat: false // First press
          });
  
          // Dispatch to document (where game listens)
          document.dispatchEvent(downEvent);
      }
  
      function simulateKeyUp(keyCombo) {
          const parsed = parseKeyCombo(keyCombo);
  
          // Create keyup event
          const upEvent = new KeyboardEvent('keyup', {
              key: parsed.key,
              code: getProperKeyCode(parsed.key),
              ctrlKey: parsed.ctrl,
              altKey: parsed.alt,
              shiftKey: parsed.shift,
              bubbles: true,
              cancelable: true
          });
  
          document.dispatchEvent(upEvent);
      }
  
      function handleHotkeyPress(e) {
          // ESC key closes sidebar (always active, even if hotkeys disabled)
          if (e.key === 'Escape' && e.type === 'keydown') {
              const sidebar = document.getElementById('mgh-sidebar');
              if (sidebar && sidebar.classList.contains('open')) {
                  sidebar.classList.remove('open');
                  e.preventDefault();
                  e.stopPropagation();
                  return;
              }
          }

          // Skip if disabled, typing in input, recording a hotkey, or in room search/add room inputs
          const isRoomSearch = e.target && e.target.id === 'room-search-input';
          const isAddRoomInput = e.target && e.target.id === 'add-room-input';
          const isRoomSearchFocused = document.activeElement && document.activeElement.id === 'room-search-input';
          const isAddRoomFocused = document.activeElement && document.activeElement.id === 'add-room-input';

          // CRITICAL: Skip simulated events to prevent infinite loops
          // Simulated events have isTrusted: false, real user keypresses have isTrusted: true
          if (!e.isTrusted) return;

          if (!UnifiedState.data.hotkeys.enabled || isTypingInInput() || currentlyRecordingHotkey || isRoomSearch || isRoomSearchFocused || isAddRoomInput || isAddRoomFocused) return;
  
          const isKeyDown = e.type === 'keydown';
          const isKeyUp = e.type === 'keyup';
  
          // STEP 1: Check each remapped key (custom ‚Üí original)
          for (const [action, config] of Object.entries(UnifiedState.data.hotkeys.gameKeys)) {
              if (config.custom) {
                  // Check if pressed key matches custom mapping
                  if (matchesKeyCombo(e, config.custom)) {
                      e.preventDefault();
                      e.stopPropagation();
  
                      // Special handling for script functions (not game keys)
                      if (action === 'toggleQuickShop') {
                          if (isKeyDown && !e.repeat) {
                              toggleShopWindows();
                              if (UnifiedState.data.settings.debugMode) {
                                  productionLog(`üéÆ [HOTKEYS] Triggered Quick Shop toggle via ${config.custom}`);
                              }
                          }
                          return false;
                      }
  
                      if (isKeyDown) {
                          // Only simulate keydown once per hold (ignore repeat events)
                          if (!e.repeat) {
                              simulateKeyDown(config.original);
                              heldRemappedKeys.set(config.custom, config.original);
                              if (UnifiedState.data.settings.debugMode) {
                                  productionLog(`üéÆ [HOTKEYS] Remapped keydown ${config.custom} ‚Üí ${config.original} (${config.name})`);
                              }
                          }
                      } else if (isKeyUp) {
                          // Simulate keyup when released
                          simulateKeyUp(config.original);
                          heldRemappedKeys.delete(config.custom);
                          if (UnifiedState.data.settings.debugMode) {
                              productionLog(`üéÆ [HOTKEYS] Remapped keyup ${config.custom} ‚Üí ${config.original} (${config.name})`);
                          }
                      }
                      return false;
                  }
              }
          }
  
          // STEP 2: Check for non-remapped script functions using original key
          for (const [action, config] of Object.entries(UnifiedState.data.hotkeys.gameKeys)) {
              if (!config.custom && action === 'toggleQuickShop') {
                  if (matchesKeyCombo(e, config.original)) {
                      if (isKeyDown && !e.repeat) {
                          e.preventDefault();
                          e.stopPropagation();
                          toggleShopWindows();
                          if (UnifiedState.data.settings.debugMode) {
                              productionLog(`üéÆ [HOTKEYS] Triggered Quick Shop toggle via ${config.original}`);
                          }
                          return false;
                      }
                  }
              }
          }
  
          // STEP 3: Suppress original keys that have been remapped
          for (const [action, config] of Object.entries(UnifiedState.data.hotkeys.gameKeys)) {
              if (config.custom && matchesKeyCombo(e, config.original)) {
                  // Original key has been remapped, suppress it
                  e.preventDefault();
                  e.stopPropagation();
                  if (UnifiedState.data.settings.debugMode && !e.repeat) {
                      productionLog(`üö´ [HOTKEYS] Suppressed ${config.original} (remapped to ${config.custom} for ${config.name})`);
                  }
                  return false;
              }
          }
      }
  
      function handleHotkeyRelease(e) {
          // Just call the same handler - it checks e.type
          handleHotkeyPress(e);
      }
  
      // Install hotkey interceptor at highest priority
      function initializeHotkeySystem() {
          document.addEventListener('keydown', handleHotkeyPress, true);
          document.addEventListener('keyup', handleHotkeyRelease, true);
          productionLog('üéÆ [HOTKEYS] Key interception system installed (keydown + keyup)');
      }
  
      function setupHotkeysTabHandlers(context = document) {
          // Enable/disable checkbox
          const enableCheckbox = context.querySelector('#hotkeys-enabled');
          if (enableCheckbox) {
              enableCheckbox.addEventListener('change', (e) => {
                  UnifiedState.data.hotkeys.enabled = e.target.checked;
                  MGA_saveJSON('MGA_hotkeys', UnifiedState.data.hotkeys);
                  productionLog(`üéÆ [HOTKEYS] ${e.target.checked ? 'Enabled' : 'Disabled'}`);
              });
          }
  
          // Hotkey buttons
          context.querySelectorAll('.hotkey-button').forEach(button => {
              button.addEventListener('click', function() {
                  const key = this.dataset.key;
                  startRecordingHotkey(key, this);
              });
          });
  
          // Reset buttons
          context.querySelectorAll('.hotkey-reset').forEach(button => {
              button.addEventListener('click', function() {
                  const key = this.dataset.key;
                  UnifiedState.data.hotkeys.gameKeys[key].custom = null;
                  MGA_saveJSON('MGA_hotkeys', UnifiedState.data.hotkeys);
                  updateTabContent(); // Refresh display
                  productionLog(`üéÆ [HOTKEYS] Reset ${key} to default`);
              });
          });
  
          // Reset all button
          const resetAllBtn = context.querySelector('#hotkeys-reset-all');
          if (resetAllBtn) {
              resetAllBtn.addEventListener('click', () => {
                  if (confirm('Reset all hotkeys to defaults?')) {
                      Object.keys(UnifiedState.data.hotkeys.gameKeys).forEach(key => {
                          UnifiedState.data.hotkeys.gameKeys[key].custom = null;
                      });
                      MGA_saveJSON('MGA_hotkeys', UnifiedState.data.hotkeys);
                      updateTabContent();
                      productionLog('üéÆ [HOTKEYS] Reset all hotkeys to defaults');
                  }
              });
          }
  
          // Export button
          const exportBtn = context.querySelector('#hotkeys-export');
          if (exportBtn) {
              exportBtn.addEventListener('click', () => {
                  const exportData = {};
                  Object.entries(UnifiedState.data.hotkeys.gameKeys).forEach(([key, config]) => {
                      if (config.custom) {
                          exportData[key] = config.custom;
                      }
                  });
                  const json = JSON.stringify(exportData, null, 2);
                  navigator.clipboard.writeText(json);
                  alert('Hotkey configuration copied to clipboard!');
              });
          }
      }
  
      function setupProtectTabHandlers(context = document) {
          // Actual game crop species (from shop)
          const cropSpecies = ['Mushroom', 'Cactus', 'Bamboo', 'Grape', 'Pepper', 'Lemon', 'PassionFruit', 'DragonFruit', 'Lychee', 'Sunflower', 'Starweaver', 'DawnCelestial', 'MoonCelestial'];
          const cropMutations = ['Rainbow', 'Frozen', 'Wet', 'Chilled', 'Gold', 'Lock All Mutations', 'Lock Only Non-Mutated'];

          // Add new setting for frozen exception
          if (!UnifiedState.data.protectionSettings) {
              UnifiedState.data.protectionSettings = {
                  allowFrozenPickup: false  // Allow pickup of protected crops when frozen
              };
          }

          // Initialize locked crops if not exists
          if (!UnifiedState.data.lockedCrops) {
              UnifiedState.data.lockedCrops = { species: [], mutations: [] };
          }
          if (!UnifiedState.data.sellBlockThreshold) {
              UnifiedState.data.sellBlockThreshold = 1.0;
          }
  
          const lockedCrops = UnifiedState.data.lockedCrops;
  
          // Generate species checkboxes
          const speciesList = context.querySelector('#protect-species-list');
          if (speciesList) {
              speciesList.innerHTML = cropSpecies.map(species => `
                  <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 6px; background: rgba(74, 158, 255, 0.30); border-radius: 4px;">
                      <input type="checkbox" class="protect-species-checkbox" value="${species}"
                          ${lockedCrops.species?.includes(species) ? 'checked' : ''}
                          style="cursor: pointer;">
                      <span style="font-size: 12px;">${species}</span>
                  </label>
              `).join('');
          }
  
          // Generate mutation checkboxes
          const mutationsList = context.querySelector('#protect-mutations-list');
          if (mutationsList) {
              mutationsList.innerHTML = cropMutations.map(mutation => `
                  <label style="display: flex; align-items: center; gap: 6px; cursor: pointer; padding: 6px; background: rgba(74, 158, 255, 0.30); border-radius: 4px;">
                      <input type="checkbox" class="protect-mutation-checkbox" value="${mutation}"
                          ${lockedCrops.mutations?.includes(mutation) ? 'checked' : ''}
                          style="cursor: pointer;">
                      <span style="font-size: 12px;">${mutation}</span>
                  </label>
              `).join('');
          }
  
          // Handle species checkbox changes
          context.querySelectorAll('.protect-species-checkbox').forEach(checkbox => {
              checkbox.addEventListener('change', (e) => {
                  const species = e.target.value;
                  if (e.target.checked) {
                      if (!lockedCrops.species.includes(species)) {
                          lockedCrops.species.push(species);
                      }
                  } else {
                      lockedCrops.species = lockedCrops.species.filter(s => s !== species);
                  }
                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  updateProtectStatus(context);
                  applyHarvestRule();
              });
          });
  
          // Handle mutation checkbox changes
          context.querySelectorAll('.protect-mutation-checkbox').forEach(checkbox => {
              checkbox.addEventListener('change', (e) => {
                  const mutation = e.target.value;

                  // Special handling for "Lock All Mutations" - it's a "select all" toggle
                  if (mutation === 'Lock All Mutations') {
                      const allMutationCheckboxes = context.querySelectorAll('.protect-mutation-checkbox');
                      const otherMutations = ['Rainbow', 'Frozen', 'Wet', 'Chilled', 'Gold'];

                      if (e.target.checked) {
                          // Check all other mutation checkboxes
                          allMutationCheckboxes.forEach(cb => {
                              if (cb.value !== 'Lock All Mutations' && cb.value !== 'Lock Only Non-Mutated') {
                                  cb.checked = true;
                                  if (!lockedCrops.mutations.includes(cb.value)) {
                                      lockedCrops.mutations.push(cb.value);
                                  }
                              }
                          });
                      } else {
                          // Uncheck all other mutation checkboxes
                          allMutationCheckboxes.forEach(cb => {
                              if (cb.value !== 'Lock All Mutations' && cb.value !== 'Lock Only Non-Mutated') {
                                  cb.checked = false;
                              }
                          });
                          lockedCrops.mutations = lockedCrops.mutations.filter(m => m === 'Lock Only Non-Mutated');
                      }
                  } else if (mutation === 'Lock Only Non-Mutated') {
                      // Special handling for "Lock Only Non-Mutated" - locks crops with 0 mutations
                      if (e.target.checked) {
                          if (!lockedCrops.mutations.includes(mutation)) {
                              lockedCrops.mutations.push(mutation);
                          }
                      } else {
                          lockedCrops.mutations = lockedCrops.mutations.filter(m => m !== mutation);
                      }
                  } else {
                      // Regular mutation checkbox
                      if (e.target.checked) {
                          if (!lockedCrops.mutations.includes(mutation)) {
                              lockedCrops.mutations.push(mutation);
                          }
                      } else {
                          lockedCrops.mutations = lockedCrops.mutations.filter(m => m !== mutation);
                          // Uncheck "Lock All Mutations" if any individual mutation is unchecked
                          const lockAllCheckbox = context.querySelector('.protect-mutation-checkbox[value="Lock All Mutations"]');
                          if (lockAllCheckbox) {
                              lockAllCheckbox.checked = false;
                          }
                      }
                  }

                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  updateProtectStatus(context);
                  applyHarvestRule();
              });
          });
  
          // Clear all button
          const clearButton = context.querySelector('#protect-clear-all');
          if (clearButton) {
              clearButton.addEventListener('click', () => {
                  lockedCrops.species = [];
                  lockedCrops.mutations = [];
                  MGA_saveJSON('MGA_data', UnifiedState.data);
  
                  // Uncheck all checkboxes
                  context.querySelectorAll('.protect-species-checkbox, .protect-mutation-checkbox').forEach(cb => {
                      cb.checked = false;
                  });
  
                  updateProtectStatus(context);
                  applyHarvestRule();
              });
          }
  
          // Sell threshold slider
          const thresholdSlider = context.querySelector('#protect-sell-threshold');
          const thresholdValue = context.querySelector('#protect-sell-threshold-value');
          if (thresholdSlider) {
              thresholdSlider.addEventListener('input', (e) => {
                  const value = parseFloat(e.target.value);
                  UnifiedState.data.sellBlockThreshold = value;
                  if (thresholdValue) {
                      thresholdValue.textContent = `${value.toFixed(2)}x (${((value - 1) * 100).toFixed(0)}%)`;
                  }
                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  applySellBlockThreshold();
              });
          }

          // Add handler for frozen pickup checkbox
          const frozenCheckbox = context.querySelector('#allow-frozen-pickup');
          if (frozenCheckbox) {
              frozenCheckbox.addEventListener('change', (e) => {
                  if (!UnifiedState.data.protectionSettings) {
                      UnifiedState.data.protectionSettings = {};
                  }
                  UnifiedState.data.protectionSettings.allowFrozenPickup = e.target.checked;
                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  productionLog(`‚ùÑÔ∏è [PROTECTION] Frozen exception: ${e.target.checked ? 'enabled' : 'disabled'}`);
                  applyHarvestRule();
              });
          }

          // Initial status update
          updateProtectStatus(context);
          applyHarvestRule();
          applySellBlockThreshold();
      }
  
      function updateProtectStatus(context = document) {
          const statusDisplay = context.querySelector('#protect-status-display');
          if (!statusDisplay) return;
  
          const lockedCrops = UnifiedState.data.lockedCrops || { species: [], mutations: [] };
          const hasLocks = lockedCrops.species.length > 0 || lockedCrops.mutations.length > 0;
  
          if (!hasLocks) {
              statusDisplay.innerHTML = '<div style="color: #888;">No crops are currently locked.</div>';
              return;
          }
  
          let html = '';
          if (lockedCrops.species.length > 0) {
              html += `<div style="margin-bottom: 8px;"><strong>üîí Locked Species:</strong> ${lockedCrops.species.join(', ')}</div>`;
          }
          if (lockedCrops.mutations.length > 0) {
              html += `<div><strong>üîí Locked Mutations:</strong> ${lockedCrops.mutations.join(', ')}</div>`;
          }
  
          statusDisplay.innerHTML = html;
      }
  
      // ==================== HARVEST & SELL PROTECTION ====================
      function applyHarvestRule() {
          targetWindow.currentHarvestRule = ({ species, mutations } = {}) => {
              // CRITICAL FIX: Read fresh locked crops from UnifiedState each time harvest is attempted
              // This ensures unlocking crops takes effect immediately without requiring page refresh
              const freshLockedCrops = UnifiedState.data.lockedCrops || { species: [], mutations: [] };
              mutations = Array.isArray(mutations) ? mutations : [];

              // Check if crop is frozen
              const isFrozen = mutations.includes('Frozen');
              const allowFrozenPickup = UnifiedState.data.protectionSettings?.allowFrozenPickup || false;

              // If species is locked, check for frozen exception
              if (freshLockedCrops.species && freshLockedCrops.species.includes(species)) {
                  // If frozen exception is enabled and crop is frozen, allow harvest
                  if (isFrozen && allowFrozenPickup) {
                      return true;
                  }
                  return false;
              }

              // Check for "Lock Only Non-Mutated" - locks crops with 0 mutations
              if (freshLockedCrops.mutations && freshLockedCrops.mutations.includes('Lock Only Non-Mutated')) {
                  if (mutations.length === 0) {
                      return false; // Block harvest if crop has no mutations
                  }
              }

              // If any locked mutation is present, check for frozen exception
              if (freshLockedCrops.mutations && freshLockedCrops.mutations.length > 0) {
                  const regularMutations = freshLockedCrops.mutations.filter(m =>
                      m !== 'Lock All Mutations' && m !== 'Lock Only Non-Mutated'
                  );
                  const hasLockedMutation = regularMutations.some(m => mutations.includes(m));
                  if (hasLockedMutation) {
                      // If frozen exception is enabled and crop is frozen, allow harvest
                      if (isFrozen && allowFrozenPickup) {
                          return true;
                      }
                      return false;
                  }
              }

              return true;
          };
      }
  
      function applySellBlockThreshold() {
          targetWindow.sellBlockThreshold = UnifiedState.data.sellBlockThreshold || 1.0;
          console.log(`‚úÖ Sell block threshold set to ${targetWindow.sellBlockThreshold}x`);
      }
  
      // Track RoomConnection retry attempts
      let roomConnectionRetries = 0;
      const MAX_ROOM_CONNECTION_RETRIES = 10;

      function initializeProtectionHooks() {
          // Note: friendBonus and myGarden atoms are already hooked in initializeAtoms()
          // which sets both UnifiedState.atoms and targetWindow values

          // Hook sendMessage to intercept harvest and sell commands
          setTimeout(() => {
              if (!targetWindow.MagicCircle_RoomConnection) {
                  if (roomConnectionRetries < MAX_ROOM_CONNECTION_RETRIES) {
                      roomConnectionRetries++;
                      console.warn(`‚è≥ Waiting for RoomConnection (${roomConnectionRetries}/${MAX_ROOM_CONNECTION_RETRIES})...`);
                      window.location.reload();
                      setTimeout(initializeProtectionHooks, 1000);
                      return;
                  } else {
                      console.warn('‚ö†Ô∏è RoomConnection not found after max retries - continuing without protection hooks');
                      // Continue without it - non-critical feature
                      return;
                  }
              }

              // Reset counter on success
              roomConnectionRetries = 0;
              console.log('‚úÖ MagicCircle_RoomConnection found - initializing protection hooks');
  
              const originalSendMessage = targetWindow.MagicCircle_RoomConnection.sendMessage.bind(targetWindow.MagicCircle_RoomConnection);
  
              targetWindow.MagicCircle_RoomConnection.sendMessage = function(message, ...rest) {
                  try {
                      if (!message || typeof message.type !== "string") {
                          return originalSendMessage(message, ...rest);
                      }
  
                      const friendBonus = targetWindow.friendBonus ?? 1.5;
                      const msgType = message.type;
                      const isSellMessage = msgType === "SellAllCrops" || msgType.toLowerCase().startsWith("sellpet");

                      // Detect in-game shop purchases
                      if (msgType === "PurchaseSeed" && message.species) {
                          if (typeof trackLocalPurchase === 'function') {
                              trackLocalPurchase(message.species, 'seed', 1);
                          }
                      } else if (msgType === "PurchaseEgg" && message.eggId) {
                          if (typeof trackLocalPurchase === 'function') {
                              trackLocalPurchase(message.eggId, 'egg', 1);
                          }
                      } else if (msgType === "PurchaseTool" && message.toolId) {
                          console.log(`üîß [PURCHASE-INTERCEPT] Tool Purchase Detected!`, {
                              toolId: message.toolId,
                              toolIdType: typeof message.toolId,
                              fullMessage: JSON.stringify(message)
                          });
                          if (typeof trackLocalPurchase === 'function') {
                              trackLocalPurchase(message.toolId, 'tool', 1);
                              console.log(`üîß [PURCHASE-INTERCEPT] Called trackLocalPurchase with: "${message.toolId}"`);
                          } else {
                              console.error(`‚ùå [PURCHASE-INTERCEPT] trackLocalPurchase function not available!`);
                          }
                      }
  
                      // Check sell blocking
                      if (isSellMessage && friendBonus < targetWindow.sellBlockThreshold) {
                          console.warn(`[SellBlock] Blocked ${msgType} (friendBonus=${friendBonus} < ${targetWindow.sellBlockThreshold})`);
                          return;
                      }
  
                      // Check harvest blocking
                      if (msgType === "HarvestCrop") {
                          const tile = targetWindow.myGarden?.garden?.tileObjects?.[message.slot];
                          const slotData = tile?.slots?.[message.slotsIndex];
  
                          console.log(`[HarvestCheck] Attempting harvest: slot=${message.slot}, index=${message.slotsIndex}`);
                          console.log(`[HarvestCheck] Tile data:`, tile);
                          console.log(`[HarvestCheck] Slot data:`, slotData);
  
                          if (slotData) {
                              const species = slotData.species;
                              const slotMutations = slotData.mutations || [];
  
                              console.log(`[HarvestCheck] Species: ${species}, Mutations:`, slotMutations);
                              console.log(`[HarvestCheck] currentHarvestRule exists:`, !!targetWindow.currentHarvestRule);
  
                              if (targetWindow.currentHarvestRule && !targetWindow.currentHarvestRule({ species, mutations: slotMutations })) {
                                  console.log(`üîí BLOCKED HarvestCrop: ${species} with mutations [${slotMutations.join(', ')}]`);
                                  return;
                              }
                              console.log(`‚úÖ ALLOWED HarvestCrop: ${species} with mutations [${slotMutations.join(', ')}]`);
                          } else {
                              console.warn(`[HarvestCheck] No slot data found for slot ${message.slot}, index ${message.slotsIndex}`);
                          }
                      }
  
                      return originalSendMessage(message, ...rest);
  
                  } catch (err) {
                      console.error("[SendMessageHook] Error:", err);
                      return originalSendMessage(message, ...rest);
                  }
              };
  
              console.log('‚úÖ Harvest and sell protection hooks installed');
          }, 2000);
  
          // Apply initial rules
          applyHarvestRule();
          applySellBlockThreshold();
      }
  
      function setupNotificationsTabHandlers(context = document) {
          // Notification enabled checkbox
          const notificationEnabledCheckbox = context.querySelector('#notifications-enabled-checkbox');
          if (notificationEnabledCheckbox && !notificationEnabledCheckbox.hasAttribute('data-handler-setup')) {
              notificationEnabledCheckbox.setAttribute('data-handler-setup', 'true');
              notificationEnabledCheckbox.addEventListener('change', (e) => {
                  UnifiedState.data.settings.notifications.enabled = e.target.checked;
                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  productionLog(`üîî [NOTIFICATIONS] ${e.target.checked ? 'Enabled' : 'Disabled'} notifications`);
  
                  // Update quick toggle button if it exists
                  const quickToggle = context.querySelector('#notification-quick-toggle');
                  if (quickToggle) {
                      updateQuickToggleButton(quickToggle, e.target.checked);
                  }
              });
          }
  
          // Quick notification toggle button
          const quickToggleButton = context.querySelector('#notification-quick-toggle');
          if (quickToggleButton && !quickToggleButton.hasAttribute('data-handler-setup')) {
              quickToggleButton.setAttribute('data-handler-setup', 'true');
              quickToggleButton.addEventListener('click', () => {
                  const newState = !UnifiedState.data.settings.notifications.enabled;
                  UnifiedState.data.settings.notifications.enabled = newState;
                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  productionLog(`üîî [NOTIFICATIONS] Quick toggle: ${newState ? 'Enabled' : 'Disabled'} notifications`);
  
                  // Update button appearance
                  updateQuickToggleButton(quickToggleButton, newState);
  
                  // Update checkbox if it exists
                  if (notificationEnabledCheckbox) {
                      notificationEnabledCheckbox.checked = newState;
                  }
              });
          }
  
          // Helper function to update quick toggle button
          function updateQuickToggleButton(button, enabled) {
              button.style.background = enabled ? '#4a9eff' : '#666';
              button.textContent = enabled ? 'üîä Turn OFF Notifications' : 'üîá Turn ON Notifications';
          }
  
          // Volume slider
          const volumeSlider = context.querySelector('#notification-volume-slider');
          if (volumeSlider && !volumeSlider.hasAttribute('data-handler-setup')) {
              volumeSlider.setAttribute('data-handler-setup', 'true');
              volumeSlider.addEventListener('input', (e) => {
                  const volume = parseInt(e.target.value) / 100;
                  UnifiedState.data.settings.notifications.volume = volume;
                  // Update label
                  const label = volumeSlider.previousElementSibling;
                  label.textContent = `Volume: ${Math.round(volume * 100)}%`;
                  MGA_saveJSON('MGA_data', UnifiedState.data);
              });
          }
  
          // Enable Continuous Mode checkbox
          const continuousCheckbox = context.querySelector('#notification-continuous-checkbox');
          if (continuousCheckbox && !continuousCheckbox.hasAttribute('data-handler-setup')) {
              continuousCheckbox.setAttribute('data-handler-setup', 'true');

              // On load: if continuous is already enabled, lock acknowledgment checkbox
              if (UnifiedState.data.settings.notifications.continuousEnabled) {
                  const acknowledgmentCheckbox = context.querySelector('#notification-acknowledgment-checkbox');
                  if (acknowledgmentCheckbox) {
                      acknowledgmentCheckbox.checked = true;
                      acknowledgmentCheckbox.disabled = true;
                      UnifiedState.data.settings.notifications.requiresAcknowledgment = true;
                  }
              }

              continuousCheckbox.addEventListener('change', (e) => {
                  UnifiedState.data.settings.notifications.continuousEnabled = e.target.checked;

                  // When enabling continuous mode, force acknowledgment to be enabled AND disabled (locked)
                  const acknowledgmentCheckbox = context.querySelector('#notification-acknowledgment-checkbox');
                  if (acknowledgmentCheckbox) {
                      if (e.target.checked) {
                          acknowledgmentCheckbox.checked = true;
                          acknowledgmentCheckbox.disabled = true; // Lock it on
                          UnifiedState.data.settings.notifications.requiresAcknowledgment = true;
                          productionLog(`üö® [NOTIFICATIONS] Auto-enabled and locked acknowledgment (required for continuous alarms)`);
                      } else {
                          acknowledgmentCheckbox.disabled = false; // Unlock when continuous is off
                      }
                  }

                  // Update dropdown state
                  const notificationTypeSelect = context.querySelector('#notification-type-select');
                  if (notificationTypeSelect) {
                      const continuousOption = notificationTypeSelect.querySelector('option[value="continuous"]');
                      if (continuousOption) {
                          continuousOption.disabled = !e.target.checked;
  
                          // If unchecking and continuous is selected, change to epic
                          if (!e.target.checked && notificationTypeSelect.value === 'continuous') {
                              notificationTypeSelect.value = 'epic';
                              UnifiedState.data.settings.notifications.notificationType = 'epic';
                              productionLog(`üîä [NOTIFICATIONS] Continuous mode disabled, reverted to epic`);
                          }
                      }
                  }
  
                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  productionLog(`‚ö†Ô∏è [NOTIFICATIONS] Continuous mode enabled: ${e.target.checked}`);
              });
          }
  
          // Notification type selector
          const notificationTypeSelect = context.querySelector('#notification-type-select');
          if (notificationTypeSelect && !notificationTypeSelect.hasAttribute('data-handler-setup')) {
              notificationTypeSelect.setAttribute('data-handler-setup', 'true');

              // Explicitly restore saved value (defensive - ensures dropdown matches saved state)
              const savedNotificationType = UnifiedState.data.settings.notifications.notificationType || 'epic';
              notificationTypeSelect.value = savedNotificationType;
              productionLog(`üîä [NOTIFICATIONS] Restored notification type to: ${savedNotificationType}`);

              // On load: if continuous type is selected, lock acknowledgment checkbox
              if (UnifiedState.data.settings.notifications.notificationType === 'continuous') {
                  const acknowledgmentCheckbox = context.querySelector('#notification-acknowledgment-checkbox');
                  if (acknowledgmentCheckbox) {
                      acknowledgmentCheckbox.checked = true;
                      acknowledgmentCheckbox.disabled = true;
                      UnifiedState.data.settings.notifications.requiresAcknowledgment = true;
                  }
              }

              notificationTypeSelect.addEventListener('change', (e) => {
                  // Prevent selecting continuous if not enabled
                  if (e.target.value === 'continuous' && !UnifiedState.data.settings.notifications.continuousEnabled) {
                      e.target.value = UnifiedState.data.settings.notifications.notificationType || 'epic';
                      productionWarn(`‚ö†Ô∏è [NOTIFICATIONS] Cannot select continuous mode - please enable it first`);
                      showVisualNotification('‚ö†Ô∏è Please enable Continuous Mode checkbox first', false);
                      return;
                  }

                  UnifiedState.data.settings.notifications.notificationType = e.target.value;

                  // When selecting continuous, force acknowledgment to be enabled AND locked
                  const acknowledgmentCheckbox = context.querySelector('#notification-acknowledgment-checkbox');
                  if (acknowledgmentCheckbox) {
                      if (e.target.value === 'continuous') {
                          acknowledgmentCheckbox.checked = true;
                          acknowledgmentCheckbox.disabled = true; // Lock it on
                          UnifiedState.data.settings.notifications.requiresAcknowledgment = true;
                          productionLog(`üö® [NOTIFICATIONS] Auto-enabled and locked acknowledgment (required for continuous alarms)`);
                      } else {
                          // When changing away from continuous, unlock the acknowledgment checkbox
                          // (unless continuous mode checkbox is still enabled)
                          if (!UnifiedState.data.settings.notifications.continuousEnabled) {
                              acknowledgmentCheckbox.disabled = false;
                          }
                      }
                  }

                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  productionLog(`üîä [NOTIFICATIONS] Sound type changed to: ${e.target.value}`);
              });
          }
  
          // Acknowledgment required checkbox
          const acknowledgmentCheckbox = context.querySelector('#notification-acknowledgment-checkbox');
          if (acknowledgmentCheckbox && !acknowledgmentCheckbox.hasAttribute('data-handler-setup')) {
              acknowledgmentCheckbox.setAttribute('data-handler-setup', 'true');

              // Explicitly restore saved value
              acknowledgmentCheckbox.checked = UnifiedState.data.settings.notifications.requiresAcknowledgment || false;
              productionLog(`üö® [NOTIFICATIONS] Restored acknowledgment checkbox to: ${acknowledgmentCheckbox.checked}`);

              acknowledgmentCheckbox.addEventListener('change', (e) => {
                  UnifiedState.data.settings.notifications.requiresAcknowledgment = e.target.checked;
                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  productionLog(`üö® [NOTIFICATIONS] Require acknowledgment: ${e.target.checked}`);
              });
          }
  
          // Test notification button
          const testNotificationBtn = context.querySelector('#test-notification-btn');
          if (testNotificationBtn && !testNotificationBtn.hasAttribute('data-handler-setup')) {
              testNotificationBtn.setAttribute('data-handler-setup', 'true');
              testNotificationBtn.addEventListener('click', () => {
                  const notifications = UnifiedState.data.settings.notifications;
                  playSelectedNotification();
                  queueNotification('üîî Test notification - This is how alerts will look!', notifications.requiresAcknowledgment);
                  productionLog(`üîî [NOTIFICATIONS] Test notification played - Type: ${notifications.notificationType}, Volume: ${Math.round(notifications.volume * 100)}%, Acknowledgment: ${notifications.requiresAcknowledgment}`);
              });
          }
  
          // Seed watch checkboxes
          const seedWatchMap = {
              'watch-carrot': 'Carrot',
              'watch-strawberry': 'Strawberry',
              'watch-aloe': 'Aloe',
              'watch-blueberry': 'Blueberry',
              'watch-apple': 'Apple',
              'watch-tulip': 'Tulip',
              'watch-tomato': 'Tomato',
              'watch-daffodil': 'Daffodil',
              'watch-corn': 'Corn',
              'watch-watermelon': 'Watermelon',
              'watch-pumpkin': 'Pumpkin',
              'watch-echeveria': 'Echeveria',
              'watch-coconut': 'Coconut',
              'watch-banana': 'Banana',
              'watch-lily': 'Lily',
              'watch-burrostail': 'BurrosTail',
              'watch-mushroom': 'Mushroom',
              'watch-cactus': 'Cactus',
              'watch-bamboo': 'Bamboo',
              'watch-grape': 'Grape',
              'watch-pepper': 'Pepper',
              'watch-lemon': 'Lemon',
              'watch-passionfruit': 'PassionFruit',
              'watch-dragonfruit': 'DragonFruit',
              'watch-lychee': 'Lychee',
              'watch-sunflower': 'Sunflower',
              'watch-starweaver': 'Starweaver',
              'watch-dawnbinder': 'Dawnbinder',
              'watch-moonbinder': 'Moonbinder'
          };
  
          Object.entries(seedWatchMap).forEach(([checkboxId, seedId]) => {
              const checkbox = context.querySelector(`#${checkboxId}`);
              if (checkbox && !checkbox.hasAttribute('data-handler-setup')) {
                  checkbox.setAttribute('data-handler-setup', 'true');
                  checkbox.addEventListener('change', (e) => {
                      const notifications = UnifiedState.data.settings.notifications;
                      if (e.target.checked) {
                          if (!notifications.watchedSeeds.includes(seedId)) {
                              notifications.watchedSeeds.push(seedId);
                          }
                      } else {
                          notifications.watchedSeeds = notifications.watchedSeeds.filter(id => id !== seedId);
                      }
                      MGA_saveJSON('MGA_data', UnifiedState.data);
                      productionLog(`üå± [NOTIFICATIONS] ${e.target.checked ? 'Added' : 'Removed'} ${seedId} to/from watch list`);
                      updateLastSeenDisplay();
                  });
              }
          });
  
          // Egg watch checkboxes
          const eggWatchMap = {
              'watch-common-egg': 'CommonEgg',
              'watch-uncommon-egg': 'UncommonEgg',
              'watch-rare-egg': 'RareEgg',
              'watch-legendary-egg': 'LegendaryEgg',
              'watch-mythical-egg': 'MythicalEgg'
          };
  
          Object.entries(eggWatchMap).forEach(([checkboxId, eggId]) => {
              const checkbox = context.querySelector(`#${checkboxId}`);
              if (checkbox && !checkbox.hasAttribute('data-handler-setup')) {
                  checkbox.setAttribute('data-handler-setup', 'true');
                  checkbox.addEventListener('change', (e) => {
                      const notifications = UnifiedState.data.settings.notifications;
                      if (e.target.checked) {
                          if (!notifications.watchedEggs.includes(eggId)) {
                              notifications.watchedEggs.push(eggId);
                          }
                      } else {
                          notifications.watchedEggs = notifications.watchedEggs.filter(id => id !== eggId);
                      }
                      MGA_saveJSON('MGA_data', UnifiedState.data);
                      productionLog(`ü•ö [NOTIFICATIONS] ${e.target.checked ? 'Added' : 'Removed'} ${eggId} to/from watch list`);
                      updateLastSeenDisplay();
                  });
              }
          });
  
          // Decor watch checkboxes
          DECOR_ITEMS.forEach(decor => {
              const checkboxId = `watch-decor-${decor.id.toLowerCase()}`;
              const checkbox = context.querySelector(`#${checkboxId}`);
              if (checkbox && !checkbox.hasAttribute('data-handler-setup')) {
                  checkbox.setAttribute('data-handler-setup', 'true');
                  checkbox.addEventListener('change', (e) => {
                      const notifications = UnifiedState.data.settings.notifications;
                      if (e.target.checked) {
                          if (!notifications.watchedDecor.includes(decor.id)) {
                              notifications.watchedDecor.push(decor.id);
                          }
                      } else {
                          notifications.watchedDecor = notifications.watchedDecor.filter(id => id !== decor.id);
                      }
                      MGA_saveJSON('MGA_data', UnifiedState.data);
                      productionLog(`üé® [NOTIFICATIONS] ${e.target.checked ? 'Added' : 'Removed'} ${decor.id} to/from watch list`);
                      updateLastSeenDisplay();
                  });
              }
          });
  
          // Update last seen display function
          function updateLastSeenDisplay() {
              const lastSeenDisplay = context.querySelector('#last-seen-display');
              if (!lastSeenDisplay) return;
  
              const notifications = UnifiedState.data.settings.notifications;
              const allWatched = [...notifications.watchedSeeds, ...notifications.watchedEggs, ...notifications.watchedDecor];
  
              if (allWatched.length === 0) {
                  lastSeenDisplay.innerHTML = 'No items being watched';
                  return;
              }
  
              let html = '';
              allWatched.forEach(itemId => {
                  const timeSince = getTimeSinceLastSeen(itemId);
                  html += `<div>${itemId}: ${timeSince}</div>`;
              });
  
              lastSeenDisplay.innerHTML = html;
          }
  
          // Initial last seen update
          updateLastSeenDisplay();
  
          // Update last seen display every 30 seconds
          setInterval(updateLastSeenDisplay, 30000);
  
          // ==================== NEW NOTIFICATION HANDLERS ====================
  
          // Pet hunger enabled checkbox
          const petHungerCheckbox = context.querySelector('#pet-hunger-enabled');
          if (petHungerCheckbox && !petHungerCheckbox.hasAttribute('data-handler-setup')) {
              petHungerCheckbox.setAttribute('data-handler-setup', 'true');
              petHungerCheckbox.addEventListener('change', (e) => {
                  UnifiedState.data.settings.notifications.petHungerEnabled = e.target.checked;
                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  productionLog(`üêæ [PET-HUNGER] ${e.target.checked ? 'Enabled' : 'Disabled'} pet hunger notifications`);
  
                  // BUGFIX: Scan for currently hungry pets when enabling alerts
                  if (e.target.checked) {
                      // Delay slightly to ensure atoms are available
                      setTimeout(() => {
                          scanAndAlertHungryPets();
                      }, 500);
                  }
              });
          }
  
          // Pet hunger threshold slider
          const petHungerThreshold = context.querySelector('#pet-hunger-threshold');
          if (petHungerThreshold && !petHungerThreshold.hasAttribute('data-handler-setup')) {
              petHungerThreshold.setAttribute('data-handler-setup', 'true');
              petHungerThreshold.addEventListener('input', (e) => {
                  const threshold = parseInt(e.target.value);
                  UnifiedState.data.settings.notifications.petHungerThreshold = threshold;
                  // Update label
                  const label = petHungerThreshold.previousElementSibling;
                  label.textContent = `Alert when hunger below: ${threshold}%`;
                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  productionLog(`üêæ [PET-HUNGER] Threshold set to ${threshold}%`);
              });
          }
  
          // Ability notifications enabled checkbox
          const abilityNotificationsCheckbox = context.querySelector('#ability-notifications-enabled');
          if (abilityNotificationsCheckbox && !abilityNotificationsCheckbox.hasAttribute('data-handler-setup')) {
              abilityNotificationsCheckbox.setAttribute('data-handler-setup', 'true');
              abilityNotificationsCheckbox.addEventListener('change', (e) => {
                  UnifiedState.data.settings.notifications.abilityNotificationsEnabled = e.target.checked;
                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  productionLog(`‚ú® [ABILITY-NOTIFY] ${e.target.checked ? 'Enabled' : 'Disabled'} ability notifications`);
              });
          }
  
          // Ability notification sound type selector
          const abilityNotificationSoundSelect = context.querySelector('#ability-notification-sound-select');
          if (abilityNotificationSoundSelect && !abilityNotificationSoundSelect.hasAttribute('data-handler-setup')) {
              abilityNotificationSoundSelect.setAttribute('data-handler-setup', 'true');
              abilityNotificationSoundSelect.addEventListener('change', (e) => {
                  UnifiedState.data.settings.notifications.abilityNotificationSound = e.target.value;
                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  productionLog(`‚ú® [ABILITY-NOTIFY] Sound type changed to: ${e.target.value}`);
              });
          }
  
          // Ability notification volume slider
          const abilityVolumeSlider = context.querySelector('#ability-notification-volume-slider');
          if (abilityVolumeSlider && !abilityVolumeSlider.hasAttribute('data-handler-setup')) {
              abilityVolumeSlider.setAttribute('data-handler-setup', 'true');
              abilityVolumeSlider.addEventListener('input', (e) => {
                  const volume = parseInt(e.target.value) / 100;
                  UnifiedState.data.settings.notifications.abilityNotificationVolume = volume;
                  // Update label
                  const label = abilityVolumeSlider.previousElementSibling;
                  label.textContent = `Ability Alert Volume: ${Math.round(volume * 100)}%`;
                  MGA_saveJSON('MGA_data', UnifiedState.data);
              });
          }
  
          // Individual ability checkboxes
          const individualAbilityCheckboxes = context.querySelectorAll('.individual-ability-checkbox');
          individualAbilityCheckboxes.forEach(checkbox => {
              if (!checkbox.hasAttribute('data-handler-setup')) {
                  checkbox.setAttribute('data-handler-setup', 'true');
                  checkbox.addEventListener('change', (e) => {
                      const abilityName = e.target.dataset.abilityName;
                      if (!UnifiedState.data.settings.notifications.watchedAbilities) {
                          UnifiedState.data.settings.notifications.watchedAbilities = [];
                      }
  
                      if (e.target.checked) {
                          // Add to watched list
                          if (!UnifiedState.data.settings.notifications.watchedAbilities.includes(abilityName)) {
                              UnifiedState.data.settings.notifications.watchedAbilities.push(abilityName);
                          }
                      } else {
                          // Remove from watched list
                          const index = UnifiedState.data.settings.notifications.watchedAbilities.indexOf(abilityName);
                          if (index > -1) {
                              UnifiedState.data.settings.notifications.watchedAbilities.splice(index, 1);
                          }
                      }
  
                      MGA_saveJSON('MGA_data', UnifiedState.data);
                      productionLog(`‚ú® [ABILITY-NOTIFY] ${abilityName}: ${e.target.checked ? 'Enabled' : 'Disabled'}`);
                  });
              }
          });
  
          // Ability search box
          const abilitySearchBox = context.querySelector('#ability-search-box');
          if (abilitySearchBox && !abilitySearchBox.hasAttribute('data-handler-setup')) {
              abilitySearchBox.setAttribute('data-handler-setup', 'true');
              abilitySearchBox.addEventListener('input', (e) => {
                  const query = e.target.value.toLowerCase();
                  const items = context.querySelectorAll('.ability-checkbox-item');
                  items.forEach(item => {
                      const abilityName = item.dataset.ability.toLowerCase();
                      item.style.display = abilityName.includes(query) ? 'flex' : 'none';
                  });
              });
          }
  
          // Select All individual abilities button
          const selectAllIndividualAbilities = context.querySelector('#select-all-individual-abilities');
          if (selectAllIndividualAbilities && !selectAllIndividualAbilities.hasAttribute('data-handler-setup')) {
              selectAllIndividualAbilities.setAttribute('data-handler-setup', 'true');
              selectAllIndividualAbilities.addEventListener('click', () => {
                  // Empty array means all abilities enabled (backward compatibility)
                  UnifiedState.data.settings.notifications.watchedAbilities = [];
  
                  // Update all checkboxes
                  context.querySelectorAll('.individual-ability-checkbox').forEach(checkbox => {
                      checkbox.checked = true;
                  });
  
                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  productionLog('‚ú® [ABILITY-NOTIFY] Enabled all abilities');
              });
          }
  
          // Select None individual abilities button
          const selectNoneIndividualAbilities = context.querySelector('#select-none-individual-abilities');
          if (selectNoneIndividualAbilities && !selectNoneIndividualAbilities.hasAttribute('data-handler-setup')) {
              selectNoneIndividualAbilities.setAttribute('data-handler-setup', 'true');
              selectNoneIndividualAbilities.addEventListener('click', () => {
                  // Get all ability names
                  const allAbilities = [];
                  context.querySelectorAll('.individual-ability-checkbox').forEach(checkbox => {
                      allAbilities.push(checkbox.dataset.abilityName);
                  });
  
                  // Set watchedAbilities to opposite - if we want none, we list all then check against not-in-list
                  // Actually, better approach: use a special flag or empty means all, populated means only those
                  // For "none", we need a way to indicate "empty set of abilities"
                  // Let's use: populated array with abilities = only those; empty array = all; null = none
                  UnifiedState.data.settings.notifications.watchedAbilities = ['__NONE__']; // Special marker
  
                  // Update all checkboxes
                  context.querySelectorAll('.individual-ability-checkbox').forEach(checkbox => {
                      checkbox.checked = false;
                  });
  
                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  productionLog('‚ú® [ABILITY-NOTIFY] Disabled all abilities');
              });
          }
  
          // Weather notifications enabled checkbox
          const weatherNotificationsCheckbox = context.querySelector('#weather-notifications-enabled');
          if (weatherNotificationsCheckbox && !weatherNotificationsCheckbox.hasAttribute('data-handler-setup')) {
              weatherNotificationsCheckbox.setAttribute('data-handler-setup', 'true');
              weatherNotificationsCheckbox.addEventListener('change', (e) => {
                  UnifiedState.data.settings.notifications.weatherNotificationsEnabled = e.target.checked;
                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  productionLog(`üå§Ô∏è [WEATHER] ${e.target.checked ? 'Enabled' : 'Disabled'} weather notifications`);
              });
          }
  
          // Weather event checkboxes
          const weatherEventMap = {
              'watch-snow': 'Snow',
              'watch-rain': 'Rain',
              'watch-amber-moon': 'AmberMoon',
              'watch-dawn': 'Dawn'
          };
  
          Object.entries(weatherEventMap).forEach(([checkboxId, eventName]) => {
              const checkbox = context.querySelector(`#${checkboxId}`);
              if (checkbox && !checkbox.hasAttribute('data-handler-setup')) {
                  checkbox.setAttribute('data-handler-setup', 'true');
                  checkbox.addEventListener('change', (e) => {
                      const watchedEvents = UnifiedState.data.settings.notifications.watchedWeatherEvents;
                      if (e.target.checked) {
                          if (!watchedEvents.includes(eventName)) {
                              watchedEvents.push(eventName);
                          }
                      } else {
                          const idx = watchedEvents.indexOf(eventName);
                          if (idx > -1) watchedEvents.splice(idx, 1);
                      }
                      MGA_saveJSON('MGA_data', UnifiedState.data);
                      productionLog(`üå§Ô∏è [WEATHER] ${e.target.checked ? 'Added' : 'Removed'} ${eventName} to/from watch list`);
                  });
              }
          });

          // ========== CUSTOM NOTIFICATION SOUNDS ==========
          const customSoundsContainer = context.querySelector('#custom-sounds-container');
          if (customSoundsContainer && !customSoundsContainer.hasAttribute('data-handler-setup')) {
              customSoundsContainer.setAttribute('data-handler-setup', 'true');

              const soundTypes = [
                  { id: 'shop', label: 'üõí Shop Alerts' },
                  { id: 'pet', label: 'üêæ Pet Hunger' },
                  { id: 'ability', label: '‚ö° Ability Triggers' },
                  { id: 'weather', label: 'üå§Ô∏è Weather Events' }
              ];

              soundTypes.forEach(type => {
                  const hasCustom = GM_getValue(`mgtools_custom_sound_${type.id}`, null) !== null;

                  const controlDiv = document.createElement('div');
                  controlDiv.style.cssText = 'border: 1px solid rgba(255, 255, 255, 0.57); padding: 10px; border-radius: 6px; background: rgba(0, 0, 0, 0.48);';
                  controlDiv.innerHTML = `
                      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px;">
                          <label class="mga-label" style="margin: 0;">${type.label}</label>
                          <span id="custom-sound-status-${type.id}" style="font-size: 10px; color: ${hasCustom ? '#10b981' : '#666'};">
                              ${hasCustom ? '‚úì Custom' : '‚óã Default'}
                          </span>
                      </div>
                      <div style="display: flex; gap: 6px;">
                          <input type="file" accept="audio/*" id="upload-sound-${type.id}" style="display: none;">
                          <button class="mga-btn mga-btn-sm" id="upload-btn-${type.id}" style="flex: 1; background: #4a9eff; font-size: 11px; padding: 6px;">üìÅ Upload</button>
                          <button class="mga-btn mga-btn-sm" id="test-btn-${type.id}" style="flex: 0.6; background: #10b981; font-size: 11px; padding: 6px;">‚ñ∂Ô∏è Test</button>
                          <button class="mga-btn mga-btn-sm" id="delete-btn-${type.id}" style="flex: 0.6; background: ${hasCustom ? '#ef4444' : '#666'}; font-size: 11px; padding: 6px;" ${!hasCustom ? 'disabled' : ''}>üóëÔ∏è</button>
                      </div>
                  `;
                  customSoundsContainer.appendChild(controlDiv);

                  const uploadBtn = controlDiv.querySelector(`#upload-btn-${type.id}`);
                  const fileInput = controlDiv.querySelector(`#upload-sound-${type.id}`);
                  uploadBtn.addEventListener('click', () => fileInput.click());

                  fileInput.addEventListener('change', (e) => {
                      const file = e.target.files[0];
                      if (!file) return;
                      if (file.size > 2 * 1024 * 1024) { alert('‚ùå File too large! Max 2MB'); return; }
                      if (!file.type.startsWith('audio/')) { alert('‚ùå Please upload an audio file'); return; }

                      const reader = new FileReader();
                      reader.onload = (event) => {
                          GM_setValue(`mgtools_custom_sound_${type.id}`, event.target.result);
                          controlDiv.querySelector(`#custom-sound-status-${type.id}`).textContent = '‚úì Custom';
                          controlDiv.querySelector(`#custom-sound-status-${type.id}`).style.color = '#10b981';
                          const delBtn = controlDiv.querySelector(`#delete-btn-${type.id}`);
                          delBtn.disabled = false;
                          delBtn.style.background = '#ef4444';
                          productionLog(`üéµ [CUSTOM-SOUND] Uploaded: ${type.id}`);
                          alert(`‚úÖ Custom sound uploaded!`);
                      };
                      reader.readAsDataURL(file);
                  });

                  controlDiv.querySelector(`#test-btn-${type.id}`).addEventListener('click', () => {
                      const customSound = GM_getValue(`mgtools_custom_sound_${type.id}`, null);
                      const volume = UnifiedState.data.settings.notifications.volume || 0.3;
                      if (customSound) {
                          const audio = new Audio(customSound);
                          audio.volume = volume;
                          audio.play();
                      } else {
                          playSelectedNotification();
                      }
                  });

                  controlDiv.querySelector(`#delete-btn-${type.id}`).addEventListener('click', () => {
                      if (confirm(`Delete custom sound for ${type.label}?`)) {
                          GM_deleteValue(`mgtools_custom_sound_${type.id}`);
                          controlDiv.querySelector(`#custom-sound-status-${type.id}`).textContent = '‚óã Default';
                          controlDiv.querySelector(`#custom-sound-status-${type.id}`).style.color = '#666';
                          const delBtn = controlDiv.querySelector(`#delete-btn-${type.id}`);
                          delBtn.disabled = true;
                          delBtn.style.background = '#666';
                          alert(`‚úÖ Reverted to default sound`);
                      }
                  });
              });
          }
      }

      function setupSettingsTabHandlers(context = document) {
          console.log('üö® [CRITICAL-DEBUG] setupSettingsTabHandlers ENTERED');
          productionLog('‚öôÔ∏è [SETTINGS] setupSettingsTabHandlers called', { context: context === document ? 'document' : 'custom' });
          console.log('üö® [CRITICAL-DEBUG] Context type:', context === document ? 'DOCUMENT' : 'ELEMENT', context);
  
          // Compatibility Mode toggle button
          const compatToggleBtn = context.querySelector('#compat-toggle-btn');
          if (compatToggleBtn && typeof CompatibilityMode !== 'undefined') {
              compatToggleBtn.addEventListener('click', () => {
                  if (CompatibilityMode.flags.enabled) {
                      // Disable compatibility mode
                      CompatibilityMode.disableCompat();
                      logInfo('COMPAT', 'User disabled compatibility mode - reload required');
                      alert('Compatibility Mode disabled. Please refresh the page for changes to take effect.');
                  } else {
                      // Enable compatibility mode
                      try {
                          localStorage.setItem('mgtools_compat_forced', 'true');
                          localStorage.removeItem('mgtools_compat_disabled');
                          logInfo('COMPAT', 'User enabled compatibility mode - reload required');
                          alert('Compatibility Mode enabled. Please refresh the page for changes to take effect.');
                      } catch (e) {
                          alert('Unable to save compatibility mode setting. Your browser may have storage restrictions.');
                      }
                  }

                  // Offer to reload
                  if (confirm('Would you like to reload the page now?')) {
                      window.location.reload();
                  }
              });
          }

          // Opacity slider
          const opacitySlider = context.querySelector('#opacity-slider');
          if (opacitySlider) {
              opacitySlider.addEventListener('input', (e) => {
                  const opacity = parseInt(e.target.value);
                  UnifiedState.data.settings.opacity = opacity;
                  applyTheme();
                  // Update label
                  const label = opacitySlider.previousElementSibling;
                  label.textContent = `Main HUD Opacity: ${opacity}%`;
                  MGA_saveJSON('MGA_data', UnifiedState.data);
              });
          }
  
          // Pop-out opacity slider
          const popoutOpacitySlider = context.querySelector('#popout-opacity-slider');
          if (popoutOpacitySlider) {
              popoutOpacitySlider.addEventListener('input', (e) => {
                  const popoutOpacity = parseInt(e.target.value);
                  UnifiedState.data.settings.popoutOpacity = popoutOpacity;
                  syncThemeToAllWindows(); // Apply theme to pop-out windows only
                  // Update label
                  const label = popoutOpacitySlider.previousElementSibling;
                  label.textContent = `Pop-out Opacity: ${popoutOpacity}%`;
                  MGA_saveJSON('MGA_data', UnifiedState.data);
              });
          }
  
          // Gradient select
          const gradientSelect = context.querySelector('#gradient-select');
          if (gradientSelect) {
              gradientSelect.addEventListener('change', (e) => {
                  UnifiedState.data.settings.gradientStyle = e.target.value;
                  applyTheme();
                  MGA_saveJSON('MGA_data', UnifiedState.data);
              });
          }
  
          // Effect select
          const effectSelect = context.querySelector('#effect-select');
          if (effectSelect) {
              effectSelect.addEventListener('change', (e) => {
                  UnifiedState.data.settings.effectStyle = e.target.value;
                  applyTheme();
                  MGA_saveJSON('MGA_data', UnifiedState.data);
              });
          }

          // Theme preset buttons
          const themePresetButtons = context.querySelectorAll('[data-preset]');
          themePresetButtons.forEach(btn => {
              if (!btn.hasAttribute('data-handler-setup')) {
                  btn.setAttribute('data-handler-setup', 'true');
                  btn.addEventListener('click', (e) => {
                      const presetName = e.target.dataset.preset;

                      // Apply the preset
                      applyPreset(presetName);

                      // Apply theme immediately
                      applyTheme();

                      // Save the settings
                      MGA_saveJSON('MGA_data', UnifiedState.data);

                      // Update UI elements to reflect new values
                      // Update opacity slider
                      const opacitySlider = context.querySelector('#opacity-slider');
                      if (opacitySlider) {
                          opacitySlider.value = UnifiedState.data.settings.opacity;
                          const label = opacitySlider.previousElementSibling;
                          if (label) {
                              label.textContent = `Main HUD Opacity: ${UnifiedState.data.settings.opacity}%`;
                          }
                      }

                      // Update gradient select
                      const gradientSelect = context.querySelector('#gradient-select');
                      if (gradientSelect) {
                          gradientSelect.value = UnifiedState.data.settings.gradientStyle;
                      }

                      // Update effect select
                      const effectSelect = context.querySelector('#effect-select');
                      if (effectSelect) {
                          effectSelect.value = UnifiedState.data.settings.effectStyle;
                      }

                      productionLog(`üé® Applied theme preset: ${presetName}`);
                  });
              }
          });

          // Texture select
          const textureSelect = context.querySelector('#texture-select');
          if (textureSelect) {
              textureSelect.addEventListener('change', (e) => {
                  UnifiedState.data.settings.textureStyle = e.target.value;
                  applyTheme();
                  MGA_saveJSON('MGA_data', UnifiedState.data);
              });
          }

          // Texture intensity slider
          const intensitySlider = context.querySelector('#texture-intensity-slider');
          const intensityValue = context.querySelector('#texture-intensity-value');
          if (intensitySlider && intensityValue) {
              intensitySlider.addEventListener('input', (e) => {
                  const value = e.target.value;
                  intensityValue.textContent = value + '%';
                  UnifiedState.data.settings.textureIntensity = parseInt(value);
                  applyTheme();
              });
              intensitySlider.addEventListener('change', (e) => {
                  MGA_saveJSON('MGA_data', UnifiedState.data);
              });
          }

          // Texture scale buttons
          const scaleButtons = context.querySelectorAll('.texture-scale-btn');
          if (scaleButtons.length > 0) {
              scaleButtons.forEach(btn => {
                  btn.addEventListener('click', (e) => {
                      const scale = e.target.dataset.scale;
                      UnifiedState.data.settings.textureScale = scale;

                      // Update button styles
                      scaleButtons.forEach(b => {
                          b.style.background = '';
                          b.style.color = '';
                      });
                      e.target.style.background = '#4a9eff';
                      e.target.style.color = 'white';

                      applyTheme();
                      MGA_saveJSON('MGA_data', UnifiedState.data);
                  });
              });
          }

          // Texture blend mode selector
          const blendModeSelect = context.querySelector('#texture-blend-mode');
          if (blendModeSelect) {
              blendModeSelect.addEventListener('change', (e) => {
                  UnifiedState.data.settings.textureBlendMode = e.target.value;
                  applyTheme();
                  MGA_saveJSON('MGA_data', UnifiedState.data);
              });
          }

          // Texture animation toggle
          const animatedCheckbox = context.querySelector('#texture-animated-checkbox');
          if (animatedCheckbox) {
              animatedCheckbox.addEventListener('change', (e) => {
                  UnifiedState.data.settings.textureAnimated = e.target.checked;
                  applyTheme();
                  MGA_saveJSON('MGA_data', UnifiedState.data);
              });
          }

          // Ultra-compact mode checkbox
          const ultraCompactCheckbox = context.querySelector('#ultra-compact-checkbox');
          if (ultraCompactCheckbox) {
              // Remove any existing listeners by cloning
              const newCheckbox = ultraCompactCheckbox.cloneNode(true);
              ultraCompactCheckbox.parentNode.replaceChild(newCheckbox, ultraCompactCheckbox);
  
              newCheckbox.addEventListener('change', (e) => {
                  e.stopPropagation();
                  UnifiedState.data.settings.ultraCompactMode = e.target.checked;
                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  applyUltraCompactMode(e.target.checked);
                  productionLog(`üì± Ultra-compact mode ${e.target.checked ? 'enabled' : 'disabled'}`);
              });
          }
  
          // Overlay mode checkbox
          const overlayCheckbox = context.querySelector('#use-overlays-checkbox');
          if (overlayCheckbox) {
              overlayCheckbox.addEventListener('change', (e) => {
                  UnifiedState.data.settings.useInGameOverlays = e.target.checked;
                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  productionLog(`üéÆ Overlay mode ${e.target.checked ? 'enabled' : 'disabled'}`);
              });
          }
  
          // Debug mode checkbox
          const debugModeCheckbox = context.querySelector('#debug-mode-checkbox');
          if (debugModeCheckbox) {
              debugModeCheckbox.addEventListener('change', (e) => {
                  UnifiedState.data.settings.debugMode = e.target.checked;
                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  productionLog(`üêõ Debug mode ${e.target.checked ? 'enabled' : 'disabled'}`);
              });
          }
  
          // Preset buttons
          context.querySelectorAll('[data-preset]').forEach(btn => {
              btn.addEventListener('click', (e) => {
                  const preset = e.target.dataset.preset;
                  applyPreset(preset);
              });
          });
  
          // Export/Import
          const exportBtn = context.querySelector('#export-settings-btn');
          if (exportBtn) {
              exportBtn.addEventListener('click', () => {
                  const data = JSON.stringify(UnifiedState.data, null, 2);
                  const blob = new Blob([data], { type: 'application/json' });
                  const link = targetDocument.createElement('a');
                  link.href = URL.createObjectURL(blob);
                  link.download = 'MGA_Settings.json';
                  link.click();
              });
          }
  
          // Import settings handler
          const importBtn = context.querySelector('#import-settings-btn');
          if (importBtn) {
              importBtn.addEventListener('click', () => {
                  const fileInput = targetDocument.createElement('input');
                  fileInput.type = 'file';
                  fileInput.accept = '.json';
                  fileInput.addEventListener('change', (e) => {
                      const file = e.target.files[0];
                      if (!file) return;
  
                      const reader = new FileReader();
                      reader.onload = (event) => {
                          try {
                              const importedData = JSON.parse(event.target.result);
  
                              // Validate it's a data object
                              if (typeof importedData !== 'object' || importedData === null) {
                                  throw new Error('Invalid data format');
                              }
  
                              // Merge imported data with current data (preserve any new data not in import)
                              UnifiedState.data = { ...UnifiedState.data, ...importedData };
  
                              // Save to storage
                              MGA_saveJSON('MGA_data', UnifiedState.data);
  
                              // Apply theme immediately
                              applyTheme();
  
                              // Apply other settings
                              if (UnifiedState.data.settings.ultraCompactMode) {
                                  applyUltraCompactMode(true);
                              }
  
                              productionLog('‚úÖ Settings imported successfully!');
                              showNotificationToast('‚úÖ Settings imported and applied!', 'success');
  
                              // Refresh UI to show updated settings
                              if (UnifiedState.activeTab === 'settings') {
                                  updateTabContent();
                              }
                          } catch (error) {
                              console.error('Failed to import settings:', error);
                              showNotificationToast('‚ùå Failed to import settings. Invalid file format.', 'error');
                          }
                      };
                      reader.readAsText(file);
                  });
                  fileInput.click();
              });
          }
  
          // Reset pet loadouts handler
          const resetLoadoutsBtn = context.querySelector('#reset-loadouts-btn');
          if (resetLoadoutsBtn) {
              resetLoadoutsBtn.addEventListener('click', () => {
                  if (confirm('‚ö†Ô∏è Are you sure you want to reset all pet loadouts? This cannot be undone.')) {
                      UnifiedState.data.petPresets = {};
                      MGA_saveJSON('MGA_data', UnifiedState.data);
                      productionLog('üîÑ Pet loadouts have been reset');
                      // Update the UI if we're in the pets tab
                      if (UnifiedState.activeTab === 'pets') {
                          updateTabContent();
                      }
                      productionLog('‚úÖ Pet loadouts have been reset successfully!');
                  }
              });
          }
  
          // Weather effects checkbox
          const weatherCheckbox = context.querySelector('#hide-weather-checkbox');
          if (weatherCheckbox && !weatherCheckbox.hasAttribute('data-handler-setup')) {
              weatherCheckbox.setAttribute('data-handler-setup', 'true');
              try {
                  weatherCheckbox.checked = !!(UnifiedState && UnifiedState.data && UnifiedState.data.settings && UnifiedState.data.settings.hideWeather);
              } catch (_) {}
              const cloned = weatherCheckbox.cloneNode(true);
              weatherCheckbox.parentNode.replaceChild(cloned, weatherCheckbox);
              cloned.addEventListener('change', (e) => {
                  if (!UnifiedState || !UnifiedState.data || !UnifiedState.data.settings) return;
                  UnifiedState.data.settings.hideWeather = !!e.target.checked;
                  try { MGA_saveJSON('MGA_data', UnifiedState.data); } catch (err) { console.error('Weather save failed:', err); }
                  try { applyWeatherSetting(); } catch (err) { console.error('applyWeatherSetting failed:', err); }
                  productionLog(`üåßÔ∏è [WEATHER] Toggle set to ${e.target.checked ? 'HIDE' : 'SHOW'}`);
              });
          }
  
  }
  
      function setupToolsTabHandlers(context = document) {
          // Calculator mapping
          const calculatorUrls = {
              'sell-price': 'https://daserix.github.io/magic-garden-calculator/#/sell-price-calculator',
              'weight-probability': 'https://daserix.github.io/magic-garden-calculator/#/weight-probability-calculator',
              'pet-appearance-probability': 'https://daserix.github.io/magic-garden-calculator/#/pet-appearance-probability-calculator',
              'ability-trigger-time': 'https://daserix.github.io/magic-garden-calculator/#/ability-trigger-time-calculator',
              'import-garden': 'https://daserix.github.io/magic-garden-calculator/#/garden'
          };
  
          // Wiki mapping
          const wikiUrls = {
              'crops': 'https://magicgarden.fandom.com/wiki/Crops',
              'pets': 'https://magicgarden.fandom.com/wiki/Pets',
              'abilities': 'https://magicgarden.fandom.com/wiki/Abilities',
              'weather': 'https://magicgarden.fandom.com/wiki/Weather_Events',
              'multipliers': 'https://magicgarden.fandom.com/wiki/Multipliers',
              'shops': 'https://magicgarden.fandom.com/wiki/Shops'
          };
  
          // Add click handlers to all calculator cards
          const toolCards = context.querySelectorAll('.mga-tool-card');
          toolCards.forEach(card => {
              card.addEventListener('click', () => {
                  const calculatorType = card.dataset.calculator;
                  const url = calculatorUrls[calculatorType];
                  if (url) {
                      openCalculatorPopup(url, calculatorType);
                  } else {
                      productionWarn(`Calculator URL not found for: ${calculatorType}`);
                  }
              });
  
              // Add hover effect class if not already present
              if (!card.classList.contains('mga-tool-interactive')) {
                  card.classList.add('mga-tool-interactive');
              }
          });
  
          // Add click handlers to all wiki cards
          const wikiCards = context.querySelectorAll('.mga-wiki-card');
          wikiCards.forEach(card => {
              card.addEventListener('click', () => {
                  const wikiType = card.dataset.wiki;
                  const url = wikiUrls[wikiType];
                  if (url) {
                      openWikiPopup(url, wikiType);
                  } else {
                      productionWarn(`Wiki URL not found for: ${wikiType}`);
                  }
              });
  
              // Add hover effect class if not already present
              if (!card.classList.contains('mga-wiki-interactive')) {
                  card.classList.add('mga-wiki-interactive');
              }
          });
  
          // Hide Weather checkbox
          const hideWeatherCheckbox = context.querySelector('#hide-weather-checkbox');
          productionLog('üåßÔ∏è [WEATHER-DEBUG] Setting up weather checkbox handler', {
              found: !!hideWeatherCheckbox,
              hasHandler: hideWeatherCheckbox?.hasAttribute('data-handler-setup')
          });
  
          if (hideWeatherCheckbox && !hideWeatherCheckbox.hasAttribute('data-handler-setup')) {
              hideWeatherCheckbox.setAttribute('data-handler-setup', 'true');
              hideWeatherCheckbox.addEventListener('change', (e) => {
                  productionLog(`üåßÔ∏è [WEATHER] Checkbox changed to: ${e.target.checked}`);
                  UnifiedState.data.settings.hideWeather = e.target.checked;
                  MGA_saveJSON('MGA_data', UnifiedState.data);
                  applyWeatherSetting();
                  productionLog(`üåßÔ∏è [WEATHER] Weather effects ${e.target.checked ? 'hidden' : 'shown'}`);
              });
              productionLog('üåßÔ∏è [WEATHER-DEBUG] Event listener attached successfully');
          } else if (hideWeatherCheckbox) {
              productionLog('üåßÔ∏è [WEATHER-DEBUG] Checkbox already has handler, skipping');
          } else {
              productionLog('üåßÔ∏è [WEATHER-DEBUG] Checkbox element not found!');
          }
  
          // Crop highlighting handlers
          const applyHighlightingBtn = context.querySelector('#apply-highlighting-btn');
          if (applyHighlightingBtn) {
              applyHighlightingBtn.addEventListener('click', () => {
                  applyCropHighlighting();
              });
          }
  
          const clearHighlightingBtn = context.querySelector('#clear-highlighting-btn');
          if (clearHighlightingBtn) {
              clearHighlightingBtn.addEventListener('click', () => {
                  clearCropHighlighting();
              });
          }
  
          if (UnifiedState.data.settings.debugMode) {
              productionLog(`üßÆ Set up handlers for ${toolCards.length} calculator tools and ${wikiCards.length} wiki resources`);
          }
      }
  
      function openCalculatorPopup(url, calculatorType) {
          // Calculate window dimensions and position
          const width = 1200;
          const height = 800;
          const left = (window.screen.width - width) / 2;
          const top = (window.screen.height - height) / 2;
  
          // Window features
          const features = `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=yes,status=yes`;
  
          // Open the popup window
          const popupWindow = window.open(url, `mga_calculator_${calculatorType}`, features);
  
          // Check if popup was blocked
          if (!popupWindow || popupWindow.closed || typeof popupWindow.closed === 'undefined') {
              // Popup was blocked, show alternative message
              const message = `
                  <div style="padding: 20px; background: rgba(255, 50, 50, 0.30); border: 1px solid rgba(255,100,100,0.3); border-radius: 5px; margin: 20px;">
                      <h3 style="color: #ff6b6b; margin-bottom: 10px;">‚ö†Ô∏è Popup Blocked</h3>
                      <p style="margin-bottom: 15px;">The calculator popup was blocked by your browser. Please allow popups for this site or open the calculator manually:</p>
                      <div style="background: rgba(0, 0, 0, 0.48); padding: 10px; border-radius: 3px; word-break: break-all;">
                          <a href="${url}" target="_blank" style="color: #4fc3f7;">${url}</a>
                      </div>
                      <p style="margin-top: 10px; font-size: 0.9em; color: rgba(255,255,255,0.6);">
                          Click the link above to open the calculator in a new tab.
                      </p>
                  </div>
              `;
  
              // Show message in the Tools tab content area
              const contentEl = document.getElementById('mga-tab-content');
              if (contentEl && UnifiedState.activeTab === 'tools') {
                  const existingContent = contentEl.innerHTML;
                  contentEl.innerHTML = message + existingContent;
  
                  // Remove the message after 10 seconds
                  setTimeout(() => {
                      if (contentEl.innerHTML.includes(message)) {
                          contentEl.innerHTML = existingContent;
                      }
                  }, 10000);
              }
  
              productionWarn(`Popup blocked for calculator: ${calculatorType}. URL: ${url}`);
          } else {
              // Popup opened successfully
              popupWindow.focus();
              productionLog(`‚úÖ Opened calculator popup: ${calculatorType}`);
          }
      }
  
      function openWikiPopup(url, wikiType) {
          // Calculate window dimensions and position
          const width = 1000;
          const height = 900;
          const left = (window.screen.width - width) / 2;
          const top = (window.screen.height - height) / 2;
  
          // Window features
          const features = `width=${width},height=${height},left=${left},top=${top},resizable=yes,scrollbars=yes,status=yes`;
  
          // Open the popup window
          const popupWindow = window.open(url, `mga_wiki_${wikiType}`, features);
  
          // Check if popup was blocked
          if (!popupWindow || popupWindow.closed || typeof popupWindow.closed === 'undefined') {
              // Popup was blocked, show alternative message
              const message = `
                  <div style="padding: 20px; background: rgba(255, 50, 50, 0.30); border: 1px solid rgba(255,100,100,0.3); border-radius: 5px; margin: 20px;">
                      <h3 style="color: #ff6b6b; margin-bottom: 10px;">‚ö†Ô∏è Popup Blocked</h3>
                      <p style="margin-bottom: 15px;">The wiki popup was blocked by your browser. Please allow popups for this site or open the wiki manually:</p>
                      <div style="background: rgba(0, 0, 0, 0.48); padding: 10px; border-radius: 3px; word-break: break-all;">
                          <a href="${url}" target="_blank" style="color: #4fc3f7;">${url}</a>
                      </div>
                      <p style="margin-top: 10px; font-size: 0.9em; color: rgba(255,255,255,0.6);">
                          Click the link above to open the wiki page in a new tab.
                      </p>
                  </div>
              `;
  
              // Show message in the Tools tab content area
              const contentEl = document.getElementById('mga-tab-content');
              if (contentEl && UnifiedState.activeTab === 'tools') {
                  const existingContent = contentEl.innerHTML;
                  contentEl.innerHTML = message + existingContent;
  
                  // Remove the message after 10 seconds
                  setTimeout(() => {
                      if (contentEl.innerHTML.includes(message)) {
                          contentEl.innerHTML = existingContent;
                      }
                  }, 10000);
              }
  
              productionWarn(`Popup blocked for wiki: ${wikiType}. URL: ${url}`);
          } else {
              // Popup opened successfully
              popupWindow.focus();
              productionLog(`‚úÖ Opened wiki popup: ${wikiType}`);
          }
      }
  
      // ==================== CROP HIGHLIGHTING UTILITIES ====================
      // Initialize tile override storage
      window.__tileOverrides = window.__tileOverrides || {};
      window.__slotTargetOverrides = window.__slotTargetOverrides || {};
  
      // Tile-modifying hookAtom function (different from monitoring hookAtom)
      function hookAtomForTileOverrides(atomPath, windowKey) {
          const atom = targetWindow.jotaiAtomCache?.get(atomPath);
          if (!atom?.read) {
              productionWarn(`üîç Could not find atom at path: ${atomPath}`);
              return;
          }
  
          if (!atom.__originalRead) {
              atom.__originalRead = atom.read;
              productionLog(`üîó Hooked atom for tile overrides: ${atomPath}`);
  
              atom.read = (t) => {
                  const value = atom.__originalRead(t);
  
                  try {
                      const tileObjects = value?.garden?.tileObjects;
  
                      if (tileObjects != null) {
                          let overridesApplied = 0;
                          const applyOverrideToTile = (tileIndex, tileObj) => {
                              if (!tileObj || typeof tileObj !== 'object') return;
  
                              let wasModified = false;
  
                              // Species override
                              if (window.__tileOverrides[tileIndex] !== undefined) {
                                  const oldSpecies = tileObj.species;
                                  tileObj.species = window.__tileOverrides[tileIndex];
                                  wasModified = true;
                                  if (UnifiedState.data.settings.debugMode) {
                                      productionLog(`üîÑ Tile ${tileIndex}: ${oldSpecies} ‚Üí ${tileObj.species}`);
                                  }
                              }
  
                              // Slot targetScale override
                              if (window.__slotTargetOverrides[tileIndex] !== undefined) {
                                  const slots = tileObj.slots;
                                  const slotOverrides = window.__slotTargetOverrides[tileIndex];
                                  if (slots) {
                                      for (const [slotIdx, scale] of Object.entries(slotOverrides)) {
                                          if (slots[slotIdx] && typeof slots[slotIdx] === 'object') {
                                              const oldScale = slots[slotIdx].targetScale;
                                              slots[slotIdx].targetScale = scale;
                                              wasModified = true;
                                              if (UnifiedState.data.settings.debugMode) {
                                                  productionLog(`üîÑ Tile ${tileIndex} slot ${slotIdx}: scale ${oldScale} ‚Üí ${scale}`);
                                              }
                                          }
                                      }
                                  }
                              }
  
                              if (wasModified) overridesApplied++;
                          };
  
                          // Apply overrides to all tiles
                          if (Array.isArray(tileObjects)) {
                              tileObjects.forEach((tile, idx) => applyOverrideToTile(idx, tile));
                          } else if (tileObjects instanceof Map) {
                              tileObjects.forEach((tile, key) => applyOverrideToTile(key, tile));
                          } else if (typeof tileObjects === 'object') {
                              Object.keys(tileObjects).forEach(key => {
                                  const idx = isFinite(key) ? Number(key) : key;
                                  applyOverrideToTile(idx, tileObjects[key]);
                              });
                          }
  
                          if (overridesApplied > 0) {
                              productionLog(`üå± Applied ${overridesApplied} tile overrides in atom read`);
                          }
                      }
                  } catch (err) {
                      console.error('hookAtomForTileOverrides: error applying tile overrides', err);
                  }
  
                  // Expose full value for console inspection
                  try { window[windowKey] = value; } catch (e) {}
  
                  return value;
              };
          } else {
              productionLog(`‚ö†Ô∏è Atom already hooked: ${atomPath}`);
          }
      }
  
      // Tile override utility functions (MGA namespaced to prevent conflicts)
      window.MGA_Internal.setTileSpecies = function(index, species) {
          if (species == null) {
              delete window.__tileOverrides[index];
          } else {
              window.__tileOverrides[index] = species;
          }
      };
  
      window.MGA_Internal.setTileSlotTargetScale = function(tileIndex, slotIndex, targetScale) {
          if (!window.__slotTargetOverrides[tileIndex]) {
              window.__slotTargetOverrides[tileIndex] = {};
          }
          if (targetScale == null) {
              delete window.__slotTargetOverrides[tileIndex][slotIndex];
          } else {
              window.__slotTargetOverrides[tileIndex][slotIndex] = targetScale;
          }
      };
  
      window.MGA_Internal.removeTileOverrides = function(tileIndex) {
          delete window.__tileOverrides[tileIndex];
          delete window.__slotTargetOverrides[tileIndex];
      };
  
      window.MGA_Internal.removeAllTileOverrides = function() {
          window.__tileOverrides = {};
          window.__slotTargetOverrides = {};
      };
  
      // Advanced tile filtering functions
      window.applyToAllTilesExcept = function(skipSpecies = "Starweaver", slotIndex = 0, targetScale = 0.1, newSpecies = null) {
          const tileObjects = window.gardenInfo?.garden?.tileObjects;
          if (!tileObjects) return;
  
          const entries = Array.isArray(tileObjects) ? tileObjects.map((t,i)=>({tile:t,index:i})) :
                          tileObjects instanceof Map ? Array.from(tileObjects.entries()).map(([k,v])=>({tile:v,index:k})) :
                          Object.keys(tileObjects).map(k => ({tile: tileObjects[k], index: isFinite(k)?Number(k):k}));
  
          entries.forEach(({tile,index})=>{
              if (!tile || tile.species === skipSpecies) return;
              if (newSpecies != null) window.setTileSpecies(index, newSpecies);
              if (targetScale != null) window.setTileSlotTargetScale(index, slotIndex, targetScale);
          });
      };
  
      window.applyToAllTilesFiltered = function({
          skipSpecies = "Starweaver",
          slotIndex = 0,
          targetScale = 0.1,
          newSpecies = null,
          mutationFilter = null // function(slotMutations) => true/false
      } = {}) {
          const tileObjects = window.gardenInfo?.garden?.tileObjects;
          if (!tileObjects) return;
  
          const entries = Array.isArray(tileObjects) ? tileObjects.map((t,i)=>({tile:t,index:i})) :
                          tileObjects instanceof Map ? Array.from(tileObjects.entries()).map(([k,v])=>({tile:v,index:k})) :
                          Object.keys(tileObjects).map(k => ({tile: tileObjects[k], index: isFinite(k)?Number(k):k}));
  
          entries.forEach(({tile,index}) => {
              if (!tile || tile.species === skipSpecies) return;
  
              const slot = tile.slots?.[slotIndex];
              if (!slot) return;
  
              // Skip if mutationFilter is defined and returns false
              if (mutationFilter && !mutationFilter(slot.mutations)) return;
  
              if (newSpecies != null) window.setTileSpecies(index, newSpecies);
              if (targetScale != null) window.setTileSlotTargetScale(index, slotIndex, targetScale);
          });
      };
  
      // Main crop highlighting function
      window.highlightTilesByMutation = function({
          highlightSpecies = null,      // string or array of species
          highlightMutations = [],      // array of mutations to match
          slotIndex = 0,
          highlightScale = null,        // null = keep original
          hiddenSpecies = "Carrot",
          hiddenScale = 0.1
      } = {}) {
          const tileObjects = window.gardenInfo?.garden?.tileObjects;
          if (!tileObjects) return;
  
          const entries = Array.isArray(tileObjects)
              ? tileObjects.map((t,i)=>({tile:t,index:i}))
              : tileObjects instanceof Map
                  ? Array.from(tileObjects.entries()).map(([k,v])=>({tile:v,index:k}))
                  : Object.keys(tileObjects).map(k => ({tile: tileObjects[k], index: isFinite(k)?Number(k):k}));
  
          // Normalize species array
          const speciesArr = Array.isArray(highlightSpecies) ? highlightSpecies : (highlightSpecies ? [highlightSpecies] : []);
  
          entries.forEach(({tile,index}) => {
              if (!tile) return;
  
              const slot = tile.slots?.[slotIndex];
              if (!slot) return;
  
              const mutations = slot.mutations || [];
  
              // Highlight if species is in the array
              const matchesSpecies = speciesArr.length === 0 || speciesArr.includes(tile.species);
              const matchesMutations = !highlightMutations || highlightMutations.length === 0 || highlightMutations.includes(null) || highlightMutations.some(m => mutations.includes(m)) || highlightMutations.every(m => mutations.includes(m));
  
              if (matchesSpecies && matchesMutations) {
                  if (highlightScale != null) window.setTileSlotTargetScale(index, slotIndex, highlightScale);
                  if (highlightSpecies) window.setTileSpecies(index, tile.species); // keep species unchanged
              } else {
                  if (hiddenScale != null) window.setTileSlotTargetScale(index, slotIndex, hiddenScale);
                  window.setTileSpecies(index, hiddenSpecies);
              }
          });
      };
  
      // Initialize crop highlighting atoms hooks when utilities are loaded
      function initializeCropHighlightingAtoms() {
          if (!targetWindow.jotaiAtomCache) {
              // Wait for jotaiAtomCache to be available
              setTimeout(initializeCropHighlightingAtoms, 1000);
              return;
          }
  
          try {
              hookAtomForTileOverrides("/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myDataAtom", "gardenInfo");
              hookAtomForTileOverrides("/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom", "currentCrop");
              debugLog('CROP_HIGHLIGHT', 'Crop highlighting atom hooks initialized');
          } catch (error) {
              debugError('CROP_HIGHLIGHT', 'Failed to initialize crop highlighting atoms', error);
          }
      }
  
      // Track the last highlighted species for toggle functionality
      window.__lastHighlightedSpecies = null;
  
      // Initialize the crop highlighting atom hooks
      initializeCropHighlightingAtoms();
  
      // ==================== CROP HIGHLIGHTING SYSTEM ====================
      function applyCropHighlighting() {
          try {
              // Get values from UI
              const highlightSpecies = targetDocument.querySelector('#highlight-species-select')?.value || null;
              const slotIndex = parseInt(targetDocument.querySelector('#highlight-slot-input')?.value || '0');
              const hiddenSpecies = targetDocument.querySelector('#hidden-species-select')?.value || null;
              const hiddenScale = parseFloat(targetDocument.querySelector('#hidden-scale-input')?.value || '0.1');
  
              // Validate inputs
              if (!highlightSpecies) {
                  productionWarn('üå± No species selected for highlighting');
                  return;
              }
  
              // Always clear previous highlights first
              if (typeof window.removeAllTileOverrides === 'function') {
                  window.removeAllTileOverrides();
                  debugLog('CROP_HIGHLIGHTING', 'Cleared previous tile overrides');
              } else {
                  debugLog('CROP_HIGHLIGHTING', 'removeAllTileOverrides function not available');
              }
  
              // Apply new highlighting
              const config = {
                  highlightSpecies: highlightSpecies,
                  highlightMutations: [null], // Default to no mutation filter
                  slotIndex: slotIndex,
                  highlightScale: null, // Let the system decide
                  hiddenSpecies: hiddenSpecies || null,
                  hiddenScale: hiddenScale
              };
  
              if (typeof window.highlightTilesByMutation === 'function') {
                  window.highlightTilesByMutation(config);
                  productionLog(`üå± Applied crop highlighting for ${highlightSpecies} (slot ${slotIndex})`);
                  debugLog('CROP_HIGHLIGHTING', 'Applied highlighting configuration', config);
              } else {
                  productionWarn('üå± highlightTilesByMutation function not available');
                  debugLog('CROP_HIGHLIGHTING', 'highlightTilesByMutation function not found in window object');
              }
          } catch (error) {
              debugError('CROP_HIGHLIGHTING', 'Failed to apply crop highlighting', error);
          }
      }
  
      function clearCropHighlighting() {
          try {
              if (typeof window.removeAllTileOverrides === 'function') {
                  window.removeAllTileOverrides();
                  productionLog('üå± Cleared all crop highlighting');
                  queueNotification('üßπ Cleared all crop highlighting', false);
                  debugLog('CROP_HIGHLIGHTING', 'Cleared all tile overrides');
                  return true;
              } else {
                  productionWarn('üå± removeAllTileOverrides function not available');
                  queueNotification('‚ö†Ô∏è Cannot clear highlighting - game not fully loaded', false);
                  debugLog('CROP_HIGHLIGHTING', 'removeAllTileOverrides function not found in window object');
                  return false;
              }
          } catch (error) {
              debugError('CROP_HIGHLIGHTING', 'Failed to clear crop highlighting', error);
          }
      }
  
      // Debug function to check garden data availability
      function debugCropHighlighting() {
          productionLog('üîç CROP HIGHLIGHTING DEBUG:');
          productionLog('  window.gardenInfo:', !!window.gardenInfo);
          productionLog('  window.currentCrop:', !!window.currentCrop);
          productionLog('  targetWindow.jotaiAtomCache:', !!targetWindow.jotaiAtomCache);
  
          if (window.gardenInfo?.garden?.tileObjects) {
              const tileObjects = window.gardenInfo.garden.tileObjects;
              const tileCount = Array.isArray(tileObjects) ? tileObjects.length :
                               tileObjects instanceof Map ? tileObjects.size :
                               Object.keys(tileObjects).length;
              productionLog('  Garden tiles available:', tileCount);
  
              // Show first few tiles for debugging
              if (Array.isArray(tileObjects) && tileObjects.length > 0) {
                  productionLog('  Sample tile:', tileObjects[0]);
              }
          } else {
              productionLog('  ‚ùå No garden tile data available');
          }
  
          if (window.currentCrop && Array.isArray(window.currentCrop) && window.currentCrop.length > 0) {
              productionLog('  Current crop species:', window.currentCrop[0]?.species);
          } else {
              productionLog('  ‚ùå No current crop data available');
          }
  
          productionLog('  Available functions:');
          productionLog('    removeAllTileOverrides:', typeof window.removeAllTileOverrides);
          productionLog('    highlightTilesByMutation:', typeof window.highlightTilesByMutation);
          productionLog('    setTileSpecies:', typeof window.setTileSpecies);
      }
  
      // Improved manual highlighting with better debugging and error handling
      function applyCropHighlightingWithDebug() {
          productionLog('üå± Starting crop highlighting...');
          debugCropHighlighting();
  
          try {
              // Get values from UI
              const highlightSpecies = targetDocument.querySelector('#highlight-species-select')?.value || null;
              const slotIndex = parseInt(targetDocument.querySelector('#highlight-slot-input')?.value || '0');
              const hiddenSpecies = targetDocument.querySelector('#hidden-species-select')?.value || 'Carrot';
              const hiddenScale = parseFloat(targetDocument.querySelector('#hidden-scale-input')?.value || '0.1');
  
              productionLog('üå± Settings:', { highlightSpecies, slotIndex, hiddenSpecies, hiddenScale });
  
              // Validate inputs
              if (!highlightSpecies) {
                  productionWarn('üå± No species selected for highlighting');
                  queueNotification('‚ö†Ô∏è Please select a species to highlight first', false);
                  return false;
              }
  
              // Check if required game functions are available
              const hasRemoveOverrides = typeof window.removeAllTileOverrides === 'function';
              const hasHighlightFunction = typeof window.highlightTilesByMutation === 'function';
  
              productionLog('üå± Function availability:', {
                  removeAllTileOverrides: hasRemoveOverrides,
                  highlightTilesByMutation: hasHighlightFunction
              });
  
              if (!hasHighlightFunction) {
                  productionWarn('üå± Crop highlighting function not available - game may not be loaded yet');
                  queueNotification('‚ö†Ô∏è Crop highlighting not available - try again when fully loaded', false);
                  return false;
              }
  
              // Always clear previous highlights first
              if (hasRemoveOverrides) {
                  window.removeAllTileOverrides();
                  productionLog('üå± Cleared previous highlights');
              }
  
              // Apply new highlighting with array format
              const config = {
                  highlightSpecies: [highlightSpecies], // Convert to array like working reference
                  highlightMutations: [null], // Default to no mutation filter
                  slotIndex: slotIndex,
                  highlightScale: null, // Let the system decide
                  hiddenSpecies: hiddenSpecies,
                  hiddenScale: hiddenScale
              };
  
              productionLog('üå± Applying config:', config);
  
              try {
                  window.highlightTilesByMutation(config);
                  productionLog(`‚úÖ Applied crop highlighting for ${highlightSpecies} (slot ${slotIndex})`);
                  queueNotification(`üå± Highlighted all ${highlightSpecies} crops (slot ${slotIndex})`, false);
  
                  // Force a re-render by triggering a small change
                  setTimeout(() => {
                      productionLog('üîÑ Forcing render update...');
                      try {
                          globalThis.dispatchEvent?.(new Event("visibilitychange"));
                      } catch (e) {
                          productionLog('Could not dispatch visibility change:', e);
                      }
                  }, 100);
  
                  return true;
              } catch (highlightError) {
                  productionError('üå± Error during highlighting:', highlightError);
                  queueNotification(`‚ùå Crop highlighting failed: ${highlightError.message}`, false);
                  return false;
              }
  
          } catch (error) {
              productionError('‚ùå Failed to apply crop highlighting:', error);
              queueNotification(`‚ùå Crop highlighting system error: ${error.message}`, false);
              return false;
          }
      }
  
      // Automatic highlighting with Ctrl+C (from working reference)
      function setupAutomaticCropHighlighting() {
          window.addEventListener('keydown', function (e) {
              // Ignore when typing in input fields
              const active = document.activeElement;
              if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) return;
  
              // Ctrl (or Cmd) + C for automatic highlighting
              if ((e.ctrlKey || e.metaKey) && (e.key === 'c' || e.key === 'C')) {
                  try {
                      const cc = window.currentCrop;
  
                      window.removeAllTileOverrides(); // always clear first
                      productionLog('üå± Ctrl+C: Cleared previous highlights');
  
                      if (cc && Array.isArray(cc) && cc.length > 0 && cc[0] && cc[0].species) {
                          const species = cc[0].species;
  
                          if (window.__lastHighlightedSpecies === species) {
                              // Same species pressed twice ‚Üí just clear
                              productionLog(`üå± Ctrl+C: Removed highlights (${species} was already highlighted)`);
                              window.__lastHighlightedSpecies = null;
                          } else {
                              // New species ‚Üí highlight it after delay
                              setTimeout(() => {
                                  window.highlightTilesByMutation({
                                      highlightSpecies: [species],
                                      highlightMutations: [null],
                                      slotIndex: 0,
                                      highlightScale: null,
                                      hiddenSpecies: "Carrot",
                                      hiddenScale: 0.1
                                  });
                                  productionLog(`‚úÖ Ctrl+C: Highlighted current crop: ${species}`);
                                  window.__lastHighlightedSpecies = species;
                              }, 350);
                          }
                      } else {
                          // currentCrop is null or invalid ‚Üí just clear
                          productionLog('üå± Ctrl+C: No current crop - highlights cleared');
                          window.__lastHighlightedSpecies = null;
                      }
  
                      e.preventDefault(); // block normal copy
                  } catch (err) {
                      console.error('‚ùå Error handling Ctrl+C highlight action', err);
                  }
              }
          });
  
          productionLog('üå± Automatic crop highlighting installed (Ctrl+C)');
      }
  
      // Replace the original applyCropHighlighting with the debug version
      applyCropHighlighting = applyCropHighlightingWithDebug;
  
      // Install automatic highlighting
      setupAutomaticCropHighlighting();
  
      // ==================== GLOBAL DEBUGGING FUNCTIONS ====================
      // Make debugging functions globally accessible
      window.debugCropHighlighting = debugCropHighlighting;
      window.applyCropHighlightingWithDebug = applyCropHighlightingWithDebug;
  
      // BUGFIX: Add ability log verification command
      window.MGA_AbilityLogDebug = {
          checkLogs: function() {
              const allLogs = MGA_getAllLogs();
              const oldLogs = allLogs.filter(log =>
                  log.abilityType && /produce\s*scale\s*boost/i.test(log.abilityType)
              );
              const newLogs = allLogs.filter(log =>
                  log.abilityType && /crop\s*size\s*boost/i.test(log.abilityType)
              );
  
              console.log('=== ABILITY LOG VERIFICATION ===');
              console.log('Old "Produce Scale Boost" logs:', oldLogs.length);
              if (oldLogs.length > 0) {
                  console.warn('‚ö†Ô∏è Found unmigrated logs - migration may need to run again');
                  console.log('Sample old logs:', oldLogs.slice(0, 3));
              }
              console.log('New "Crop Size Boost" logs:', newLogs.length);
              console.log('Total logs:', allLogs.length);
              console.log('============================');
  
              return { oldCount: oldLogs.length, newCount: newLogs.length, total: allLogs.length };
          },
          listAllAbilities: function() {
              const allLogs = MGA_getAllLogs();
              const abilityTypes = [...new Set(allLogs.map(log => log.abilityType))].sort();
              console.log('=== ALL UNIQUE ABILITIES IN LOGS ===');
              abilityTypes.forEach((ability, i) => {
                  const count = allLogs.filter(log => log.abilityType === ability).length;
                  console.log(`${i + 1}. ${ability} (${count} logs)`);
              });
              console.log('===================================');
              return abilityTypes;
          }
      };
  
      window.MGA_CropDebug = {
          debug: debugCropHighlighting,
          apply: applyCropHighlightingWithDebug,
          clear: clearCropHighlighting,
          testHighlight: function(species = 'Aloe') {
              productionLog(`üß™ Testing highlight for ${species}...`);
              if (typeof window.removeAllTileOverrides === 'function') {
                  window.removeAllTileOverrides();
              }
              setTimeout(() => {
                  if (typeof window.highlightTilesByMutation === 'function') {
                      window.highlightTilesByMutation({
                          highlightSpecies: [species],
                          highlightMutations: [null],
                          slotIndex: 0,
                          highlightScale: null,
                          hiddenSpecies: "Carrot",
                          hiddenScale: 0.1
                      });
                      productionLog(`‚úÖ Test highlight applied for ${species}`);
                  } else {
                      console.error('‚ùå highlightTilesByMutation not available');
                  }
              }, 100);
          },
          listAvailableSpecies: function() {
              if (window.gardenInfo?.garden?.tileObjects) {
                  const tileObjects = window.gardenInfo.garden.tileObjects;
                  const species = new Set();
  
                  const entries = Array.isArray(tileObjects) ? tileObjects :
                                 tileObjects instanceof Map ? Array.from(tileObjects.values()) :
                                 Object.values(tileObjects);
  
                  entries.forEach(tile => {
                      if (tile?.species) species.add(tile.species);
                  });
  
                  productionLog('üå± Available species in your garden:', Array.from(species));
                  return Array.from(species);
              } else {
                  productionLog('‚ùå No garden data available');
                  return [];
              }
          },
          checkFunctions: function() {
              productionLog('üîç Crop highlighting function status:');
              productionLog('  removeAllTileOverrides:', typeof window.removeAllTileOverrides);
              productionLog('  highlightTilesByMutation:', typeof window.highlightTilesByMutation);
              productionLog('  setTileSpecies:', typeof window.setTileSpecies);
              productionLog('  setTileSlotTargetScale:', typeof window.setTileSlotTargetScale);
              productionLog('  gardenInfo available:', !!window.gardenInfo);
              productionLog('  currentCrop available:', !!window.currentCrop);
          },
          forceRefresh: function() {
              productionLog('üîÑ Forcing multiple refresh attempts...');
  
              // Method 1: Visibility change
              try {
                  globalThis.dispatchEvent?.(new Event("visibilitychange"));
                  productionLog('‚úÖ Triggered visibilitychange event');
              } catch (e) {
                  productionLog('‚ùå Could not trigger visibilitychange');
              }
  
              // Method 2: Focus events
              try {
                  window.dispatchEvent(new Event('focus'));
                  window.dispatchEvent(new Event('blur'));
                  window.dispatchEvent(new Event('focus'));
                  productionLog('‚úÖ Triggered focus/blur events');
              } catch (e) {
                  productionLog('‚ùå Could not trigger focus events');
              }
  
              // Method 3: Resize event
              try {
                  window.dispatchEvent(new Event('resize'));
                  productionLog('‚úÖ Triggered resize event');
              } catch (e) {
                  productionLog('‚ùå Could not trigger resize');
              }
  
              // Method 4: Force re-hook atoms
              setTimeout(() => {
                  productionLog('üîÑ Re-hooking atoms...');
                  if (targetWindow.jotaiAtomCache) {
                      hookAtomForTileOverrides("/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myDataAtom", "gardenInfo");
                      hookAtomForTileOverrides("/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom", "currentCrop");
                  }
              }, 100);
  
              // Method 5: Mouse movement simulation
              try {
                  const mouseEvent = new MouseEvent('mousemove', {
                      view: window,
                      bubbles: true,
                      cancelable: true,
                      clientX: window.innerWidth / 2,
                      clientY: window.innerHeight / 2
                  });
                  document.dispatchEvent(mouseEvent);
                  productionLog('‚úÖ Triggered mouse movement');
              } catch (e) {
                  productionLog('‚ùå Could not trigger mouse movement');
              }
          },
          inspectOverrides: function() {
              productionLog('üîç Current tile overrides:');
              productionLog('  Species overrides:', window.__tileOverrides);
              productionLog('  Scale overrides:', window.__slotTargetOverrides);
  
              const speciesCount = Object.keys(window.__tileOverrides || {}).length;
              const scaleCount = Object.keys(window.__slotTargetOverrides || {}).length;
              productionLog(`  Total overrides: ${speciesCount} species, ${scaleCount} scales`);
  
              if (speciesCount > 0) {
                  productionLog('üìã Sample species overrides:');
                  Object.entries(window.__tileOverrides).slice(0, 5).forEach(([index, species]) => {
                      productionLog(`    Tile ${index} ‚Üí ${species}`);
                  });
              }
          },
          enableDebugMode: function() {
              UnifiedState.data.settings.debugMode = true;
              productionLog('üêõ Debug mode enabled - you will see detailed tile modification logs');
          },
          disableDebugMode: function() {
              UnifiedState.data.settings.debugMode = false;
              productionLog('üîá Debug mode disabled');
          },
          strongRefresh: function() {
              productionLog('üí™ Attempting strong refresh with multiple methods...');
              this.forceRefresh();
  
              // Wait and try again
              setTimeout(() => {
                  productionLog('üîÑ Second refresh wave...');
                  this.forceRefresh();
  
                  // Try direct garden access
                  setTimeout(() => {
                      if (window.gardenInfo?.garden?.tileObjects) {
                          productionLog('üéØ Triggering direct garden re-read...');
                          const tileObjects = window.gardenInfo.garden.tileObjects;
                          const count = Array.isArray(tileObjects) ? tileObjects.length :
                                       tileObjects instanceof Map ? tileObjects.size :
                                       Object.keys(tileObjects).length;
                          productionLog(`üìä Garden has ${count} tiles - forcing re-process...`);
  
                          // Force a property access that might trigger re-rendering
                          try {
                              if (Array.isArray(tileObjects)) {
                                  tileObjects.forEach((tile, idx) => {
                                      if (tile) {
                                          const _ = tile.species; // Force property access
                                          const __ = tile.slots; // Force slots access
                                      }
                                  });
                              }
                              productionLog('‚úÖ Forced tile property access complete');
                          } catch (e) {
                              productionLog('‚ùå Could not force tile access:', e);
                          }
                      }
                  }, 200);
              }, 500);
          }
      };
  
      // Backward compatibility aliases to prevent conflicts with other scripts
      // These key functions are exposed with MGA_ prefix to coexist with other mods
      window.MGA_removeAllTileOverrides = window.MGA_Internal.removeAllTileOverrides;
      window.MGA_highlightTilesByMutation = window.highlightTilesByMutation;
      window.MGA_setTileSpecies = window.MGA_Internal.setTileSpecies;
      window.MGA_setTileSlotTargetScale = window.MGA_Internal.setTileSlotTargetScale;
  
      // For scripts that might still depend on the global names, check if they exist
      // If not (meaning no conflict), provide them. If they do exist, skip to avoid conflicts.
      if (typeof window.removeAllTileOverrides !== 'function') {
          window.removeAllTileOverrides = window.MGA_Internal.removeAllTileOverrides;
      }
      if (typeof window.setTileSpecies !== 'function') {
          window.setTileSpecies = window.MGA_Internal.setTileSpecies;
      }
      if (typeof window.setTileSlotTargetScale !== 'function') {
          window.setTileSlotTargetScale = window.MGA_Internal.setTileSlotTargetScale;
      }
  
      productionLog('üå± Crop highlighting debugging tools installed:');
      productionLog('  ‚Ä¢ debugCropHighlighting() - Full diagnostic');
      productionLog('  ‚Ä¢ MGA_CropDebug.debug() - Same as above');
      productionLog('  ‚Ä¢ MGA_CropDebug.testHighlight("Aloe") - Test highlighting');
      productionLog('  ‚Ä¢ MGA_CropDebug.listAvailableSpecies() - See what you have');
      productionLog('  ‚Ä¢ MGA_CropDebug.checkFunctions() - Verify functions exist');
      productionLog('  ‚Ä¢ MGA_CropDebug.clear() - Clear all highlights');
      productionLog('  üîß Advanced debugging:');
      productionLog('  ‚Ä¢ MGA_CropDebug.inspectOverrides() - See current overrides');
      productionLog('  ‚Ä¢ MGA_CropDebug.enableDebugMode() - Detailed tile logs');
      productionLog('  ‚Ä¢ MGA_CropDebug.forceRefresh() - Force game refresh');
      productionLog('  ‚Ä¢ MGA_CropDebug.strongRefresh() - Aggressive refresh');
  
      function applyPreset(preset) {
          const settings = UnifiedState.data.settings;
  
          switch (preset) {
              case 'gaming':
                  settings.opacity = 85;
                  settings.gradientStyle = 'red-orange';
                  settings.effectStyle = 'neon';
                  break;
              case 'minimal':
                  settings.opacity = 70;
                  settings.gradientStyle = 'blue-purple';
                  settings.effectStyle = 'glass';
                  break;
              case 'vibrant':
                  settings.opacity = 95;
                  settings.gradientStyle = 'purple-pink';
                  settings.effectStyle = 'neon';
                  break;
              case 'dark':
                  settings.opacity = 90;
                  settings.gradientStyle = 'blue-purple';
                  settings.effectStyle = 'metallic';
                  break;
              case 'luxury':
                  settings.opacity = 88;
                  settings.gradientStyle = 'gold-yellow';
                  settings.effectStyle = 'metallic';
                  break;
              case 'steel':
                  settings.opacity = 92;
                  settings.gradientStyle = 'steel-blue';
                  settings.effectStyle = 'steel';
                  break;
              case 'chrome':
                  settings.opacity = 85;
                  settings.gradientStyle = 'chrome-silver';
                  settings.effectStyle = 'chrome';
                  break;
              case 'titanium':
                  settings.opacity = 90;
                  settings.gradientStyle = 'titanium-gray';
                  settings.effectStyle = 'titanium';
                  break;
              case 'reset':
                  settings.opacity = 95;
                  settings.gradientStyle = 'blue-purple';
                  settings.effectStyle = 'none';
                  break;
          }
  
          applyTheme();
          updateTabContent(); // Refresh the settings tab
          MGA_saveJSON('MGA_data', UnifiedState.data);
      }
  
      // Universal theme generation function with dual opacity support
      function generateThemeStyles(settings = UnifiedState.data.settings, isPopout = false) {
          // Use different opacity based on window type
          const opacity = isPopout ?
              (settings.popoutOpacity / 100) :
              (settings.opacity / 100);
  
          // Apply opacity boost only at 100% to ensure truly solid panels
          let effectiveOpacity = opacity;
          if (opacity === 1.0) {
              effectiveOpacity = 1.8; // Overboost for solid appearance
          }
  
          // Define gradient styles - ALL themes now use effectiveOpacity for true 100% support
          const gradients = {
              // ‚ö´ BLACK ACCENT THEMES (Solid backgrounds with vibrant accent colors)
              'black-crimson': 'linear-gradient(135deg, rgba(0, 0, 0, ' + effectiveOpacity + ') 0%, rgba(26, 0, 0, ' + effectiveOpacity + ') 50%, rgba(0, 0, 0, ' + effectiveOpacity + ') 100%)',
              'black-emerald': 'linear-gradient(135deg, rgba(0, 0, 0, ' + effectiveOpacity + ') 0%, rgba(0, 26, 0, ' + effectiveOpacity + ') 50%, rgba(0, 0, 0, ' + effectiveOpacity + ') 100%)',
              'black-royal': 'linear-gradient(135deg, rgba(0, 0, 0, ' + effectiveOpacity + ') 0%, rgba(13, 0, 21, ' + effectiveOpacity + ') 50%, rgba(0, 0, 0, ' + effectiveOpacity + ') 100%)',
              'black-gold': 'linear-gradient(135deg, rgba(0, 0, 0, ' + effectiveOpacity + ') 0%, rgba(26, 20, 0, ' + effectiveOpacity + ') 50%, rgba(0, 0, 0, ' + effectiveOpacity + ') 100%)',
              'black-ice': 'linear-gradient(135deg, rgba(0, 0, 0, ' + effectiveOpacity + ') 0%, rgba(0, 13, 26, ' + effectiveOpacity + ') 50%, rgba(0, 0, 0, ' + effectiveOpacity + ') 100%)',
              'black-flame': 'linear-gradient(135deg, rgba(0, 0, 0, ' + effectiveOpacity + ') 0%, rgba(26, 13, 0, ' + effectiveOpacity + ') 50%, rgba(0, 0, 0, ' + effectiveOpacity + ') 100%)',
              'black-toxic': 'linear-gradient(135deg, rgba(0, 0, 0, ' + effectiveOpacity + ') 0%, rgba(10, 26, 0, ' + effectiveOpacity + ') 50%, rgba(0, 0, 0, ' + effectiveOpacity + ') 100%)',
              'black-pink': 'linear-gradient(135deg, rgba(0, 0, 0, ' + effectiveOpacity + ') 0%, rgba(26, 0, 20, ' + effectiveOpacity + ') 50%, rgba(0, 0, 0, ' + effectiveOpacity + ') 100%)',
              'black-matrix': 'linear-gradient(135deg, rgba(0, 0, 0, ' + effectiveOpacity + ') 0%, rgba(0, 17, 0, ' + effectiveOpacity + ') 50%, rgba(0, 0, 0, ' + effectiveOpacity + ') 100%)',
              'black-sunset': 'linear-gradient(135deg, rgba(0, 0, 0, ' + effectiveOpacity + ') 0%, rgba(26, 10, 0, ' + effectiveOpacity + ') 50%, rgba(0, 0, 0, ' + effectiveOpacity + ') 100%)',
              'black-blood': 'linear-gradient(135deg, rgba(0, 0, 0, ' + effectiveOpacity + ') 0%, rgba(40, 0, 0, ' + effectiveOpacity + ') 50%, rgba(0, 0, 0, ' + effectiveOpacity + ') 100%)',
              'black-neon': 'linear-gradient(135deg, rgba(0, 0, 0, ' + effectiveOpacity + ') 0%, rgba(0, 20, 30, ' + effectiveOpacity + ') 50%, rgba(0, 0, 0, ' + effectiveOpacity + ') 100%)',
              'black-storm': 'linear-gradient(135deg, rgba(0, 0, 0, ' + effectiveOpacity + ') 0%, rgba(10, 0, 30, ' + effectiveOpacity + ') 50%, rgba(0, 0, 0, ' + effectiveOpacity + ') 100%)',
              'black-sapphire': 'linear-gradient(135deg, rgba(0, 0, 0, ' + effectiveOpacity + ') 0%, rgba(0, 10, 40, ' + effectiveOpacity + ') 50%, rgba(0, 0, 0, ' + effectiveOpacity + ') 100%)',
              'black-aqua': 'linear-gradient(135deg, rgba(0, 0, 0, ' + effectiveOpacity + ') 0%, rgba(0, 25, 25, ' + effectiveOpacity + ') 50%, rgba(0, 0, 0, ' + effectiveOpacity + ') 100%)',
              'black-phantom': 'linear-gradient(135deg, rgba(0, 0, 0, ' + effectiveOpacity + ') 0%, rgba(20, 20, 20, ' + effectiveOpacity + ') 50%, rgba(0, 0, 0, ' + effectiveOpacity + ') 100%)',

              // üåà ORIGINAL THEMES
              'blue-purple': 'linear-gradient(135deg, rgba(20, 20, 35, ' + effectiveOpacity + ') 0%, rgba(30, 30, 50, ' + effectiveOpacity + ') 100%)',
              'green-blue': 'linear-gradient(135deg, rgba(20, 35, 20, ' + effectiveOpacity + ') 0%, rgba(30, 40, 60, ' + effectiveOpacity + ') 100%)',
              'red-orange': 'linear-gradient(135deg, rgba(35, 20, 20, ' + effectiveOpacity + ') 0%, rgba(50, 35, 30, ' + effectiveOpacity + ') 100%)',
              'purple-pink': 'linear-gradient(135deg, rgba(35, 20, 35, ' + effectiveOpacity + ') 0%, rgba(50, 30, 45, ' + effectiveOpacity + ') 100%)',
              'gold-yellow': 'linear-gradient(135deg, rgba(35, 30, 20, ' + effectiveOpacity + ') 0%, rgba(45, 40, 25, ' + effectiveOpacity + ') 100%)',
              // New vibrant gradients - using effectiveOpacity for better high-level opacity
              'electric-neon': 'linear-gradient(135deg, rgba(0, 100, 255, ' + (effectiveOpacity * 0.3) + ') 0%, rgba(147, 51, 234, ' + (effectiveOpacity * 0.4) + ') 100%)',
              'sunset-fire': 'linear-gradient(135deg, rgba(255, 94, 77, ' + (effectiveOpacity * 0.3) + ') 0%, rgba(255, 154, 0, ' + (effectiveOpacity * 0.4) + ') 100%)',
              'emerald-cyan': 'linear-gradient(135deg, rgba(16, 185, 129, ' + (effectiveOpacity * 0.3) + ') 0%, rgba(6, 182, 212, ' + (effectiveOpacity * 0.4) + ') 100%)',
              'royal-gold': 'linear-gradient(135deg, rgba(139, 69, 19, ' + (effectiveOpacity * 0.4) + ') 0%, rgba(255, 215, 0, ' + (effectiveOpacity * 0.3) + ') 100%)',
              'crimson-blaze': 'linear-gradient(135deg, rgba(220, 38, 127, ' + (effectiveOpacity * 0.3) + ') 0%, rgba(249, 115, 22, ' + (effectiveOpacity * 0.4) + ') 100%)',
              'ocean-deep': 'linear-gradient(135deg, rgba(15, 23, 42, ' + (effectiveOpacity * 0.8) + ') 0%, rgba(30, 64, 175, ' + (effectiveOpacity * 0.6) + ') 100%)',
              'forest-mystique': 'linear-gradient(135deg, rgba(20, 83, 45, ' + (effectiveOpacity * 0.6) + ') 0%, rgba(34, 197, 94, ' + (effectiveOpacity * 0.4) + ') 100%)',
              'cosmic-purple': 'linear-gradient(135deg, rgba(88, 28, 135, ' + (effectiveOpacity * 0.6) + ') 0%, rgba(168, 85, 247, ' + (effectiveOpacity * 0.4) + ') 100%)',
              'rainbow-burst': 'linear-gradient(135deg, rgba(239, 68, 68, ' + (effectiveOpacity * 0.25) + ') 0%, rgba(245, 158, 11, ' + (effectiveOpacity * 0.25) + ') 25%, rgba(34, 197, 94, ' + (effectiveOpacity * 0.25) + ') 50%, rgba(59, 130, 246, ' + (effectiveOpacity * 0.25) + ') 75%, rgba(147, 51, 234, ' + (effectiveOpacity * 0.25) + ') 100%)',
              // Premium metallic themes - FIXED for visibility with darker, richer tones
              'steel-blue': 'linear-gradient(135deg, rgba(30, 41, 59, ' + (effectiveOpacity * 0.95) + ') 0%, rgba(51, 65, 85, ' + (effectiveOpacity * 0.9) + ') 25%, rgba(71, 85, 105, ' + (effectiveOpacity * 0.85) + ') 50%, rgba(30, 58, 138, ' + (effectiveOpacity * 0.8) + ') 100%)',
              'chrome-silver': 'linear-gradient(135deg, rgba(55, 65, 81, ' + (effectiveOpacity * 0.9) + ') 0%, rgba(75, 85, 99, ' + (effectiveOpacity * 0.85) + ') 25%, rgba(100, 116, 139, ' + (effectiveOpacity * 0.8) + ') 50%, rgba(71, 85, 105, ' + (effectiveOpacity * 0.9) + ') 100%)',
              'titanium-gray': 'linear-gradient(135deg, rgba(31, 41, 55, ' + (effectiveOpacity * 0.95) + ') 0%, rgba(55, 65, 81, ' + (effectiveOpacity * 0.9) + ') 25%, rgba(75, 85, 99, ' + (effectiveOpacity * 0.85) + ') 50%, rgba(107, 114, 128, ' + (effectiveOpacity * 0.8) + ') 100%)',
              'platinum-white': 'linear-gradient(135deg, rgba(75, 85, 99, ' + (effectiveOpacity * 0.85) + ') 0%, rgba(100, 116, 139, ' + (effectiveOpacity * 0.8) + ') 25%, rgba(148, 163, 184, ' + (effectiveOpacity * 0.75) + ') 50%, rgba(156, 163, 175, ' + (effectiveOpacity * 0.7) + ') 100%)'
          };
  
          const background = gradients[settings.gradientStyle] || gradients['blue-purple'];
  
          // Generate effect styles for the current theme
          let boxShadow = '0 10px 40px rgba(0, 0, 0, 0.5)';
          let borderShadow = '';
  
          switch (settings.effectStyle) {
              case 'metallic':
                  boxShadow = `
                      0 10px 40px rgba(0, 0, 0, 0.5),
                      inset 0 1px 0 rgba(255, 255, 255, 0.57),
                      inset 0 -1px 0 rgba(0, 0, 0, 0.48)
                  `;
                  break;
              case 'neon':
                  borderShadow = `0 0 20px rgba(74, 158, 255, ${effectiveOpacity * 0.6})`;
                  boxShadow = `
                      0 10px 40px rgba(0, 0, 0, 0.5),
                      ${borderShadow}
                  `;
                  break;
              case 'plasma':
                  borderShadow = `0 0 30px rgba(147, 51, 234, ${effectiveOpacity * 0.5})`;
                  boxShadow = `
                      0 10px 40px rgba(0, 0, 0, 0.5),
                      ${borderShadow}
                  `;
                  break;
              case 'holographic':
                  boxShadow = `
                      0 10px 40px rgba(0, 0, 0, 0.5),
                      0 0 40px rgba(255, 255, 255, ${effectiveOpacity * 0.1}),
                      inset 0 1px 0 rgba(255, 255, 255, 0.73)
                  `;
                  break;
              case 'crystal':
                  boxShadow = `
                      0 10px 40px rgba(0, 0, 0, 0.5),
                      0 0 20px rgba(255, 255, 255, ${effectiveOpacity * 0.1}),
                      inset 0 1px 0 rgba(255, 255, 255, 0.3),
                      inset 0 -1px 0 rgba(0, 0, 0, 0.30)
                  `;
                  break;
          }
  
          // Accent colors for black themes
          const accentColors = {
              'black-crimson': { color: '#DC143C', glow: 'rgba(220, 20, 60, 0.5)', text: '#FF6B6B' },
              'black-emerald': { color: '#50C878', glow: 'rgba(80, 200, 120, 0.5)', text: '#90EE90' },
              'black-royal': { color: '#9D4EDD', glow: 'rgba(157, 78, 221, 0.5)', text: '#DDA0DD' },
              'black-gold': { color: '#FFD700', glow: 'rgba(255, 215, 0, 0.5)', text: '#FFD700' },
              'black-ice': { color: '#00FFFF', glow: 'rgba(0, 255, 255, 0.5)', text: '#B0E0E6' },
              'black-flame': { color: '#FF4500', glow: 'rgba(255, 69, 0, 0.5)', text: '#FF7F50' },
              'black-toxic': { color: '#7FFF00', glow: 'rgba(127, 255, 0, 0.5)', text: '#9ACD32' },
              'black-pink': { color: '#FF1493', glow: 'rgba(255, 20, 147, 0.5)', text: '#FFB6C1' },
              'black-matrix': { color: '#00FF00', glow: 'rgba(0, 255, 0, 0.8)', text: '#00FF00' },
              'black-sunset': { color: '#FF6B35', glow: 'rgba(255, 107, 53, 0.6)', text: '#FFA500' },
              'black-blood': { color: '#8B0000', glow: 'rgba(139, 0, 0, 0.7)', text: '#CD5C5C' },
              'black-neon': { color: '#00CED1', glow: 'rgba(0, 206, 209, 0.8)', text: '#AFEEEE' },
              'black-storm': { color: '#483D8B', glow: 'rgba(72, 61, 139, 0.6)', text: '#9370DB' },
              'black-sapphire': { color: '#0F52BA', glow: 'rgba(15, 82, 186, 0.7)', text: '#4169E1' },
              'black-aqua': { color: '#008B8B', glow: 'rgba(0, 139, 139, 0.6)', text: '#48D1CC' },
              'black-phantom': { color: '#C0C0C0', glow: 'rgba(192, 192, 192, 0.4)', text: '#DCDCDC' }
          };

          const accent = accentColors[settings.gradientStyle] || null;

          // Texture patterns (CSS background-image overlays)
          // ========== PROFESSIONAL TEXTURE SYSTEM 2.0 ==========
          // 25 premium patterns with proper visibility (0.12-0.25 opacity)
          const textures = {
              'none': '',

              // ===== MODERN GLASS (Apple iOS Glassmorphism) =====
              'frosted-glass': `
                  radial-gradient(circle at 35% 35%, rgba(74, 158, 255, 0.25), transparent 60%),
                  radial-gradient(circle at 65% 65%, rgba(0, 217, 255, 0.20), transparent 55%),
                  radial-gradient(circle at 20% 80%, rgba(147, 197, 253, 0.18), transparent 45%),
                  url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.15'/%3E%3C/svg%3E"),
                  linear-gradient(135deg, rgba(255, 255, 255, 0.12), rgba(200, 230, 255, 0.08))
              `,
              'crystal-prism': `
                  linear-gradient(45deg, rgba(74, 158, 255, 0.35) 0%, transparent 50%, rgba(147, 51, 234, 0.28) 100%),
                  linear-gradient(-45deg, transparent 0%, rgba(0, 217, 255, 0.30) 50%, transparent 100%),
                  radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.25), transparent 60%),
                  radial-gradient(circle at 30% 70%, rgba(139, 92, 246, 0.18), transparent 50%)
              `,
              'ice-frost': `
                  radial-gradient(circle at 20% 30%, rgba(147, 197, 253, 0.40) 0%, transparent 4%),
                  radial-gradient(circle at 60% 70%, rgba(191, 219, 254, 0.35) 0%, transparent 5%),
                  radial-gradient(circle at 80% 20%, rgba(224, 242, 254, 0.38) 0%, transparent 3%),
                  radial-gradient(circle at 40% 50%, rgba(59, 130, 246, 0.22) 0%, transparent 8%),
                  linear-gradient(to bottom, rgba(219, 234, 254, 0.15), rgba(147, 197, 253, 0.08))
              `,
              'smoke-flow': `
                  radial-gradient(ellipse at 0% 0%, rgba(96, 165, 250, 0.35), transparent 55%),
                  radial-gradient(ellipse at 100% 100%, rgba(147, 197, 253, 0.28), transparent 60%),
                  radial-gradient(ellipse at 50% 50%, rgba(191, 219, 254, 0.25), transparent 45%),
                  radial-gradient(ellipse at 30% 70%, rgba(59, 130, 246, 0.18), transparent 50%)
              `,
              'water-ripple': `
                  radial-gradient(circle, rgba(6, 182, 212, 0.30) 3px, transparent 3px),
                  radial-gradient(circle, rgba(34, 211, 238, 0.25) 2px, transparent 2px),
                  radial-gradient(circle, rgba(103, 232, 249, 0.18) 1.5px, transparent 1.5px),
                  linear-gradient(to bottom, rgba(165, 243, 252, 0.12), rgba(6, 182, 212, 0.08))
              `,

              // ===== PREMIUM MATERIALS (Photorealistic Luxury) =====
              'carbon-fiber-pro': `
                  repeating-linear-gradient(0deg,
                      rgba(59, 130, 246, 0.15) 0px,
                      rgba(147, 51, 234, 0.35) 1px,
                      rgba(99, 102, 241, 0.28) 2px,
                      rgba(139, 92, 246, 0.12) 3px,
                      transparent 4px),
                  repeating-linear-gradient(90deg,
                      rgba(30, 58, 138, 0.18) 0px,
                      rgba(67, 56, 202, 0.32) 1px,
                      rgba(79, 70, 229, 0.25) 2px,
                      rgba(99, 102, 241, 0.15) 3px,
                      transparent 4px),
                  linear-gradient(135deg, rgba(30, 27, 75, 0.20), rgba(67, 56, 202, 0.10))
              `,
              'brushed-aluminum': `
                  repeating-linear-gradient(90deg,
                      rgba(226, 232, 240, 0.35) 0px,
                      rgba(203, 213, 225, 0.45) 0.5px,
                      rgba(226, 232, 240, 0.38) 1px,
                      rgba(241, 245, 249, 0.28) 1.5px,
                      rgba(203, 213, 225, 0.32) 2px),
                  linear-gradient(180deg, rgba(248, 250, 252, 0.18), rgba(226, 232, 240, 0.25)),
                  radial-gradient(circle at 50% 0%, rgba(255, 255, 255, 0.15), transparent 60%)
              `,
              'brushed-titanium': `
                  repeating-linear-gradient(45deg,
                      rgba(251, 191, 36, 0.30) 0px,
                      rgba(217, 119, 6, 0.40) 1px,
                      rgba(245, 158, 11, 0.35) 2px,
                      rgba(251, 191, 36, 0.25) 3px),
                  linear-gradient(135deg, rgba(217, 119, 6, 0.18), rgba(251, 191, 36, 0.12)),
                  radial-gradient(circle at 40% 40%, rgba(252, 211, 77, 0.20), transparent 55%)
              `,
              'leather-grain': `
                  url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='turbulence'%3E%3CfeTurbulence type='turbulence' baseFrequency='2.2' numOctaves='3'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23turbulence)' opacity='0.28'/%3E%3C/svg%3E"),
                  radial-gradient(circle at 60% 40%, rgba(127, 29, 29, 0.35), transparent 65%),
                  radial-gradient(circle at 30% 70%, rgba(153, 27, 27, 0.28), transparent 60%),
                  linear-gradient(135deg, rgba(185, 28, 28, 0.22), rgba(127, 29, 29, 0.18))
              `,
              'fabric-weave': `
                  repeating-linear-gradient(0deg, rgba(148, 163, 184, 0.35) 0px, transparent 1px, transparent 3px),
                  repeating-linear-gradient(90deg, rgba(148, 163, 184, 0.35) 0px, transparent 1px, transparent 3px),
                  linear-gradient(45deg, rgba(203, 213, 225, 0.15) 25%, transparent 25%, transparent 75%, rgba(203, 213, 225, 0.15) 75%),
                  linear-gradient(45deg, rgba(226, 232, 240, 0.12), rgba(203, 213, 225, 0.08))
              `,
              'wood-grain': `
                  linear-gradient(90deg,
                      rgba(217, 119, 6, 0.28) 0%,
                      rgba(251, 146, 60, 0.35) 8%,
                      rgba(217, 119, 6, 0.25) 16%,
                      rgba(234, 88, 12, 0.32) 24%,
                      rgba(251, 146, 60, 0.28) 32%,
                      rgba(217, 119, 6, 0.30) 40%),
                  repeating-linear-gradient(90deg, transparent 0px, rgba(180, 83, 9, 0.18) 1px, transparent 2px),
                  linear-gradient(180deg, rgba(251, 191, 36, 0.15), rgba(217, 119, 6, 0.10))
              `,

              // ===== TECH/FUTURISTIC (Cyberpunk Neon) =====
              'circuit-board': `
                  linear-gradient(rgba(34, 197, 94, 0.32) 1px, transparent 1px),
                  linear-gradient(90deg, rgba(34, 197, 94, 0.32) 1px, transparent 1px),
                  linear-gradient(rgba(16, 185, 129, 0.25) 2px, transparent 2px),
                  linear-gradient(90deg, rgba(16, 185, 129, 0.25) 2px, transparent 2px),
                  radial-gradient(circle at 25% 25%, rgba(52, 211, 153, 0.20), transparent 15%),
                  radial-gradient(circle at 75% 75%, rgba(16, 185, 129, 0.18), transparent 15%),
                  linear-gradient(135deg, rgba(6, 78, 59, 0.15), rgba(20, 83, 45, 0.10))
              `,
              'hexagon-grid-pro': `
                  repeating-linear-gradient(0deg, transparent, transparent 22px, rgba(6, 182, 212, 0.38) 22px, rgba(14, 165, 233, 0.38) 23px),
                  repeating-linear-gradient(60deg, transparent, transparent 22px, rgba(34, 211, 238, 0.32) 22px, rgba(6, 182, 212, 0.32) 23px),
                  repeating-linear-gradient(120deg, transparent, transparent 22px, rgba(56, 189, 248, 0.32) 22px, rgba(14, 165, 233, 0.32) 23px),
                  radial-gradient(circle at 50% 50%, rgba(125, 211, 252, 0.18), transparent 50%)
              `,
              'hologram-scan': `
                  repeating-linear-gradient(0deg,
                      transparent 0px,
                      rgba(6, 182, 212, 0.22) 1px,
                      rgba(236, 72, 153, 0.32) 2px,
                      rgba(6, 182, 212, 0.22) 3px,
                      transparent 4px),
                  linear-gradient(90deg, rgba(236, 72, 153, 0.15), rgba(6, 182, 212, 0.15), rgba(236, 72, 153, 0.15)),
                  radial-gradient(circle at 50% 50%, rgba(236, 72, 153, 0.18), transparent 60%)
              `,
              'matrix-rain': `
                  linear-gradient(rgba(34, 197, 94, 0.35) 2px, transparent 2px),
                  linear-gradient(90deg, rgba(16, 185, 129, 0.28) 1px, transparent 1px),
                  radial-gradient(circle at 30% 40%, rgba(52, 211, 153, 0.20), transparent 50%),
                  linear-gradient(180deg, rgba(34, 197, 94, 0.12), rgba(6, 78, 59, 0.08))
              `,
              'energy-waves': `
                  radial-gradient(ellipse at 50% 0%, rgba(59, 130, 246, 0.40), transparent 45%),
                  radial-gradient(ellipse at 50% 100%, rgba(96, 165, 250, 0.38), transparent 45%),
                  radial-gradient(ellipse at 50% 50%, rgba(147, 197, 253, 0.28), transparent 35%),
                  radial-gradient(ellipse at 0% 50%, rgba(29, 78, 216, 0.22), transparent 40%),
                  radial-gradient(ellipse at 100% 50%, rgba(37, 99, 235, 0.22), transparent 40%)
              `,
              'cyberpunk-grid': `
                  linear-gradient(rgba(236, 72, 153, 0.35) 1px, transparent 1px),
                  linear-gradient(90deg, rgba(6, 182, 212, 0.35) 1px, transparent 1px),
                  radial-gradient(circle at 50% 50%, rgba(168, 85, 247, 0.25), transparent 65%),
                  linear-gradient(135deg, rgba(236, 72, 153, 0.12), rgba(6, 182, 212, 0.12))
              `,

              // ===== GEOMETRIC CLEAN (Swiss Design) =====
              'dots-pro': `
                  radial-gradient(circle, rgba(100, 116, 139, 0.40) 2px, transparent 2px),
                  radial-gradient(circle, rgba(148, 163, 184, 0.20) 1px, transparent 1px),
                  linear-gradient(to bottom right, rgba(203, 213, 225, 0.10), rgba(148, 163, 184, 0.08))
              `,
              'grid-pro': `
                  linear-gradient(rgba(100, 116, 139, 0.35) 1px, transparent 1px),
                  linear-gradient(90deg, rgba(100, 116, 139, 0.35) 1px, transparent 1px),
                  linear-gradient(rgba(148, 163, 184, 0.15) 1px, transparent 1px),
                  linear-gradient(90deg, rgba(148, 163, 184, 0.15) 1px, transparent 1px)
              `,
              'diagonal-pro': `
                  repeating-linear-gradient(45deg,
                      transparent,
                      transparent 18px,
                      rgba(100, 116, 139, 0.32) 18px,
                      rgba(148, 163, 184, 0.28) 19px,
                      transparent 20px),
                  linear-gradient(135deg, rgba(203, 213, 225, 0.10), rgba(148, 163, 184, 0.05))
              `,
              'waves': `
                  repeating-radial-gradient(circle at 50% 50%,
                      transparent 0px,
                      rgba(100, 116, 139, 0.30) 12px,
                      transparent 24px),
                  radial-gradient(circle at 50% 50%, rgba(148, 163, 184, 0.18), transparent 60%)
              `,
              'triangles': `
                  linear-gradient(45deg, rgba(100, 116, 139, 0.35) 25%, transparent 25%),
                  linear-gradient(-45deg, rgba(100, 116, 139, 0.35) 25%, transparent 25%),
                  linear-gradient(45deg, transparent 75%, rgba(148, 163, 184, 0.28) 75%),
                  linear-gradient(-45deg, transparent 75%, rgba(148, 163, 184, 0.28) 75%)
              `,
              'crosshatch': `
                  repeating-linear-gradient(0deg, transparent, transparent 4px, rgba(100, 116, 139, 0.32) 4px, rgba(100, 116, 139, 0.32) 5px),
                  repeating-linear-gradient(90deg, transparent, transparent 4px, rgba(148, 163, 184, 0.28) 4px, rgba(148, 163, 184, 0.28) 5px)
              `,

              // ===== SPECIAL EFFECTS (Atmospheric) =====
              'perlin-noise': `
                  url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='perlin'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='5' stitchTiles='stitch'/%3E%3CfeColorMatrix values='0.3 0 0 0 0.4, 0 0.4 0 0 0.5, 0 0 0.5 0 0.6, 0 0 0 0.35 0'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23perlin)'/%3E%3C/svg%3E"),
                  radial-gradient(circle at 50% 50%, rgba(147, 51, 234, 0.15), transparent 70%)
              `,
              'gradient-mesh': `
                  radial-gradient(circle at 25% 25%, rgba(139, 92, 246, 0.35), transparent 55%),
                  radial-gradient(circle at 75% 25%, rgba(59, 130, 246, 0.32), transparent 55%),
                  radial-gradient(circle at 25% 75%, rgba(236, 72, 153, 0.30), transparent 55%),
                  radial-gradient(circle at 75% 75%, rgba(6, 182, 212, 0.28), transparent 55%),
                  linear-gradient(135deg, rgba(167, 139, 250, 0.12), rgba(96, 165, 250, 0.12))
              `
          };

          const textureBackgroundSize = {
              'frosted-glass': '100% 100%, 100% 100%, 100% 100%, cover, 100% 100%',
              'crystal-prism': '100% 100%, 100% 100%, 100% 100%, 100% 100%',
              'ice-frost': '100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%',
              'smoke-flow': '100% 100%, 100% 100%, 100% 100%, 100% 100%',
              'water-ripple': '30px 30px, 50px 50px, 40px 40px, 100% 100%',
              'carbon-fiber-pro': '6px 6px, 6px 6px, 100% 100%',
              'brushed-aluminum': '2px 100%, 100% 100%, 100% 100%',
              'brushed-titanium': '3px 3px, 100% 100%, 100% 100%',
              'leather-grain': 'cover, 100% 100%, 100% 100%, 100% 100%',
              'fabric-weave': '4px 4px, 4px 4px, 30px 30px, 100% 100%',
              'wood-grain': '100% 40px, 100% 2px, 100% 100%',
              'circuit-board': '40px 40px, 40px 40px, 120px 120px, 120px 120px, 100% 100%, 100% 100%, 100% 100%',
              'hexagon-grid-pro': '100% 100%, 100% 100%, 100% 100%, 100% 100%',
              'hologram-scan': '100% 5px, 100% 100%, 100% 100%',
              'matrix-rain': '2px 20px, 10px 10px, 100% 100%, 100% 100%',
              'energy-waves': '100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%',
              'cyberpunk-grid': '50px 50px, 50px 50px, 100% 100%, 100% 100%',
              'dots-pro': '25px 25px, 20px 20px, 100% 100%',
              'grid-pro': '30px 30px, 30px 30px, 60px 60px, 60px 60px',
              'diagonal-pro': '100% 100%, 100% 100%',
              'waves': '100% 100%, 100% 100%',
              'triangles': '30px 30px, 30px 30px, 30px 30px, 30px 30px',
              'crosshatch': '100% 100%, 100% 100%',
              'perlin-noise': 'cover, 100% 100%',
              'gradient-mesh': '100% 100%, 100% 100%, 100% 100%, 100% 100%, 100% 100%'
          };

          const textureStyle = settings.textureStyle || 'none';
          let texturePattern = textures[textureStyle] || '';
          let textureBgSize = textureBackgroundSize[textureStyle] || 'auto';

          // Apply intensity multiplier to texture opacity
          const textureIntensity = (settings.textureIntensity !== undefined) ? settings.textureIntensity : 75;
          const intensityMultiplier = textureIntensity / 100; // 0-100% direct mapping

          if (texturePattern && intensityMultiplier !== 1.0) {
              // Multiply all rgba() opacity values by intensity multiplier
              texturePattern = texturePattern.replace(/rgba\((\d+),\s*(\d+),\s*(\d+),\s*([0-9.]+)\)/g, (match, r, g, b, a) => {
                  const newAlpha = Math.min(1, parseFloat(a) * intensityMultiplier);
                  return `rgba(${r}, ${g}, ${b}, ${newAlpha.toFixed(3)})`;
              });

              // Also handle SVG opacity attributes
              texturePattern = texturePattern.replace(/opacity='([0-9.]+)'/g, (match, a) => {
                  const newAlpha = Math.min(1, parseFloat(a) * intensityMultiplier);
                  return `opacity='${newAlpha.toFixed(2)}'`;
              });
          }

          // Apply scale multiplier to texture background-size
          const textureScale = settings.textureScale || 'medium';
          const scaleMultipliers = { small: 0.5, medium: 1.0, large: 2.0 };
          const scaleMultiplier = scaleMultipliers[textureScale];

          if (textureBgSize !== 'cover' && textureBgSize !== 'auto' && scaleMultiplier !== 1.0) {
              // Scale pixel/percentage values
              textureBgSize = textureBgSize.replace(/(\d+)(px|%)/g, (match, value, unit) => {
                  const scaled = Math.round(parseFloat(value) * scaleMultiplier);
                  return scaled + unit;
              });
          }

          // Get blend mode
          const textureBlendMode = settings.textureBlendMode || 'overlay';

          // Get animation setting
          const textureAnimated = settings.textureAnimated || false;

          return {
              background,
              boxShadow,
              opacity: isPopout ? settings.popoutOpacity : settings.opacity,
              effectiveOpacity: effectiveOpacity,
              gradientStyle: settings.gradientStyle,
              effectStyle: settings.effectStyle,
              textureStyle: textureStyle,
              texturePattern: texturePattern,
              textureBackgroundSize: textureBgSize,
              textureBlendMode: textureBlendMode,
              textureAnimated: textureAnimated,
              isPopout: isPopout,
              accentColor: accent ? accent.color : '#4a9eff',
              accentGlow: accent ? accent.glow : 'rgba(74, 158, 255, 0.5)',
              accentText: accent ? accent.text : '#FFFFFF'
          };
      }
  
      function applyThemeToElement(element, themeStyles) {
          if (!element || !themeStyles) return;
  
          const opacity = themeStyles.opacity / 100;
  
          // Handle true 0% opacity - completely transparent
          if (opacity === 0) {
              element.style.background = 'transparent';
              element.style.boxShadow = 'none';
              element.style.backdropFilter = 'none';
              element.style.border = 'none';
              productionLog('üîç Applied true 0% opacity - completely transparent');
              return;
          }
  
          // Handle true 100% opacity - completely opaque
          if (opacity === 1.0 && themeStyles.effectiveOpacity) {
              // For 100% opacity, use the background but ensure it's truly opaque
              element.style.background = themeStyles.background.replace(/rgba\(([^)]+)\)/g, (match, rgbaValues) => {
                  const values = rgbaValues.split(',');
                  if (values.length === 4) {
                      // Replace alpha with 1.0 for true opacity
                      return `rgba(${values[0]}, ${values[1]}, ${values[2]}, 1.0)`;
                  }
                  return match;
              });
  
              // Apply accent color border and glow for black themes
              const isBlackTheme = themeStyles.gradientStyle && themeStyles.gradientStyle.startsWith('black-');
              if (isBlackTheme && themeStyles.accentColor) {
                  element.style.boxShadow = `0 10px 40px rgba(0, 0, 0, 0.8), 0 0 30px ${themeStyles.accentGlow}`;
                  element.style.border = `1px solid ${themeStyles.accentColor}`;
              } else {
                  element.style.boxShadow = themeStyles.boxShadow;
                  element.style.border = '1px solid rgba(255, 255, 255, 0.73)';
              }
              element.style.backdropFilter = 'blur(15px)';
              productionLog('üé® Applied true 100% opacity - completely opaque');
              return;
          }
  
          // Handle regular opacity ranges (1-99%)
          // Layer texture over gradient if texture is enabled
          if (themeStyles.texturePattern) {
              element.style.background = `${themeStyles.texturePattern}, ${themeStyles.background}`;
              element.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
              element.style.backgroundBlendMode = `${themeStyles.textureBlendMode}, normal`;

              // Add animation class if enabled for supported textures
              const animatedTextures = ['smoke-flow', 'hologram-scan', 'energy-waves', 'water-ripple'];
              if (themeStyles.textureAnimated && animatedTextures.includes(themeStyles.textureStyle)) {
                  element.classList.add('mga-texture-animated');
              } else {
                  element.classList.remove('mga-texture-animated');
              }
          } else {
              element.style.background = themeStyles.background;
              element.style.backgroundBlendMode = '';
              element.classList.remove('mga-texture-animated');
          }
          element.style.boxShadow = themeStyles.boxShadow;
  
          if (opacity > 0.05) { // Lower threshold for backdrop filter
              // Scale blur intensity with opacity for better visual effect
              const blurIntensity = Math.max(2, Math.min(12, 12 * opacity));
              element.style.backdropFilter = `blur(${blurIntensity}px)`;
          } else {
              element.style.backdropFilter = 'none';
          }
  
          element.style.border = `1px solid rgba(255, 255, 255, ${Math.max(0.05, opacity * 0.15)})`;
  
          // Set theme-aware CSS custom properties for dynamic elements
          const effectiveOpacity = themeStyles.effectiveOpacity || opacity;
          const accentColor = getAccentColorForTheme(themeStyles.gradientStyle, effectiveOpacity);
  
          element.style.setProperty('--theme-accent-bg', accentColor.background);
          element.style.setProperty('--theme-accent-border', accentColor.border);
  
          // Apply dynamic scaling if this is an overlay
          if (element.classList.contains('mga-overlay') || element.id && element.id.includes('overlay')) {
              const width = element.offsetWidth || 400;
              const scale = calculateScale(width);
              element.style.setProperty('--panel-scale', scale);
          }
      }
  
      function calculateScale(width) {
          // Same scaling logic as the main panel
          let scale = 1;
          if (width < 350) {
              scale = 0.8;
          } else if (width < 450) {
              scale = 0.85;
          } else if (width < 550) {
              scale = 0.9;
          } else if (width < 650) {
              scale = 0.95;
          } else if (width >= 800) {
              scale = 1.05;
          }
          return scale;
      }
  
      function getAccentColorForTheme(gradientStyle, opacity) {
          // Define accent colors based on the current theme
          const accentColors = {
              'blue-purple': {
                  background: `linear-gradient(135deg, rgba(74, 158, 255, ${opacity * 0.1}) 0%, rgba(147, 51, 234, ${opacity * 0.1}) 100%)`,
                  border: `rgba(74, 158, 255, ${opacity * 0.3})`
              },
              'green-blue': {
                  background: `linear-gradient(135deg, rgba(34, 197, 94, ${opacity * 0.1}) 0%, rgba(59, 130, 246, ${opacity * 0.1}) 100%)`,
                  border: `rgba(34, 197, 94, ${opacity * 0.3})`
              },
              'red-orange': {
                  background: `linear-gradient(135deg, rgba(239, 68, 68, ${opacity * 0.1}) 0%, rgba(249, 115, 22, ${opacity * 0.1}) 100%)`,
                  border: `rgba(239, 68, 68, ${opacity * 0.3})`
              },
              'purple-pink': {
                  background: `linear-gradient(135deg, rgba(168, 85, 247, ${opacity * 0.1}) 0%, rgba(236, 72, 153, ${opacity * 0.1}) 100%)`,
                  border: `rgba(168, 85, 247, ${opacity * 0.3})`
              },
              'gold-yellow': {
                  background: `linear-gradient(135deg, rgba(255, 215, 0, ${opacity * 0.1}) 0%, rgba(245, 158, 11, ${opacity * 0.1}) 100%)`,
                  border: `rgba(255, 215, 0, ${opacity * 0.3})`
              },
              'steel-blue': {
                  background: `linear-gradient(135deg, rgba(30, 58, 138, ${opacity * 0.1}) 0%, rgba(51, 65, 85, ${opacity * 0.1}) 100%)`,
                  border: `rgba(30, 58, 138, ${opacity * 0.3})`
              },
              'chrome-silver': {
                  background: `linear-gradient(135deg, rgba(203, 213, 225, ${opacity * 0.1}) 0%, rgba(148, 163, 184, ${opacity * 0.1}) 100%)`,
                  border: `rgba(203, 213, 225, ${opacity * 0.3})`
              },
              'titanium-gray': {
                  background: `linear-gradient(135deg, rgba(107, 114, 128, ${opacity * 0.1}) 0%, rgba(156, 163, 175, ${opacity * 0.1}) 100%)`,
                  border: `rgba(107, 114, 128, ${opacity * 0.3})`
              },
              'electric-neon': {
                  background: `linear-gradient(135deg, rgba(0, 100, 255, ${opacity * 0.1}) 0%, rgba(147, 51, 234, ${opacity * 0.1}) 100%)`,
                  border: `rgba(0, 100, 255, ${opacity * 0.3})`
              },
              'rainbow-burst': {
                  background: `linear-gradient(135deg, rgba(239, 68, 68, ${opacity * 0.08}) 0%, rgba(245, 158, 11, ${opacity * 0.08}) 25%, rgba(34, 197, 94, ${opacity * 0.08}) 50%, rgba(59, 130, 246, ${opacity * 0.08}) 75%, rgba(147, 51, 234, ${opacity * 0.08}) 100%)`,
                  border: `rgba(147, 51, 234, ${opacity * 0.3})`
              }
          };
  
          return accentColors[gradientStyle] || accentColors['blue-purple'];
      }
  
      function syncThemeToAllWindows() {
          // Generate theme styles specifically for pop-out windows
          const popoutThemeStyles = generateThemeStyles(UnifiedState.data.settings, true);
          if (!popoutThemeStyles) return;
  
          // Update all in-game overlays with pop-out opacity
          UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
              if (overlay && document.contains(overlay)) {
                  applyThemeToElement(overlay, popoutThemeStyles);
              }
          });
  
          // Update all shift+click popout widgets
          UnifiedState.data.popouts.widgets.forEach((widget, tabName) => {
              if (widget && document.contains(widget)) {
                  applyThemeToPopoutWidget(widget, popoutThemeStyles);
              }
          });
  
          // For pop-out windows, we'll implement a refresh system since we can't directly
          // communicate with them across window contexts. This is a limitation of
          // separate windows, but the themes will be applied when they're opened.
  
          // Store theme update timestamp for future reference
          UnifiedState.data.lastThemeUpdate = Date.now();
      }
  
      // Enhanced function to ensure themes are always current
      function ensureThemeConsistency() {
          // Apply theme to main panel if it exists but doesn't have the current theme
          const panel = UnifiedState.panels.main;
          if (panel) {
              const currentTheme = UnifiedState.currentTheme || generateThemeStyles();
              if (!UnifiedState.currentTheme) {
                  UnifiedState.currentTheme = currentTheme;
              }
              applyThemeToElement(panel, currentTheme);
          }
  
          // Update all overlays
          syncThemeToAllWindows();
      }
  
      // Enhanced modal spam prevention with debouncing and queue system
      function setupModalSpamPrevention() {
          // Add modal spam protection to settings
          if (!UnifiedState.data.settings.modalSpamProtection) {
              UnifiedState.data.settings.modalSpamProtection = {
                  enabled: true,
                  cooldownMs: 500,
                  queueLimit: 3,
                  lastModalTime: 0,
                  modalQueue: []
              };
          }
  
          const modalSettings = UnifiedState.data.settings.modalSpamProtection;
  
          // Note: Console.log filtering removed - cannot intercept logs from other userscripts (MGC)
          // MGC spam is from separate userscript and must be filtered at browser console level if needed
  
          // Enhanced modal prevention with debouncing
          const originalAlert = window.alert;
          const originalConfirm = window.confirm;
  
          window.alert = function(message) {
              if (!modalSettings.enabled) return originalAlert.call(window, message);
  
              const now = Date.now();
              if (now - modalSettings.lastModalTime < modalSettings.cooldownMs) {
                  debugLog('MODAL_SPAM', 'Alert blocked due to cooldown', { message: message.substring(0, 50) });
                  return;
              }
  
              modalSettings.lastModalTime = now;
              return originalAlert.call(window, message);
          };
  
          window.confirm = function(message) {
              if (!modalSettings.enabled) return originalConfirm.call(window, message);
  
              const now = Date.now();
              if (now - modalSettings.lastModalTime < modalSettings.cooldownMs) {
                  debugLog('MODAL_SPAM', 'Confirm blocked due to cooldown', { message: message.substring(0, 50) });
                  return false; // Default to false for safety
              }
  
              modalSettings.lastModalTime = now;
              return originalConfirm.call(window, message);
          };
  
          // Prevent multiple overlapping modal dialogs
          let activeModalCount = 0;
          const originalCreateElement = targetDocument.createElement;
          targetDocument.createElement = function(tagName) {
              const element = originalCreateElement.call(document, tagName);
  
              if (tagName.toLowerCase() === 'dialog' ||
                  (element.className && element.className.includes('modal'))) {
  
                  if (activeModalCount >= modalSettings.queueLimit) {
                      debugLog('MODAL_SPAM', 'Modal blocked due to queue limit');
                      return element; // Return but don't increment count
                  }
  
                  activeModalCount++;
  
                  // Auto-cleanup modal count after 5 seconds
                  setTimeout(() => {
                      if (activeModalCount > 0) activeModalCount--;
                  }, 5000);
              }
  
              return element;
          };
  
          debugLog('MODAL_SPAM', 'Enhanced modal spam prevention initialized', {
              cooldownMs: modalSettings.cooldownMs,
              queueLimit: modalSettings.queueLimit
          });
      }
  
      function applyTheme() {
          const themeStyles = generateThemeStyles();
  
          // Store current theme for cross-window synchronization
          UnifiedState.currentTheme = themeStyles;
  
          // Apply to main panel if it exists (Alt+key overlay windows)
          const panel = UnifiedState.panels.main;
          if (panel) {
              applyThemeToElement(panel, themeStyles);
          }
  
          // Apply theme colors to dock and sidebar for all themes
          const isBlackTheme = themeStyles.gradientStyle && themeStyles.gradientStyle.startsWith('black-');
          if (isBlackTheme && themeStyles.accentColor) {
              // Black themes get special accent styling
              applyAccentToDock(themeStyles);
              applyAccentToSidebar(themeStyles);
          } else {
              // Non-black themes get their gradient applied
              applyThemeToDock(themeStyles);
              applyThemeToSidebar(themeStyles);
          }
  
          // Update all existing overlays and pop-out windows
          syncThemeToAllWindows();
      }
  
      function applyThemeToDock(themeStyles) {
          const dock = document.querySelector('#mgh-dock');
          if (!dock) return;
  
          // Apply theme background, border, and effects to dock
          dock.style.background = themeStyles.background;
          dock.style.border = `1px solid rgba(255, 255, 255, ${themeStyles.opacity / 100 * 0.15})`;
          dock.style.boxShadow = themeStyles.boxShadow;
          dock.style.backdropFilter = 'blur(20px)';
      }
  
      function applyAccentToDock(themeStyles) {
          const dock = document.querySelector('#mgh-dock');
          if (!dock) return;
  
          // Apply solid black background with accent border and glow
          dock.style.background = 'rgba(0, 0, 0, 0.95)';
          dock.style.border = `1px solid ${themeStyles.accentColor}`;
  
          // Combine base shadow with accent glow - enhanced by effect style
          let accentShadow = `0 8px 24px rgba(0, 0, 0, 0.8), 0 0 20px ${themeStyles.accentGlow}`;
  
          // Add effect-specific enhancements to the accent glow
          if (themeStyles.effectStyle === 'neon' || themeStyles.effectStyle === 'plasma') {
              accentShadow += `, 0 0 40px ${themeStyles.accentGlow}`;
          } else if (themeStyles.effectStyle === 'metallic' || themeStyles.effectStyle === 'steel') {
              accentShadow += `, inset 0 1px 0 rgba(255, 255, 255, 0.57)`;
          } else if (themeStyles.effectStyle === 'crystal' || themeStyles.effectStyle === 'glass') {
              accentShadow += `, 0 0 30px ${themeStyles.accentGlow}, inset 0 1px 0 rgba(255, 255, 255, 0.73)`;
          }
  
          dock.style.boxShadow = accentShadow;
          dock.style.backdropFilter = 'blur(20px)';
  
          // Use CSS variables for hover effects (better performance)
          dock.style.setProperty('--accent-color', themeStyles.accentColor);
          dock.style.setProperty('--accent-glow', themeStyles.accentGlow);
      }
  
      function applyThemeToSidebar(themeStyles) {
          const sidebar = document.querySelector('#mgh-sidebar');
          if (!sidebar) return;
  
          // Apply theme background with textures, border, and effects to sidebar
          if (themeStyles.texturePattern) {
              sidebar.style.background = `${themeStyles.texturePattern}, ${themeStyles.background}`;
              sidebar.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
          } else {
              sidebar.style.background = themeStyles.background;
          }
          sidebar.style.borderRight = `1px solid rgba(255, 255, 255, ${themeStyles.opacity / 100 * 0.15})`;
          sidebar.style.boxShadow = `4px 0 24px rgba(0, 0, 0, 0.6), ${themeStyles.boxShadow}`;
          sidebar.style.backdropFilter = 'blur(20px)';
  
          // Style sidebar header with textures
          const header = sidebar.querySelector('.mgh-sidebar-header');
          if (header) {
              if (themeStyles.texturePattern) {
                  header.style.background = `${themeStyles.texturePattern}, ${themeStyles.background}`;
                  header.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
              } else {
                  header.style.background = themeStyles.background;
              }
              header.style.borderBottom = `1px solid rgba(255, 255, 255, ${themeStyles.opacity / 100 * 0.2})`;
          }
  
          // Remove accent-specific CSS if it exists
          const existingStyle = document.getElementById('accent-theme-styles');
          if (existingStyle) existingStyle.remove();
      }
  
      function applyAccentToSidebar(themeStyles) {
          const sidebar = document.querySelector('#mgh-sidebar');
          if (!sidebar) return;
  
          // Apply solid black background with subtle accent tint and textures
          const accentGradient = `linear-gradient(180deg, #000000 0%, ${themeStyles.accentColor}11 50%, #000000 100%)`;
          if (themeStyles.texturePattern) {
              sidebar.style.background = `${themeStyles.texturePattern}, ${accentGradient}`;
              sidebar.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
          } else {
              sidebar.style.background = accentGradient;
          }
          sidebar.style.borderRight = `2px solid ${themeStyles.accentColor}`;
          sidebar.style.backdropFilter = 'blur(20px)';
  
          // Enhanced shadow with effect-specific styling
          let sidebarShadow = `4px 0 24px rgba(0, 0, 0, 0.6), 0 0 20px ${themeStyles.accentGlow}`;
  
          // Add effect-specific enhancements
          if (themeStyles.effectStyle === 'neon' || themeStyles.effectStyle === 'plasma') {
              sidebarShadow += `, 0 0 40px ${themeStyles.accentGlow}`;
          } else if (themeStyles.effectStyle === 'crystal' || themeStyles.effectStyle === 'glass') {
              sidebarShadow += `, inset 0 1px 0 rgba(255, 255, 255, 0.57)`;
          }
  
          sidebar.style.boxShadow = sidebarShadow;
  
          // Style sidebar header with accent gradient
          const header = sidebar.querySelector('.mgh-sidebar-header');
          if (header) {
              header.style.background = `linear-gradient(90deg, #000000 0%, ${themeStyles.accentColor} 100%)`;
              header.style.borderBottom = `2px solid ${themeStyles.accentColor}`;
  
              // Enhanced header glow based on effect
              let headerGlow = `0 2px 20px ${themeStyles.accentGlow}`;
              if (themeStyles.effectStyle === 'neon' || themeStyles.effectStyle === 'plasma') {
                  headerGlow += `, 0 0 30px ${themeStyles.accentGlow}`;
              }
              header.style.boxShadow = headerGlow;
          }
  
          // Use CSS variables for dynamic styling (better performance than event listeners)
          sidebar.style.setProperty('--accent-color', themeStyles.accentColor);
          sidebar.style.setProperty('--accent-glow', themeStyles.accentGlow);
  
          // Inject dynamic CSS for hover effects and other elements
          const style = document.createElement('style');
          style.id = 'accent-theme-styles';
          const existingStyle = document.getElementById('accent-theme-styles');
          if (existingStyle) existingStyle.remove();
  
          style.textContent = `
              /* Sidebar sections - ONLY MGTools elements */
              #mgh-sidebar .mga-section {
                  background: ${themeStyles.accentColor}05;
                  border: 1px solid ${themeStyles.accentColor}33;
              }
  
              /* Buttons - ONLY in sidebar */
              #mgh-sidebar button.mga-button,
              #mgh-sidebar button.mga-btn {
                  background: linear-gradient(135deg, ${themeStyles.accentColor}AA, ${themeStyles.accentColor});
                  border: 1px solid ${themeStyles.accentColor};
              }
              #mgh-sidebar button.mga-button:hover,
              #mgh-sidebar button.mga-btn:hover {
                  background: linear-gradient(135deg, ${themeStyles.accentColor}, ${themeStyles.accentColor}FF);
                  box-shadow: 0 0 15px ${themeStyles.accentGlow};
              }
  
              /* Inputs - ONLY mga-prefixed classes */
              #mgh-sidebar input.mga-slider,
              #mgh-sidebar select.mga-select,
              #mgh-sidebar textarea.mga-textarea {
                  border-color: ${themeStyles.accentColor}66;
              }
              #mgh-sidebar input.mga-slider:focus,
              #mgh-sidebar select.mga-select:focus,
              #mgh-sidebar textarea.mga-textarea:focus {
                  border-color: ${themeStyles.accentColor};
                  box-shadow: 0 0 10px ${themeStyles.accentGlow};
              }
  
              /* Scrollbar - ONLY sidebar scrollbar */
              #mgh-sidebar .mgh-sidebar-body::-webkit-scrollbar-thumb {
                  background: linear-gradient(180deg, ${themeStyles.accentColor}, ${themeStyles.accentColor}AA);
              }
              #mgh-sidebar .mgh-sidebar-body::-webkit-scrollbar-thumb:hover {
                  background: ${themeStyles.accentColor};
              }
          `;
          document.head.appendChild(style);
      }
  
      function applyThemeToPopoutWidget(popout, themeStyles) {
          if (!popout || !themeStyles) return;
  
          const isBlackTheme = themeStyles.gradientStyle && themeStyles.gradientStyle.startsWith('black-');
  
          if (isBlackTheme && themeStyles.accentColor) {
              // Black themes: solid black with vibrant accents and textures
              if (themeStyles.texturePattern) {
                  popout.style.background = `${themeStyles.texturePattern}, rgba(0, 0, 0, 0.95)`;
                  popout.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
              } else {
                  popout.style.background = 'rgba(0, 0, 0, 0.95)';
              }
              popout.style.border = `1px solid ${themeStyles.accentColor}`;
  
              // Enhanced shadow with effect-specific styling
              let shadow = `0 8px 32px rgba(0, 0, 0, 0.6), 0 0 20px ${themeStyles.accentGlow}`;
  
              // Add effect-specific enhancements
              if (themeStyles.effectStyle === 'neon' || themeStyles.effectStyle === 'plasma') {
                  shadow += `, 0 0 40px ${themeStyles.accentGlow}`;
              } else if (themeStyles.effectStyle === 'metallic' || themeStyles.effectStyle === 'steel') {
                  shadow += `, inset 0 1px 0 rgba(255, 255, 255, 0.57)`;
              } else if (themeStyles.effectStyle === 'crystal' || themeStyles.effectStyle === 'glass') {
                  shadow += `, 0 0 30px ${themeStyles.accentGlow}, inset 0 1px 0 rgba(255, 255, 255, 0.73)`;
              }
  
              popout.style.boxShadow = shadow;
  
              // Style header with accent gradient
              const header = popout.querySelector('.mgh-popout-header');
              if (header) {
                  header.style.background = `linear-gradient(90deg, #000000 0%, ${themeStyles.accentColor} 100%)`;
                  header.style.borderBottom = `1px solid ${themeStyles.accentColor}`;
  
                  // Enhanced header glow based on effect
                  let headerGlow = `0 2px 20px ${themeStyles.accentGlow}`;
                  if (themeStyles.effectStyle === 'neon' || themeStyles.effectStyle === 'plasma') {
                      headerGlow += `, 0 0 30px ${themeStyles.accentGlow}`;
                  }
                  header.style.boxShadow = headerGlow;
              }
  
              // Keep body background solid for content readability, with textures
              const body = popout.querySelector('.mgh-popout-body');
              if (body) {
                  if (themeStyles.texturePattern) {
                      body.style.background = `${themeStyles.texturePattern}, #000000`;
                      body.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
                  } else {
                      body.style.background = '#000000'; // Solid black for black themes
                  }
              }
          } else {
              // Regular themes: use gradient background with textures
              if (themeStyles.texturePattern) {
                  popout.style.background = `${themeStyles.texturePattern}, ${themeStyles.background}`;
                  popout.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
              } else {
                  popout.style.background = themeStyles.background;
              }
              popout.style.border = `1px solid rgba(255, 255, 255, ${themeStyles.opacity / 100 * 0.15})`;
              popout.style.boxShadow = themeStyles.boxShadow;
  
              // Style header
              const header = popout.querySelector('.mgh-popout-header');
              if (header) {
                  if (themeStyles.texturePattern) {
                      header.style.background = `${themeStyles.texturePattern}, ${themeStyles.background}`;
                      header.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
                  } else {
                      header.style.background = themeStyles.background;
                  }
                  header.style.borderBottom = `1px solid rgba(255, 255, 255, ${themeStyles.opacity / 100 * 0.2})`;
              }
  
              // Keep body background solid for content readability
              const body = popout.querySelector('.mgh-popout-body');
              if (body) {
                  if (themeStyles.texturePattern) {
                      body.style.background = `${themeStyles.texturePattern}, ${themeStyles.background}`;
                      body.style.backgroundSize = `${themeStyles.textureBackgroundSize}, cover`;
                  } else {
                      body.style.background = themeStyles.background; // Match theme gradient
                  }
              }
          }
  
          popout.style.backdropFilter = 'blur(20px)';
      }
  
      function applyUltraCompactMode(enabled) {
          const panel = UnifiedState.panels.main;
          if (!panel) return;
  
          if (enabled) {
              // Apply ultra-compact styles
              panel.style.cssText += `
                  --mga-font-size: 11px;
                  --mga-section-padding: 6px;
                  --mga-header-padding: 8px 12px;
                  --mga-button-padding: 4px 8px;
                  --mga-input-padding: 4px 6px;
                  --mga-tab-height: 32px;
                  --mga-spacing: 4px;
                  min-width: 250px;
                  font-size: 11px;
              `;
  
              // Add ultra-compact class for specific styling
              panel.classList.add('mga-ultra-compact');
  
              // Reduce overall panel size
              const currentWidth = parseInt(panel.style.width) || 800;
              const currentHeight = parseInt(panel.style.height) || 600;
              panel.style.width = Math.max(250, currentWidth * 0.7) + 'px';
              panel.style.height = Math.max(300, currentHeight * 0.8) + 'px';
  
          } else {
              // Remove ultra-compact styles
              panel.classList.remove('mga-ultra-compact');
  
              // Restore normal CSS variables
              panel.style.cssText = panel.style.cssText.replace(/--mga-[^;]+;/g, '');
  
              // Restore normal size - remove restrictions
              panel.style.minWidth = '250px';
              panel.style.maxWidth = '';
              panel.style.fontSize = '13px';
          }
  
          // Force re-render of current tab to apply new styles
          if (UnifiedState.activeTab) {
              updateTabContent();
          }
  
          productionLog(`üì± Ultra-compact mode ${enabled ? 'applied' : 'removed'}`);
      }
  
      // Cache for scale calculations
      const scaleCache = new Map();
  
      function applyDynamicScaling(element, width) {
          // Don't override ultra-compact mode
          if (element.classList.contains('mga-ultra-compact')) {
              return;
          }
  
          // Use cached scale if available for this width range
          const widthRange = Math.floor(width / 50) * 50; // Round to nearest 50px
          let scale = scaleCache.get(widthRange);
  
          if (scale === undefined) {
              // Calculate scale only once per range
              scale = 1;
              if (width < 350) {
                  scale = 0.8;
              } else if (width < 450) {
                  scale = 0.85;
              } else if (width < 550) {
                  scale = 0.9;
              } else if (width < 650) {
                  scale = 0.95;
              } else if (width >= 800) {
                  scale = 1.05;
              }
              scaleCache.set(widthRange, scale);
          }
  
          // Only update if scale changed (avoid string conversion cost)
          const elementId = element.id || 'default';
          const lastScale = element._lastScale;
          if (lastScale !== scale) {
              element._lastScale = scale;
              element.style.setProperty('--panel-scale', scale);
          }
      }
  
      function updateTabResponsiveness(element) {
          // This function was causing tabs to lose their popout buttons and text to truncate
          // Now we use horizontal scrolling with navigation arrows instead
          // Just handle scrolling the active tab into view if needed
          const tabs = element.querySelectorAll('.mga-tab');
          const tabsContainer = element.querySelector('.mga-tabs');
  
          if (!tabsContainer || tabs.length === 0) return;
  
          // Ensure active tab is visible by scrolling if necessary
          const activeTab = element.querySelector('.mga-tab.active');
          if (activeTab && tabsContainer.scrollWidth > tabsContainer.clientWidth) {
              const tabRect = activeTab.getBoundingClientRect();
              const containerRect = tabsContainer.getBoundingClientRect();
  
              if (tabRect.right > containerRect.right) {
                  tabsContainer.scrollLeft += (tabRect.right - containerRect.right) + 10;
              } else if (tabRect.left < containerRect.left) {
                  tabsContainer.scrollLeft -= (containerRect.left - tabRect.left) + 10;
              }
          }
      }
  
      // ==================== ABILITY MONITORING ====================
      // OPTIMIZED: Batch DOM updates and only update when necessary
      let pendingAbilityUpdates = false;
  
      // Helper function to get crop info from garden (only if unambiguous)
      function getGardenCropIfUnique() {
          const tileObjects = window.gardenInfo?.garden?.tileObjects;
          if (!tileObjects) return null;
  
          // Count unique species (only plants, not empty tiles)
          const speciesSet = new Set();
          const tiles = Object.values(tileObjects);
  
          tiles.forEach(tile => {
              if (tile?.species && tile.objectType === 'plant') {
                  speciesSet.add(tile.species);
              }
          });
  
          // Only return if there's exactly ONE unique species (unambiguous)
          // If multiple crops, we can't know which one was affected
          if (speciesSet.size === 1) {
              return Array.from(speciesSet)[0];
          }
  
          return null; // Multiple crops or no crops - can't determine accurately
      }
  
      function monitorPetAbilities() {
          if (!UnifiedState.atoms.petAbility || !UnifiedState.atoms.activePets) return;
  
          let hasNewAbility = false;
  
          UnifiedState.atoms.activePets.forEach((pet, index) => {
              if (!pet || !pet.id) return;
  
              const abilityData = UnifiedState.atoms.petAbility[pet.id];
              if (!abilityData || !abilityData.lastAbilityTrigger) return;
  
              const trigger = abilityData.lastAbilityTrigger;
              const currentTimestamp = trigger.performedAt;
  
              // BUGFIX v1.11.4: Skip logging if pet is unfed (hunger = 0)
              // Game shows "feed your pet" notification but creates empty trigger
              if (!currentTimestamp || pet.hunger === 0) {
                  productionLog(`üö´ [ABILITY-SKIP] Pet ${pet.petSpecies} unfed (hunger: ${pet.hunger}) - skipping ability log`);
                  return;
              }
  
              // BUGFIX v1.11.4: Additional validation - skip if trigger has no valid ability ID
              // This prevents fake ability logs from unfed pet notifications
              if (!trigger.abilityId || trigger.abilityId === 'Unknown' || trigger.abilityId === '') {
                  productionLog(`üö´ [ABILITY-SKIP] Invalid ability ID for ${pet.petSpecies} - likely unfed pet notification`);
                  return;
              }
  
              // Check if this is a new trigger - use UnifiedState instead of window variables
              if (!UnifiedState.data.lastAbilityTimestamps) {
                  UnifiedState.data.lastAbilityTimestamps = {};
              }
  
              const lastKnown = UnifiedState.data.lastAbilityTimestamps[pet.id];
  
              // Exact match - definitely already logged
              if (lastKnown === currentTimestamp) {
                  return;
              }
  
              // Additional validation: If timestamp is very recent (within 10 seconds), skip
              // This prevents false triggers on page refresh when same ability state reloads
              if (lastKnown && Math.abs(currentTimestamp - lastKnown) < 10000) {
                  if (UnifiedState.data.settings?.debugMode) {
                      productionLog(`üö´ [ABILITY-SKIP] ${pet.petSpecies} - Timestamp too close to last (${Math.abs(currentTimestamp - lastKnown)}ms)`);
                  }
                  return;
              }
  
              // Check if this exact log already exists in recent entries (prevents race condition duplicates)
              const isDuplicate = UnifiedState.data.petAbilityLogs
                  .slice(0, 10)
                  .some(log => log.timestamp === currentTimestamp && log.petName && log.petName.includes(pet.petSpecies));
  
              if (isDuplicate) {
                  if (UnifiedState.data.settings?.debugMode) {
                      productionLog(`üö´ [ABILITY-SKIP] ${pet.petSpecies} - Already in recent logs (duplicate prevention)`);
                  }
                  return;
              }
  
              UnifiedState.data.lastAbilityTimestamps[pet.id] = currentTimestamp;
              hasNewAbility = true;
  
              // Save ability timestamps to prevent duplicate logging after refresh
              MGA_debouncedSave('MGA_lastAbilityTimestamps', UnifiedState.data.lastAbilityTimestamps);
  
              // BUGFIX: Enrich ability data with crop info if missing (only when unambiguous)
              let enrichedData = trigger.data ? { ...trigger.data } : {};
  
              // For granter abilities (Gold/Rainbow), try to add crop name if missing
              const abilityId = trigger.abilityId || '';
              if (abilityId.includes('Granter') && !enrichedData.cropName) {
                  // Strategy 1: Check currentCrop (works for single-crop users)
                  const currentCrop = window.currentCrop || UnifiedState.atoms.currentCrop;
                  if (currentCrop && currentCrop[0]?.species) {
                      enrichedData.cropName = currentCrop[0].species;
                  } else {
                      // Strategy 2: Check garden tiles (only if exactly ONE crop type exists)
                      // This prevents showing wrong crop when multiple crop types are growing
                      const uniqueCrop = getGardenCropIfUnique();
                      if (uniqueCrop) {
                          enrichedData.cropName = uniqueCrop;
                      }
                      // Otherwise: No crop name added (honest about uncertainty)
                  }
              }
  
              // Create display name with custom name if available
              let displayName = pet.petSpecies || `Pet ${index + 1}`;
              if (pet.name && pet.name !== pet.petSpecies) {
                  // Show as "CustomName (Species)"
                  displayName = `${pet.name} (${pet.petSpecies || 'Pet'})`;
              }
  
              // Normalize ability name to fix potential typos (e.g., "Seed FinderII" ‚Üí "Seed Finder II")
              const rawAbilityType = trigger.abilityId || 'Unknown Ability';
              const normalizedAbilityType = normalizeAbilityName(rawAbilityType);
  
              const abilityLog = {
                  petName: displayName,
                  abilityType: normalizedAbilityType,
                  timestamp: currentTimestamp,
                  timeString: formatTimestamp(currentTimestamp),
                  data: Object.keys(enrichedData).length > 0 ? enrichedData : null
              };
  
              logDebug('ABILITY-LOGS', 'Adding NEW ability log:', {
                  ability: abilityLog.abilityType,
                  pet: abilityLog.petName,
                  time: abilityLog.timeString,
                  currentLogCount: UnifiedState.data.petAbilityLogs.length
              });
  
              UnifiedState.data.petAbilityLogs.unshift(abilityLog);
  
              // Apply memory management to keep recent logs in memory, archive older ones
              UnifiedState.data.petAbilityLogs = MGA_manageLogMemory(UnifiedState.data.petAbilityLogs);
  
              // Use debounced save to reduce I/O operations during frequent ability triggers
              // Only save if not in clear session
              const clearSession = localStorage.getItem('MGA_logs_clear_session');
              if (!clearSession || (Date.now() - parseInt(clearSession, 10)) > 86400000) {
                  MGA_debouncedSave('MGA_petAbilityLogs', UnifiedState.data.petAbilityLogs);
              } else {
                  logDebug('ABILITY-LOGS', '‚è∏Ô∏è Skipping save - clear session active');
              }
  
              // Check if we should notify for this ability
              if (UnifiedState.data.settings.notifications.abilityNotificationsEnabled) {
                  const abilityType = trigger.abilityId || '';
  
                  // Filter out ProduceMutationBoost/PetMutationBoost - these are passive and shouldn't trigger notifications
                  if (abilityType && (
                      abilityType.includes('ProduceMutationBoost') ||
                      abilityType.includes('PetMutationBoost')
                  )) {
                      return; // Skip notification for mutation boosts
                  }
  
                  // Check individual abilities list
                  const watchedAbilities = UnifiedState.data.settings.notifications.watchedAbilities || [];
  
                  // Logic:
                  // - Empty array = all abilities enabled (default/backward compatible)
                  // - ['__NONE__'] = no abilities enabled (user clicked "Select None")
                  // - [...abilities] = only those specific abilities enabled
                  let shouldNotify = false;
  
                  if (watchedAbilities.length === 0) {
                      // Empty array means all abilities
                      shouldNotify = true;
                  } else if (watchedAbilities.includes('__NONE__')) {
                      // Special marker means none
                      shouldNotify = false;
                  } else {
                      // Check if this specific ability is in the list
                      shouldNotify = watchedAbilities.includes(abilityType);
                  }
  
                  if (shouldNotify) {
                      const displayAbilityName = normalizeAbilityName(abilityType);
                      productionLog(`üéØ [ABILITY-NOTIFY] ${abilityLog.petName} triggered ${displayAbilityName}`);
  
                      // Play ability notification sound based on settings
                      const abilityVolume = UnifiedState.data.settings.notifications.abilityNotificationVolume || 0.2;
                      const abilitySound = UnifiedState.data.settings.notifications.abilityNotificationSound || 'single';
  
                      switch (abilitySound) {
                          case 'single':
                              playSingleBeepNotification(abilityVolume);
                              break;
                          case 'double':
                              playDoubleBeepNotification(abilityVolume);
                              break;
                          case 'triple':
                              playTripleBeepNotification(abilityVolume);
                              break;
                          case 'chime':
                              playChimeNotification(abilityVolume);
                              break;
                          case 'alert':
                              playAlertNotification(abilityVolume);
                              break;
                          case 'buzz':
                              playBuzzNotification(abilityVolume);
                              break;
                          case 'ding':
                              playDingNotification(abilityVolume);
                              break;
                          case 'chirp':
                              playChirpNotification(abilityVolume);
                              break;
                          default:
                              playSingleBeepNotification(abilityVolume);
                      }
  
                      // Show toast
                      showNotificationToast(`‚ú® ${abilityLog.petName}: ${displayAbilityName}`, 'success');
                  }
              }
          });
  
          // OPTIMIZED: Only update DOM if there's actually a new ability and page is visible
          if (hasNewAbility && document.visibilityState === 'visible' && !pendingAbilityUpdates) {
              pendingAbilityUpdates = true;
              // Batch all DOM updates in next animation frame
              requestAnimationFrame(() => {
                  updateAllAbilityLogDisplays();
  
                  if (UnifiedState.activeTab === 'abilities') {
                      updateTabContent();
                  }
  
                  // BUGFIX: Removed duplicate overlay update loop
                  // updateAllAbilityLogDisplays() already handles all overlays at line 13548
                  // Duplicate updates were causing race conditions when both tab and pop-up were open
  
                  pendingAbilityUpdates = false;
              });
          }
      }
  
      function exportAbilityLogs() {
          const allLogs = MGA_getAllLogs();
          if (!allLogs.length) {
              productionWarn('‚ö†Ô∏è No logs to export!');
              return;
          }
  
          const headers = 'Date,Time,Pet Name,Ability Type,Details\r\n';
          const csvContent = allLogs.map(log => {
              const date = new Date(log.timestamp);
              return [
                  date.toLocaleDateString(),
                  date.toLocaleTimeString(),
                  log.petName,
                  normalizeAbilityName(log.abilityType),
                  JSON.stringify(log.data || '')
              ].map(field => `"${String(field).replace(/"/g, '""')}"`).join(',');
          }).join('\r\n');
  
          const blob = new Blob([headers + csvContent], { type: 'text/csv;charset=utf-8;' });
          const link = targetDocument.createElement('a');
          link.href = URL.createObjectURL(blob);
          link.download = `MagicGarden_AbilityLogs_${new Date().toISOString().split('T')[0]}.csv`;
          link.click();
      }
  
      // ==================== VALUE CALCULATIONS ====================
      const speciesValues = {
          Sunflower: 750000,
          Starweaver: 10000000,
          DawnCelestial: 11000000,
          MoonCelestial: 11000000,
          Lychee: 50000,
          DragonFruit: 24500,
          PassionFruit: 24500,
          Lemon: 10000,
          Pepper: 7220,
          Grape: 7085,
          Bamboo: 500000,
          Cactus: 287000,
          Mushroom: 160000,
          BurrosTail: 6000,
          Lily: 20123,
          Banana: 1750,
          Coconut: 302,
          Echeveria: 5520,
          Pumpkin: 3700,
          Watermelon: 2708,
          Corn: 36,
          Daffodil: 1090,
          Tomato: 27,
          OrangeTulip: 767,
          Apple: 73,
          Blueberry: 23,
          Aloe: 310,
          Strawberry: 14,
          Carrot: 20
      };
  
      // Mutation calculation matching FriendsScript logic
      const COLOR_MULT = {
          Gold: 25,
          Rainbow: 50
      };
  
      const WEATHER_MULT = {
          Wet: 2,
          Chilled: 2,
          Frozen: 10
      };
  
      const TIME_MULT = {
          Dawnlit: 2,
          Dawnbound: 3,
          Dawncharged: 3,  // Same as Dawnbound
          Amberlit: 5,
          Ambershine: 5,  // Internal game name for Amberlit
          Amberbound: 6,
          Ambercharged: 6  // Same as Amberbound
      };

      const WEATHER_TIME_COMBO = {
          "Wet+Dawnlit": 3,
          "Chilled+Dawnlit": 3,
          "Wet+Amberlit": 6,
          "Chilled+Amberlit": 6,
          "Wet+Ambershine": 6,  // Internal game name for Amberlit
          "Chilled+Ambershine": 6,  // Internal game name for Amberlit
          "Frozen+Dawnlit": 11,
          "Frozen+Dawnbound": 12,
          "Frozen+Dawncharged": 12,  // Same as Dawnbound
          "Frozen+Amberlit": 14,
          "Frozen+Ambershine": 14,  // Internal game name for Amberlit
          "Frozen+Amberbound": 15,
          "Frozen+Ambercharged": 15  // Same as Amberbound
      };
  
      function calculateMutationMultiplier(mutations) {
          if (!mutations || !Array.isArray(mutations)) return 1;
  
          // Pick best color multiplier
          let color = 1;
          for (const m of mutations) {
              if (m === "Rainbow" && COLOR_MULT.Rainbow > color) color = COLOR_MULT.Rainbow;
              if (m === "Gold" && COLOR_MULT.Gold > color) color = COLOR_MULT.Gold;
          }
  
          // Pick best weather
          let weather = null;
          for (const m of mutations) {
              if (WEATHER_MULT[m]) {
                  if (!weather || WEATHER_MULT[m] > WEATHER_MULT[weather]) {
                      weather = m;
                  }
              }
          }
  
          // Pick best time
          let time = null;
          for (const m of mutations) {
              if (TIME_MULT[m]) {
                  if (!time || TIME_MULT[m] > TIME_MULT[time]) {
                      time = m;
                  }
              }
          }
  
          // Calculate weather+time multiplier
          let wt = 1;
          if (!weather && !time) wt = 1;
          else if (weather && !time) wt = WEATHER_MULT[weather];
          else if (!weather && time) wt = TIME_MULT[time];
          else {
              const combo = `${weather}+${time}`;
              wt = WEATHER_TIME_COMBO[combo] || Math.max(WEATHER_MULT[weather], TIME_MULT[time]);
          }
  
          return Math.round(color * wt);
      }
  
      // ==================== ENHANCED VALUE MANAGER ====================
      class ValueManager {
          constructor() {
              this.cache = {
                  inventoryValue: { value: 0, lastUpdate: 0 },
                  tileValue: { value: 0, lastUpdate: 0 },
                  gardenValue: { value: 0, lastUpdate: 0 }
              };
              this.throttleMs = 100; // 100ms throttle for value calculations
              this.retryAttempts = 3;
              this.observer = null;
  
              this.initializeObserver();
              debugLog('VALUE_MANAGER', 'ValueManager initialized', { throttleMs: this.throttleMs });
          }
  
          initializeObserver() {
              // Create MutationObserver to detect game state changes
              if (typeof MutationObserver !== 'undefined') {
                  this.observer = new MutationObserver((mutations) => {
                      let shouldUpdate = false;
                      mutations.forEach(mutation => {
                          // Check if changes are related to inventory or game state
                          if (mutation.target.className &&
                              (mutation.target.className.includes('inventory') ||
                               mutation.target.className.includes('garden') ||
                               mutation.target.className.includes('crop'))) {
                              shouldUpdate = true;
                          }
                      });
  
                      if (shouldUpdate) {
                          this.invalidateCache();
                          debugLog('VALUE_MANAGER', 'Game state change detected, invalidating cache');
                      }
                  });
  
                  // Observe body for any game-related changes
                  this.observer.observe(targetDocument.body, {
                      childList: true,
                      subtree: true,
                      attributes: true,
                      attributeFilter: ['class', 'data-value']
                  });
              }
          }
  
          getTileValue(forceRefresh = false) {
              return this.getCachedValue('tileValue', forceRefresh, () => this.calculateTileValue());
          }
  
          getInventoryValue(forceRefresh = false) {
              return this.getCachedValue('inventoryValue', forceRefresh, () => this.calculateInventoryValue());
          }
  
          getGardenValue(forceRefresh = false) {
              return this.getCachedValue('gardenValue', forceRefresh, () => this.calculateGardenValue());
          }
  
          getCachedValue(type, forceRefresh, calculator) {
              const cached = this.cache[type];
              const now = Date.now();
  
              if (!forceRefresh && cached && (now - cached.lastUpdate) < this.throttleMs) {
                  return cached.value;
              }
  
              // Calculate new value with retry mechanism
              let attempts = 0;
              let value = 0;
  
              while (attempts < this.retryAttempts) {
                  try {
                      value = calculator();
                      break;
                  } catch (error) {
                      attempts++;
                      debugError('VALUE_MANAGER', `Calculation failed for ${type}, attempt ${attempts}`, error);
  
                      if (attempts >= this.retryAttempts) {
                          // Use cached value if all retries fail
                          value = cached ? cached.value : 0;
                          debugLog('VALUE_MANAGER', `Using cached value for ${type} after ${attempts} failures`);
                      } else {
                          // Brief delay before retry
                          setTimeout(() => {}, 10 * attempts);
                      }
                  }
              }
  
              // Update cache
              this.cache[type] = {
                  value,
                  lastUpdate: now
              };
  
              return value;
          }
  
          calculateTileValue() {
              const currentCrop = UnifiedState.atoms.currentCrop;
              const friendBonus = UnifiedState.atoms.friendBonus || 1;
              let tileValue = 0;
  
              if (currentCrop && currentCrop.length) {
                  currentCrop.forEach(slot => {
                      if (slot && slot.species) {
                          const multiplier = calculateMutationMultiplier(slot.mutations);
                          const speciesVal = speciesValues[slot.species] || 0;
                          const scale = slot.targetScale || 1;
                          tileValue += Math.round(multiplier * speciesVal * scale * friendBonus);
                      }
                  });
              }
  
              return tileValue;
          }
  
          calculateInventoryValue() {
              const inventory = UnifiedState.atoms.inventory;
              const friendBonus = UnifiedState.atoms.friendBonus || 1;
              let inventoryValue = 0;
  
              if (inventory && inventory.items) {
                  inventory.items.forEach(item => {
                      if (item.itemType === 'Produce' && item.species) {
                          const multiplier = calculateMutationMultiplier(item.mutations);
                          const speciesVal = speciesValues[item.species] || 0;
                          const scale = item.scale || 1;
                          inventoryValue += Math.round(multiplier * speciesVal * scale * friendBonus);
                      }
                  });
              }
  
              return inventoryValue;
          }
  
          calculateGardenValue() {
              const myGarden = UnifiedState.atoms.myGarden;
              const friendBonus = UnifiedState.atoms.friendBonus || 1;
              let gardenValue = 0;
  
              if (myGarden && myGarden.garden && myGarden.garden.tileObjects) {
                  const now = Date.now();
                  Object.values(myGarden.garden.tileObjects).forEach(tile => {
                      if (tile.objectType === 'plant' && tile.slots) {
                          tile.slots.forEach(slot => {
                              if (slot && slot.species && slot.endTime && now >= slot.endTime) {
                                  const multiplier = calculateMutationMultiplier(slot.mutations);
                                  const speciesVal = speciesValues[slot.species] || 0;
                                  const scale = slot.targetScale || 1;
                                  gardenValue += Math.round(multiplier * speciesVal * scale * friendBonus);
                              }
                          });
                      }
                  });
              }
  
              return gardenValue;
          }
  
          updateAllValues(forceRefresh = false) {
              const tileValue = this.getTileValue(forceRefresh);
              const inventoryValue = this.getInventoryValue(forceRefresh);
              const gardenValue = this.getGardenValue(forceRefresh);
  
              // Store in UnifiedState
              UnifiedState.data.tileValue = tileValue;
              UnifiedState.data.inventoryValue = inventoryValue;
              UnifiedState.data.gardenValue = gardenValue;
  
              // Update UI if values tab is active
              this.updateValueDisplays();
  
              debugLog('VALUE_MANAGER', 'All values updated', {
                  tileValue,
                  inventoryValue,
                  gardenValue,
                  cached: Object.keys(this.cache).map(k => `${k}: ${Date.now() - this.cache[k].lastUpdate}ms ago`)
              });
  
              return { tileValue, inventoryValue, gardenValue };
          }
  
          updateValueDisplays() {
              // Update main window if values tab is active
              if (UnifiedState.activeTab === 'values') {
                  updateTabContent();
              }
  
              // Update all overlay windows showing values tab
              UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                  if (overlay && document.contains(overlay) && tabName === 'values') {
                      if (overlay.className.includes('mga-overlay-content-only')) {
                          updatePureOverlayContent(overlay, tabName);
                          debugLog('VALUE_MANAGER', 'Updated pure values overlay');
                      } else {
                          // Legacy overlay structure
                          const overlayContent = overlay.querySelector('.mga-overlay-content > div');
                          if (overlayContent) {
                              overlayContent.innerHTML = getValuesTabContent();
                              debugLog('VALUE_MANAGER', 'Updated legacy values overlay');
                          }
                      }
                  }
              });
  
              // Update separate windows
              UnifiedState.data.popouts.windows.forEach((windowRef, tabName) => {
                  if (windowRef && !windowRef.closed && tabName === 'values') {
                      try {
                          const freshContent = getValuesTabContent();
                          const contentElement = windowRef.document.getElementById('content');
                          if (contentElement) {
                              contentElement.innerHTML = freshContent;
                              // Set up dashboard handlers in the separate window
                              if (window.resourceDashboard) {
                                  window.resourceDashboard.setupDashboardHandlers(windowRef.document);
                              }
                              debugLog('VALUE_MANAGER', 'Updated values in separate window');
                          }
                      } catch (error) {
                          debugError('VALUE_MANAGER', 'Failed to update separate window', error);
                      }
                  }
              });
          }
  
          invalidateCache() {
              Object.keys(this.cache).forEach(key => {
                  this.cache[key].lastUpdate = 0;
              });
          }
  
          getStatus() {
              const now = Date.now();
              return {
                  cache: Object.keys(this.cache).reduce((acc, key) => {
                      const cached = this.cache[key];
                      acc[key] = {
                          value: cached.value,
                          age: now - cached.lastUpdate,
                          fresh: (now - cached.lastUpdate) < this.throttleMs
                      };
                      return acc;
                  }, {}),
                  throttleMs: this.throttleMs,
                  retryAttempts: this.retryAttempts
              };
          }
  
          destroy() {
              if (this.observer) {
                  this.observer.disconnect();
                  this.observer = null;
              }
          }
      }
  
      // Initialize global ValueManager
      let globalValueManager = null;
  
      function initializeValueManager() {
          if (!globalValueManager) {
              globalValueManager = new ValueManager();
          }
          return globalValueManager;
      }
  
      function updateValues() {
          // Use enhanced ValueManager instead of manual calculations
          const valueManager = globalValueManager || initializeValueManager();
          valueManager.updateAllValues();
  
          // Refresh Values tab if it's currently active
          if (UnifiedState.activeTab === 'values') {
              updateTabContent();
          }
  
          // Refresh any open Values overlays
          UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
              if (overlay && document.contains(overlay) && tabName === 'values') {
                  if (overlay.className.includes('mga-overlay-content-only')) {
                      updatePureOverlayContent(overlay, tabName);
                  }
              }
          });
  
          // Refresh Values in separate window popouts
          refreshSeparateWindowPopouts('values');
  
          debugLog('VALUES_UPDATE', 'Values updated and UI refreshed');
      }
  
      // ==================== SEED DELETION ====================
      function deleteSelectedSeeds() {
          if (!UnifiedState.atoms.inventory || !UnifiedState.atoms.inventory.items || !UnifiedState.data.seedsToDelete.length) {
              productionWarn('‚ö†Ô∏è No seeds selected for deletion!');
              return;
          }
  
          // Confirmation dialog for manual deletion
          const selectedSeedsText = UnifiedState.data.seedsToDelete.join(', ');
          const confirmMessage = `‚ö†Ô∏è WARNING: This action is IRREVERSIBLE!\n\nYou are about to permanently delete the following seeds:\n${selectedSeedsText}\n\nThis cannot be undone. Are you sure you want to continue?`;
  
          if (!confirm(confirmMessage)) {
              return;
          }
  
          // seedsToDelete now contains internal IDs (e.g., "OrangeTulip"), so direct comparison works
          productionLog('üå± [SEED-DELETE-DEBUG] Deletion attempt:', {
              seedsToDelete: UnifiedState.data.seedsToDelete,
              inventoryItems: UnifiedState.atoms.inventory.items?.map(item => ({species: item.species, quantity: item.quantity})) || 'No inventory',
              inventoryCount: UnifiedState.atoms.inventory.items?.length || 0
          });
  
          const itemsToDelete = UnifiedState.atoms.inventory.items.filter(item =>
              item && item.species && UnifiedState.data.seedsToDelete.includes(item.species)
          );
  
          productionLog('üå± [SEED-DELETE-DEBUG] Items found for deletion:', itemsToDelete.map(item => ({species: item.species, quantity: item.quantity})));
  
          if (!itemsToDelete.length) {
              productionLog('üå± [SEED-DELETE-DEBUG] No matching items found. Details:', {
                  selectedSeeds: UnifiedState.data.seedsToDelete,
                  availableSpecies: UnifiedState.atoms.inventory.items?.map(item => item.species) || []
              });
              productionWarn('‚ö†Ô∏è No matching seeds found in inventory!');
              return;
          }
  
          const summary = itemsToDelete.map(item => `${item.species}: ${item.quantity}`).join('\n');
  
          if (confirm(`Delete the following seeds?\n\n${summary}`)) {
              itemsToDelete.forEach(item => {
                  const qty = item.quantity || 0;
                  for (let i = 0; i < qty; i++) {
                      safeSendMessage({
                          scopePath: ["Room", "Quinoa"],
                          type: "Wish",
                          itemId: item.species
                      });
                  }
              });
  
              // Clear selections
              UnifiedState.data.seedsToDelete = [];
  
              // Clear checkboxes in main panel
              targetDocument.querySelectorAll('.seed-checkbox').forEach(cb => cb.checked = false);
  
              // Update main tab content
              if (UnifiedState.activeTab === 'seeds') {
                  updateTabContent();
              }
  
              // Update all seed overlays
              UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                  if (overlay && document.contains(overlay) && tabName === 'seeds') {
                      if (overlay.className.includes('mga-overlay-content-only')) {
                          updatePureOverlayContent(overlay, tabName);
                          // Also clear checkboxes in overlay
                          overlay.querySelectorAll('.seed-checkbox').forEach(cb => cb.checked = false);
                          debugLog('OVERLAY_LIFECYCLE', 'Updated pure seeds overlay after deletion');
                      }
                  }
              });
  
              // Update separate window popouts
              refreshSeparateWindowPopouts('seeds');
          }
      }
  
      function startAutoDelete() {
          if (!UnifiedState.data.autoDeleteEnabled) return;
  
          // Clear existing interval to prevent multiple intervals
          clearManagedInterval('autoDelete');
  
          // Use managed interval to prevent memory leaks
          setManagedInterval('autoDelete', () => {
              if (UnifiedState.data.autoDeleteEnabled && UnifiedState.data.seedsToDelete.length) {
                  const inventory = UnifiedState.atoms.inventory;
                  if (!inventory || !inventory.items) return;
  
                  // seedsToDelete now contains internal IDs (e.g., "OrangeTulip"), so direct comparison works
                  UnifiedState.data.seedsToDelete.forEach(seedToDelete => {
                      const matchingItems = inventory.items.filter(item =>
                          item && item.species && item.species === seedToDelete
                      );
  
                      matchingItems.forEach(item => {
                          const qty = item.quantity || 0;
                          for (let i = 0; i < qty; i++) {
                              safeSendMessage({
                                  scopePath: ["Room", "Quinoa"],
                                  type: "Wish",
                                  itemId: seedToDelete
                              });
                          }
                      });
                  });
              }
          }, 2000);
      }
  
      function stopAutoDelete() {
          clearManagedInterval('autoDelete');
          UnifiedState.data.autoDeleteEnabled = false;
          debugLog('PERFORMANCE', 'Auto-delete stopped and disabled');
      }
  
      // ==================== TIMERS ====================
      // ==================== ENHANCED TIMER MANAGER ====================
      class TimerManager {
          constructor() {
              this.activeTimers = new Map();
              this.isRunning = false;
              this.animationFrameId = null;
              this.lastHeartbeat = Date.now();
              this.heartbeatInterval = 1000; // 1 second heartbeat
              this.frozenThreshold = 3000; // 3 seconds to consider frozen
  
              // Initialize active timers storage
              if (!UnifiedState.data.activeTimers) {
                  UnifiedState.data.activeTimers = {};
              }
  
              this.loadPersistedTimers();
              this.startHeartbeat();
  
              debugLog('TIMER_MANAGER', 'TimerManager initialized', {
                  heartbeatInterval: this.heartbeatInterval,
                  frozenThreshold: this.frozenThreshold
              });
          }
  
          startTimer(id, callback, interval = 1000) {
              if (this.activeTimers.has(id)) {
                  this.stopTimer(id);
              }
  
              const timer = {
                  id,
                  callback,
                  interval,
                  lastRun: Date.now(),
                  running: true,
                  frozen: false
              };
  
              this.activeTimers.set(id, timer);
              UnifiedState.data.activeTimers[id] = {
                  interval,
                  lastRun: timer.lastRun,
                  running: true
              };
  
              this.saveTimerState();
  
              if (!this.isRunning) {
                  this.startMainLoop();
              }
  
              debugLog('TIMER_MANAGER', `Timer started: ${id}`, { interval });
              return timer;
          }
  
          stopTimer(id) {
              if (this.activeTimers.has(id)) {
                  this.activeTimers.delete(id);
                  delete UnifiedState.data.activeTimers[id];
                  this.saveTimerState();
                  debugLog('TIMER_MANAGER', `Timer stopped: ${id}`);
              }
          }
  
          pauseAll() {
              this.activeTimers.forEach((timer, id) => {
                  timer.running = false;
                  UnifiedState.data.activeTimers[id].running = false;
              });
              this.saveTimerState();
              debugLog('TIMER_MANAGER', 'All timers paused');
          }
  
          resumeAll() {
              this.activeTimers.forEach((timer, id) => {
                  timer.running = true;
                  timer.lastRun = Date.now(); // Reset to prevent immediate execution
                  UnifiedState.data.activeTimers[id].running = true;
                  UnifiedState.data.activeTimers[id].lastRun = timer.lastRun;
              });
              this.saveTimerState();
              debugLog('TIMER_MANAGER', 'All timers resumed');
          }
  
          startMainLoop() {
              if (this.isRunning) return;
  
              this.isRunning = true;
              const loop = (currentTime) => {
                  if (!this.isRunning || this.activeTimers.size === 0) {
                      this.isRunning = false;
                      this.animationFrameId = null;
                      return;
                  }
  
                  this.processTimers(currentTime);
                  this.animationFrameId = requestAnimationFrame(loop);
              };
  
              this.animationFrameId = requestAnimationFrame(loop);
              debugLog('TIMER_MANAGER', 'Main loop started');
          }
  
          processTimers(currentTime) {
              this.activeTimers.forEach((timer, id) => {
                  if (!timer.running) return;
  
                  const elapsed = currentTime - timer.lastRun;
                  if (elapsed >= timer.interval) {
                      try {
                          timer.callback();
                          timer.lastRun = currentTime;
                          timer.frozen = false;
                          UnifiedState.data.activeTimers[id].lastRun = timer.lastRun;
                      } catch (error) {
                          debugError('TIMER_MANAGER', `Timer callback error for ${id}`, error);
                      }
                  }
              });
          }
  
          startHeartbeat() {
              const heartbeat = () => {
                  const now = Date.now();
                  const timeSinceLastBeat = now - this.lastHeartbeat;
  
                  // Detect if main loop is frozen
                  if (this.isRunning && timeSinceLastBeat > this.frozenThreshold) {
                      debugLog('TIMER_MANAGER', 'Heartbeat detected frozen timers, restarting main loop', {
                          timeSinceLastBeat
                      });
                      this.restartMainLoop();
                  }
  
                  // Check individual timers for freezing
                  this.checkForFrozenTimers(now);
  
                  this.lastHeartbeat = now;
                  setTimeout(heartbeat, this.heartbeatInterval);
              };
  
              // Start first heartbeat
              setTimeout(heartbeat, this.heartbeatInterval);
              debugLog('TIMER_MANAGER', 'Heartbeat monitor started');
          }
  
          checkForFrozenTimers(now) {
              this.activeTimers.forEach((timer, id) => {
                  if (!timer.running) return;
  
                  const timeSinceLastRun = now - timer.lastRun;
                  const expectedRuns = Math.floor(timeSinceLastRun / timer.interval);
  
                  if (expectedRuns > 2 && !timer.frozen) {
                      debugLog('TIMER_MANAGER', `Timer appears frozen: ${id}`, {
                          timeSinceLastRun,
                          expectedRuns,
                          interval: timer.interval
                      });
                      timer.frozen = true;
                      this.restartTimer(id);
                  }
              });
          }
  
          restartTimer(id) {
              const timer = this.activeTimers.get(id);
              if (timer) {
                  timer.lastRun = Date.now();
                  timer.frozen = false;
                  debugLog('TIMER_MANAGER', `Timer restarted: ${id}`);
              }
          }
  
          restartMainLoop() {
              if (this.animationFrameId) {
                  cancelAnimationFrame(this.animationFrameId);
                  this.animationFrameId = null;
              }
              this.isRunning = false;
              setTimeout(() => this.startMainLoop(), 100); // Small delay before restart
          }
  
          saveTimerState() {
              try {
                  MGA_saveJSON('MGA_timerStates', UnifiedState.data.activeTimers);
              } catch (error) {
                  debugError('TIMER_MANAGER', 'Failed to save timer state', error);
              }
          }
  
          loadPersistedTimers() {
              try {
                  const saved = MGA_loadJSON('MGA_timerStates', {});
                  UnifiedState.data.activeTimers = { ...saved };
                  debugLog('TIMER_MANAGER', 'Loaded persisted timer states', {
                      count: Object.keys(saved).length
                  });
              } catch (error) {
                  debugError('TIMER_MANAGER', 'Failed to load persisted timers', error);
              }
          }
  
          getStatus() {
              return {
                  isRunning: this.isRunning,
                  activeCount: this.activeTimers.size,
                  frozenCount: Array.from(this.activeTimers.values()).filter(t => t.frozen).length,
                  lastHeartbeat: this.lastHeartbeat
              };
          }
      }
  
      // Initialize global TimerManager
      let globalTimerManager = null;
  
      function initializeTimerManager() {
          if (!globalTimerManager) {
              globalTimerManager = new TimerManager();
          }
          return globalTimerManager;
      }
  
      function updateTimers() {
          // Update restock timers
          const quinoaData = UnifiedState.atoms.quinoaData;
          if (quinoaData && quinoaData.shops) {
              UnifiedState.data.timers.seed = (quinoaData.shops.seed && quinoaData.shops.seed.secondsUntilRestock) || null;
              UnifiedState.data.timers.egg = (quinoaData.shops.egg && quinoaData.shops.egg.secondsUntilRestock) || null;
              UnifiedState.data.timers.tool = (quinoaData.shops.tool && quinoaData.shops.tool.secondsUntilRestock) || null;
          }
  
          // Calculate lunar event
          const lunarResult = getSecondsToNextLunarEvent();
          UnifiedState.data.timers.lunar = lunarResult.secondsLeft;
  
          // Note: checkForWatchedItems() now runs on its own 5-second interval
  
          // Always update timer display (needed for pop-out windows to work independently)
          updateTimerDisplay();
      }
  
      function getSecondsToNextLunarEvent() {
          const eventZone = "America/Chicago";
          const lunarHours = [3, 7, 11, 15, 19, 23];
  
          // Get current time in Central Time Zone
          const now = new Date();
          const centralTime = new Date(now.toLocaleString('en-US', { timeZone: eventZone }));
  
          const currentHour = centralTime.getHours();
          const currentMin = centralTime.getMinutes();
          const currentSec = centralTime.getSeconds();
  
          // Find next lunar event hour
          let nextEventHour = null;
          for (const eventHour of lunarHours) {
              if (eventHour > currentHour || (eventHour === currentHour && currentMin === 0 && currentSec === 0)) {
                  nextEventHour = eventHour;
                  break;
              }
          }
  
          // If no event found today, get first event tomorrow
          if (nextEventHour === null) {
              nextEventHour = lunarHours[0];
          }
  
          // Create next event date in Central Time
          const nextEvent = new Date(centralTime);
          nextEvent.setHours(nextEventHour, 0, 0, 0);
  
          // If event is in the past today, move to tomorrow
          if (nextEvent <= centralTime) {
              nextEvent.setDate(nextEvent.getDate() + 1);
          }
  
          // Calculate seconds until event (precise calculation without manual adjustment)
          const secondsLeft = Math.max(0, Math.floor((nextEvent.getTime() - centralTime.getTime()) / 1000));
  
          return {
              secondsLeft: secondsLeft, // Precise calculation without manual adjustment
              eventDateLocal: nextEvent
          };
      }
  
      function updateTimerDisplay() {
          const formatTime = (seconds) => {
              if (seconds == null) return '--:--';
              const s = Math.max(0, Math.floor(seconds));
              const m = Math.floor(s / 60);
              const ss = s % 60;
              return `${m}:${String(ss).padStart(2, '0')}`;
          };
  
          const formatTimeHoursMinutes = (seconds) => {
              if (seconds == null) return '--:--';
              const totalMinutes = Math.floor(seconds / 60);
              const hours = Math.floor(totalMinutes / 60);
              const minutes = totalMinutes % 60;
  
              if (hours > 0) {
                  return `${hours}h ${minutes}m`;
              } else {
                  return `${minutes}m`;
              }
          };
  
          // Helper function to update timer elements across all contexts
          const updateTimerElement = (id, value) => {
              // Choose formatter based on timer type
              const formatter = (id === 'timer-lunar') ? formatTimeHoursMinutes : formatTime;
              const formattedValue = formatter(value);
  
              // Update main window
              const mainElement = document.getElementById(id);
              if (mainElement) {
                  mainElement.textContent = formattedValue;
              }
  
              // Update in-game overlays
              UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                  if (overlay && document.contains(overlay)) {
                      const overlayElement = overlay.querySelector(`#${id}`);
                      if (overlayElement) {
                          overlayElement.textContent = formattedValue;
                      }
                  }
              });
  
              // Update all timer elements with this ID across all open windows
              // This catches pop-out windows that may contain timer elements
              try {
                  const allElements = targetDocument.querySelectorAll(`#${id}`);
                  allElements.forEach(el => {
                      el.textContent = formattedValue;
                  });
              } catch (e) {
                  // Ignore errors from closed windows
              }
          };
  
          // Update all timer types
          updateTimerElement('timer-seed', UnifiedState.data.timers.seed);
          updateTimerElement('timer-egg', UnifiedState.data.timers.egg);
          updateTimerElement('timer-tool', UnifiedState.data.timers.tool);
          updateTimerElement('timer-lunar', UnifiedState.data.timers.lunar);
      }
  
      // ==================== DEBUGGING UTILITIES ====================
      window.debugPets = function() {
          productionLog('üîç [DEBUG] Debugging pets data...');
          productionLog('üêæ UnifiedState.atoms.activePets:', UnifiedState.atoms.activePets);
          productionLog('üêæ window.activePets:', window.activePets);
  
          // Try to access game's pet data directly
          if (targetWindow.MagicCircle_RoomConnection) {
              const roomState = targetWindow.MagicCircle_RoomConnection.lastRoomStateJsonable;
              productionLog('üéÆ Room state pets:', roomState?.child?.data?.petSlots);
              productionLog('üéÆ User slots:', roomState?.child?.data?.userSlots);
          }
  
          // Check jotai atoms
          if (targetWindow.jotaiAtomCache) {
              const allAtoms = Array.from(targetWindow.jotaiAtomCache.keys());
              const petAtoms = allAtoms.filter(key =>
                  key.toLowerCase().includes('pet') ||
                  key.toLowerCase().includes('slot') ||
                  key.toLowerCase().includes('animal')
              );
              productionLog('üîç Pet-related atoms found:', petAtoms);
          }
  
          productionLog('üè† Presets saved:', Object.keys(UnifiedState.data.petPresets));
      };
  
      // Manual fallback to force update Active Pets display
      window.forceUpdateActivePets = function() {
          productionLog('üîß [MANUAL] Force updating Active Pets display...');
  
          // Try to get pets from room state as fallback
          if (targetWindow.MagicCircle_RoomConnection) {
              const roomState = targetWindow.MagicCircle_RoomConnection.lastRoomStateJsonable;
              const petSlots = roomState?.child?.data?.petSlots;
  
              if (petSlots && Array.isArray(petSlots)) {
                  // Convert room state format to our expected format
                  const activePetsFromRoom = petSlots.filter(slot => slot && slot.item).map(slot => ({
                      id: slot.item.id,
                      petSpecies: slot.item.species || 'Unknown',
                      mutations: slot.item.mutations || []
                  }));
  
                  productionLog('üêæ [FALLBACK] Found pets in room state:', activePetsFromRoom);
  
                  // Manually set the active pets data
                  UnifiedState.atoms.activePets = activePetsFromRoom;
                  window.activePets = activePetsFromRoom;
  
                  // Force update displays
                  updateActivePetsDisplay(document);
                  UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                      if (overlay && document.contains(overlay) && tabName === 'pets') {
                          updateActivePetsDisplay(overlay);
                      }
                  });
  
                  productionLog('‚úÖ [FALLBACK] Active pets display updated manually');
                  return activePetsFromRoom;
              }
          }
  
          productionWarn('‚ùå [FALLBACK] Could not find pet data in room state');
          return null;
      };
  
  
      // ==================== INITIALIZATION ====================
      function initializeAtoms() {
          productionLog('üîó [SIMPLE-ATOMS] Starting simple atom initialization...');
  
          // Start simple pet detection using room state
          productionLog('üêæ [SIMPLE-ATOMS] Setting up room state pet detection...');
          updateActivePetsFromRoomState(); // Get initial pets immediately
  
          // Set up periodic pet detection (reduced frequency to minimize console spam)
          setManagedInterval('petDetection', () => {
              updateActivePetsFromRoomState();
  
              // ALSO check window.activePets directly (set by atom hook)
              if (window.activePets && Array.isArray(window.activePets) && window.activePets.length > 0) {
                  productionLog('üêæ [PERIODIC-CHECK] Found pets in window.activePets:', window.activePets);
  
                  // Update UnifiedState
                  if (!UnifiedState.atoms.activePets || UnifiedState.atoms.activePets.length !== window.activePets.length) {
                      UnifiedState.atoms.activePets = window.activePets;
  
                      // Force UI update
                      if (UnifiedState.activeTab === 'pets') {
                          const context = document.getElementById('mga-tab-content');
                          if (context) {
                              updateTabContent('pets', context);
                          }
                      }
                  }
              }
          }, 30000); // Check every 30 seconds
  
          // Hook #1: Pet SPECIES data (for active pets display)
          hookAtom(
              "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/_archive/myPetSlotsAtom.ts/myPetSlotsAtom",
              "activePets",
              (petSlots) => {
                  if (UnifiedState.data.settings?.debugMode) {
                      productionLog('üêæ [ATOM-DEBUG] myPetSlotsAtom raw value:', {
                          value: petSlots,
                          type: typeof petSlots,
                          isArray: Array.isArray(petSlots),
                          length: petSlots?.length,
                          valueIsArray: Array.isArray(petSlots?.value),
                          valueLength: petSlots?.value?.length
                      });
                  }
  
                  // Extract the actual array from the wrapper object
                  const actualPetSlots = Array.isArray(petSlots) ? petSlots : petSlots?.value;
  
                  // Extract active pets with species info
                  if (Array.isArray(actualPetSlots)) {
                      // DEBUG: Log raw slot data to understand structure
                      if (UnifiedState.data.settings?.debugMode) {
                          console.log('üêæ [ATOM-DEBUG] Raw pet slots:', actualPetSlots);
                          actualPetSlots.forEach((slot, i) => {
                              console.log(`üêæ [ATOM-DEBUG] Slot ${i}:`, slot);
                          });
                      }
  
                      const activePets = actualPetSlots
                          .filter(slot => {
                              // Check if slot has pet data (handle multiple possible property names)
                              const hasPet = slot && (slot.petSpecies || slot.species || slot.petId || slot.id);
                              return hasPet;
                          })
                          .map((slot, index) => {
                              const extracted = {
                                  id: slot.id || slot.petId || `pet_${index}`,
                                  petSpecies: slot.petSpecies || slot.species || 'Unknown',
                                  mutations: slot.mutations || [],
                                  abilities: slot.abilities || [],
                                  hunger: slot.hunger ?? slot.petHunger ?? slot.health ?? 100,  // Include hunger for pet hunger notifications
                                  xp: slot.xp || 0,  // CRITICAL: Required for turtle timer experience calculation
                                  targetScale: slot.targetScale || slot.scale || 1,  // CRITICAL: Required for turtle timer scale bonus calculation
                                  strength: slot.strength || slot.str || 100,  // Include strength for Hunger Boost calculations
                                  str: slot.str || slot.strength || 100,       // Fallback property name
                                  slot: index + 1
                              };
  
                              if (UnifiedState.data.settings?.debugMode) {
                                  console.log(`üêæ [ATOM-DEBUG] Extracted pet ${index}:`, extracted);
                              }
  
                              return extracted;
                          });
  
                      if (UnifiedState.data.settings?.debugMode) {
                          productionLog('üêæ [PETS] Extracted active pets:', activePets);
                      }
  
                      const previousCount = UnifiedState.atoms.activePets?.length || 0;
                      const previousPets = UnifiedState.atoms.activePets || [];
  
                      // Check if pets changed (count OR species/abilities)
                      const petsChanged = activePets.length !== previousCount ||
                                         JSON.stringify(activePets.map(p => ({s: p.petSpecies, a: p.abilities}))) !==
                                         JSON.stringify(previousPets.map(p => ({s: p.petSpecies, a: p.abilities})));
  
                      if (petsChanged) {
                          // Update UI if pets tab is active
                          if (UnifiedState.activeTab === 'pets') {
                              const context = document.getElementById('mga-tab-content');
                              if (context && typeof updateActivePetsDisplay === 'function') {
                                  updateActivePetsDisplay(context);
                              }
                          }

                          // Update all pet overlays
                          UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                              if (overlay && document.contains(overlay) && tabName === 'pets') {
                                  updateActivePetsDisplay(overlay);
                              }
                          });

                          // TURTLE TIMER: Refresh tooltip when pets change
                          (targetDocument || document).querySelectorAll('[data-turtletimer-estimate="true"], [data-turtletimer-slot-value="true"]')
                              .forEach((el) => el.remove());

                          setTimeout(() => {
                              requestAnimationFrame(() => {
                                  if (typeof insertTurtleEstimate === 'function') {
                                      insertTurtleEstimate();
                                  }
                              });
                          }, 150);
                      }
  
                      // CRITICAL: Return the extracted array so hookAtom stores it correctly
                      if (UnifiedState.data.settings?.debugMode) {
                          productionLog('üîÑ [RENDER-CYCLE] Atom callback returning pets to hookAtom system:', {
                              petsCount: activePets.length,
                              petsList: activePets.map(p => p.petSpecies),
                              willUpdateUnifiedState: true,
                              willUpdateWindowActivePets: true
                          });
                      }
                      return activePets;
                  } else {
                      if (UnifiedState.data.settings?.debugMode) {
                          productionLog('üêæ [EXTRACTION-ERROR] actualPetSlots is not an array:', actualPetSlots);
                      }
                      return [];
                  }
              }
          );
  
          // Hook #2: Pet ABILITY data (for ability logs - monitoring handled by timer only)
          hookAtom(
              "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myPetSlotInfosAtom",
              "petAbility",
              null // Removed duplicate monitorPetAbilities() call to prevent double logging
          );
  
          // Hook inventory
          hookAtom(
              "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myInventoryAtom",
              "inventory",
              () => updateValues()
          );
  
          // Hook crop data
          hookAtom(
              "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom",
              "currentCrop",
              () => updateValues()
          );
  
          // Hook friend bonus from game (same as Slot,Inv,Garden script)
          hookAtom(
              "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/miscAtoms.ts/friendBonusMultiplierAtom",
              "friendBonus",
              (value) => {
                  UnifiedState.atoms.friendBonus = value || 1;
                  targetWindow.friendBonus = value; // Also needed for harvest/sell protection
                  updateValues();
              }
          );
  
          // Hook garden data AND myData for auto-favorite
          hookAtom(
              "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myDataAtom",
              "myGarden",
              (value) => {
                  targetWindow.myGarden = value; // Needed for harvest protection
                  targetWindow.myData = value; // Needed for auto-favorite
                  updateValues();
              }
          );
  
          // Hook quinoa data for timers and globalShop
          hookAtom(
              "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/_archive/quinoaDataAtom.ts/quinoaDataAtom",
              "quinoaData",
              (value) => {
                  // Store quinoa data for timers
                  UnifiedState.atoms.quinoaData = value;
                  // Also make globalShop available for notifications (same as MainScript)
                  targetWindow.globalShop = value;
                  // Update timers
                  updateTimers();
              }
          );
  
          // Hook REAL-TIME shop atoms for purchase tracking
          hookAtom(
              "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/shopAtoms.ts/seedShopAtom",
              "seedShop",
              (value) => {
                  // Update globalShop.shops.seed with real-time data
                  if (!targetWindow.globalShop) targetWindow.globalShop = {};
                  if (!targetWindow.globalShop.shops) targetWindow.globalShop.shops = {};
                  targetWindow.globalShop.shops.seed = value;
  
                  // Trigger shop UI refresh if open
                  if (typeof targetWindow.refreshAllShopWindows === 'function') {
                      targetWindow.refreshAllShopWindows();
                  }
              }
          );
  
          hookAtom(
              "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/shopAtoms.ts/eggShopAtom",
              "eggShop",
              (value) => {
                  // Update globalShop.shops.egg with real-time data
                  if (!targetWindow.globalShop) targetWindow.globalShop = {};
                  if (!targetWindow.globalShop.shops) targetWindow.globalShop.shops = {};
                  targetWindow.globalShop.shops.egg = value;
  
                  // Trigger shop UI refresh if open
                  if (typeof targetWindow.refreshAllShopWindows === 'function') {
                      targetWindow.refreshAllShopWindows();
                  }
              }
          );
  
          productionLog('‚úÖ [SIMPLE-ATOMS] Simple atom initialization complete (including shop atoms)');
  
          // CRITICAL: Check if window.activePets already exists after hooks are set up
          setTimeout(() => {
              if (window.activePets && Array.isArray(window.activePets) && window.activePets.length > 0) {
                  productionLog('üêæ [INIT-CHECK] Found existing pets in window.activePets after hook setup:', window.activePets);
                  UnifiedState.atoms.activePets = window.activePets;
  
                  // Force UI update if on pets tab
                  if (UnifiedState.activeTab === 'pets') {
                      const context = document.getElementById('mga-tab-content');
                      if (context) {
                          updateTabContent('pets', context);
                      }
                  }
              } else {
                  productionLog('üêæ [INIT-CHECK] No pets found in window.activePets yet');
              }
          }, 2000); // Wait 2 seconds for atoms to populate
      }

      // ==================== AUTO-FAVORITE SYSTEM ====================
      (function initAutoFavorite() {
          let lastInventoryCount = 0;

          // Monitor inventory changes for auto-favorite (myData is set by existing myDataAtom hook)
          setInterval(() => {
              if (!targetWindow.myData?.inventory?.items || !UnifiedState.data.settings.autoFavorite.enabled) {
                  return;
              }

              const currentCount = targetWindow.myData.inventory.items.length;
              if (currentCount > lastInventoryCount) {
                  checkAndFavoriteNewItems(targetWindow.myData.inventory);
              }
              lastInventoryCount = currentCount;
          }, 500);

          function checkAndFavoriteNewItems(inventory) {
              if (!inventory?.items) return;
              if (!UnifiedState.data.settings.autoFavorite.species.length && !UnifiedState.data.settings.autoFavorite.mutations.length) return;

              const favoritedIds = new Set(inventory.favoritedItemIds || []);
              const targetSpecies = new Set(UnifiedState.data.settings.autoFavorite.species);
              const targetMutations = new Set(UnifiedState.data.settings.autoFavorite.mutations);
              let count = 0;

              for (const item of inventory.items) {
                  if (favoritedIds.has(item.id)) continue; // Already favorited
                  if (item.itemType !== 'Produce') continue; // Only auto-favorite crops

                  // CRITICAL: Explicitly exclude pets, eggs, and tools - CROPS ONLY
                  if (item.itemType === 'Pet' || item.itemType === 'Egg' || item.itemType === 'Tool') continue;
                  if (item.category === 'Pet' || item.category === 'Egg' || item.category === 'Tool') continue;
                  if (item.species && (item.species.includes('Pet') || item.species.includes('Egg'))) continue;

                  // Check if item matches species
                  const matchesSpecies = targetSpecies.has(item.species);

                  // Check if item matches any mutation
                  const itemMutations = item.mutations || [];
                  const matchesMutation = itemMutations.some(mut => targetMutations.has(mut));

                  if (matchesSpecies || matchesMutation) {
                      // Send favorite command
                      if (targetWindow.MagicCircle_RoomConnection?.sendMessage) {
                          targetWindow.MagicCircle_RoomConnection.sendMessage({
                              scopePath: ["Room", "Quinoa"],
                              type: "ToggleFavoriteItem",
                              itemId: item.id
                          });
                          count++;
                      }
                  }
              }

              if (count > 0) {
                  productionLog(`üåü [AUTO-FAVORITE] Auto-favorited ${count} new crops`);
              }
          }

          // Function to favorite ALL items of a species (called when checkbox is checked)
          targetWindow.favoriteSpecies = function(speciesName) {
              if (!targetWindow.myData?.inventory?.items) {
                  productionLog('üåü [AUTO-FAVORITE] No myData available yet - waiting for game to load');
                  return;
              }

              const items = targetWindow.myData.inventory.items;
              const favoritedIds = new Set(targetWindow.myData.inventory.favoritedItemIds || []);
              let count = 0;

              productionLog(`üåü [AUTO-FAVORITE] Attempting to favorite all ${speciesName} crops...`);

              for (const item of items) {
                  // CRITICAL: Multiple checks to ensure ONLY crops are favorited
                  if (item.itemType !== 'Produce') continue;
                  if (item.itemType === 'Pet' || item.itemType === 'Egg' || item.itemType === 'Tool') continue;
                  if (item.category === 'Pet' || item.category === 'Egg' || item.category === 'Tool') continue;
                  if (item.species && (item.species.includes('Pet') || item.species.includes('Egg'))) continue;

                  if (item.species === speciesName && !favoritedIds.has(item.id)) {
                      if (targetWindow.MagicCircle_RoomConnection?.sendMessage) {
                          targetWindow.MagicCircle_RoomConnection.sendMessage({
                              scopePath: ["Room", "Quinoa"],
                              type: "ToggleFavoriteItem",
                              itemId: item.id
                          });
                          count++;
                          productionLog(`üåü [AUTO-FAVORITE] Favoriting ${item.species} (id: ${item.id})`);
                      } else {
                          productionLog('‚ùå [AUTO-FAVORITE] MagicCircle_RoomConnection not available!');
                      }
                  }
              }

              if (count > 0) {
                  productionLog(`‚úÖ [AUTO-FAVORITE] Favorited ${count} ${speciesName} crops`);
              } else {
                  productionLog(`‚ÑπÔ∏è [AUTO-FAVORITE] No ${speciesName} crops to favorite (already favorited or none in inventory)`);
              }
          };

          // DISABLED: Script never unfavorites - only adds favorites
          targetWindow.unfavoriteSpecies = function(speciesName) {
              productionLog(`üîí [AUTO-FAVORITE] Checkbox unchecked for ${speciesName} - Auto-favorite disabled, but existing favorites are preserved (script never removes favorites)`);
              // Do nothing - script only adds favorites, never removes them
              // This protects user's manually-favorited items (pets, eggs, crops, etc.)
          };

          // Function to favorite ALL items with a specific mutation (called when mutation checkbox is checked)
          targetWindow.favoriteMutation = function(mutationName) {
              if (!targetWindow.myData?.inventory?.items) {
                  productionLog('üåü [AUTO-FAVORITE] No myData available yet - waiting for game to load');
                  return;
              }

              const items = targetWindow.myData.inventory.items;
              const favoritedIds = new Set(targetWindow.myData.inventory.favoritedItemIds || []);
              let count = 0;

              productionLog(`üåü [AUTO-FAVORITE] Attempting to favorite all crops with ${mutationName} mutation...`);

              for (const item of items) {
                  // CRITICAL: Multiple checks to ensure ONLY crops are favorited
                  if (item.itemType !== 'Produce') continue;
                  if (item.itemType === 'Pet' || item.itemType === 'Egg' || item.itemType === 'Tool') continue;
                  if (item.category === 'Pet' || item.category === 'Egg' || item.category === 'Tool') continue;
                  if (item.species && (item.species.includes('Pet') || item.species.includes('Egg'))) continue;

                  const itemMutations = item.mutations || [];
                  if (itemMutations.includes(mutationName) && !favoritedIds.has(item.id)) {
                      if (targetWindow.MagicCircle_RoomConnection?.sendMessage) {
                          targetWindow.MagicCircle_RoomConnection.sendMessage({
                              scopePath: ["Room", "Quinoa"],
                              type: "ToggleFavoriteItem",
                              itemId: item.id
                          });
                          count++;
                          productionLog(`üåü [AUTO-FAVORITE] Favoriting ${item.species} with ${mutationName} mutation (id: ${item.id})`);
                      } else {
                          productionLog('‚ùå [AUTO-FAVORITE] MagicCircle_RoomConnection not available!');
                      }
                  }
              }

              if (count > 0) {
                  productionLog(`‚úÖ [AUTO-FAVORITE] Favorited ${count} crops with ${mutationName} mutation`);
              } else {
                  productionLog(`‚ÑπÔ∏è [AUTO-FAVORITE] No crops with ${mutationName} mutation to favorite (already favorited or none in inventory)`);
              }
          };

          // DISABLED: Script never unfavorites - only adds favorites
          targetWindow.unfavoriteMutation = function(mutationName) {
              productionLog(`üîí [AUTO-FAVORITE] Checkbox unchecked for ${mutationName} mutation - Auto-favorite disabled, but existing favorites are preserved (script never removes favorites)`);
              // Do nothing - script only adds favorites, never removes them
              // This protects user's manually-favorited items (pets, eggs, crops, etc.)
          };

          productionLog('üåü [AUTO-FAVORITE] System initialized - monitoring inventory changes');

          // Diagnostic check every 5 seconds
          setInterval(() => {
              const hasMyData = !!targetWindow.myData;
              const hasConnection = !!targetWindow.MagicCircle_RoomConnection;
              const hasInventory = !!targetWindow.myData?.inventory?.items;
              const inventoryCount = targetWindow.myData?.inventory?.items?.length || 0;

              if (!hasMyData || !hasConnection) {
                  productionLog(`üîç [AUTO-FAVORITE-DEBUG] myData: ${hasMyData}, Connection: ${hasConnection}, Inventory: ${hasInventory}, Items: ${inventoryCount}`);
              }
          }, 5000);

          // Expose test function for manual testing
          targetWindow.testAutoFavorite = function() {
              productionLog('üß™ [AUTO-FAVORITE-TEST] Starting diagnostic test...');
              productionLog('üß™ myData exists:', !!targetWindow.myData);
              productionLog('üß™ MagicCircle_RoomConnection exists:', !!targetWindow.MagicCircle_RoomConnection);
              productionLog('üß™ Inventory items:', targetWindow.myData?.inventory?.items?.length || 0);
              productionLog('üß™ Auto-favorite enabled:', UnifiedState.data.settings.autoFavorite.enabled);
              productionLog('üß™ Watched species:', UnifiedState.data.settings.autoFavorite.species);
              if (targetWindow.myData?.inventory?.items) {
                  const itemCounts = {};
                  targetWindow.myData.inventory.items.forEach(item => {
                      itemCounts[item.species] = (itemCounts[item.species] || 0) + 1;
                  });
                  productionLog('üß™ Inventory breakdown:', itemCounts);
              }
          };

          productionLog('üí° [AUTO-FAVORITE] Run testAutoFavorite() in console to debug auto-favorite issues');
      })();

      // ==================== TURTLE TIMER (CROP GROWTH BOOST II) ====================
      // Calculates expected crop growth time with Turtle's Plant Growth Boost II ability
  
      function getCropHash(crop) {
          try {
              return JSON.stringify(crop);
          } catch (e) {
              return "__ref_changed__" + Date.now();
          }
      }
  
      function getTurtleExpectations(activePets) {
          // Debug: Only log when debug mode is enabled
          if (UnifiedState.data.settings?.debugMode) {
              logDebug('TURTLE', 'Checking active pets:', {
                  petsCount: activePets?.length || 0,
                  pets: (activePets || []).map(p => ({
                      species: p?.petSpecies,
                      hunger: p?.hunger,
                      abilities: p?.abilities
                  }))
              });
          }
  
          const turtles = (activePets || []).filter(p =>
              p &&
              p.petSpecies === "Turtle" &&
              p.hunger > 0 &&
              p.abilities?.some(a =>
                  a === "Plant Growth Boost II" ||
                  a === "PlantGrowthBoostII" ||
                  a === "Plant Growth Boost 2" ||
                  (typeof a === 'string' && a.toLowerCase().includes("plant") && a.toLowerCase().includes("growth") && (a.includes("II") || a.includes("2")))
              )
          );
  
          if (UnifiedState.data.settings?.debugMode) {
              logDebug('TURTLE', 'Filtered turtles:', {
                  turtleCount: turtles.length,
                  turtles: turtles.map(t => ({
                      species: t.petSpecies,
                      hunger: t.hunger,
                      abilities: t.abilities,
                      xp: t.xp,
                      targetScale: t.targetScale
                  }))
              });
          }
  
          let expectedMinutesRemoved = 0;
  
          turtles.forEach(p => {
              const xpComponent = Math.min(Math.floor((p.xp || 0) / (100 * 3600) * 30), 30);
              const scaleComponent = Math.floor((((p.targetScale || 1) - 1) / (2.5 - 1)) * 20 + 80) - 30;
              const base = xpComponent + scaleComponent;
              const minutesRemoved = (base / 100 * 5) * 60 * (1 - Math.pow(1 - 0.27 * base / 100, 1/60));
  
              if (UnifiedState.data.settings?.debugMode) {
                  logDebug('TURTLE', 'Turtle calculation:', {
                      xp: p.xp,
                      targetScale: p.targetScale,
                      xpComponent,
                      scaleComponent,
                      base,
                      minutesRemoved
                  });
              }
  
              expectedMinutesRemoved += minutesRemoved;
          });
  
          if (UnifiedState.data.settings?.debugMode) {
              logDebug('TURTLE', 'Total expected minutes removed:', expectedMinutesRemoved);
          }
  
          return {
              expectedMinutesRemoved
          };
      }
  
      function estimateUntilLatestCrop(currentCrop, activePets, slotIndex = null) {
          try {
              if (!currentCrop || currentCrop.length === 0) return null;
              if (!activePets || activePets.length === 0) return null;

              const turtleExpectations = getTurtleExpectations(activePets);
              if (!turtleExpectations || turtleExpectations.expectedMinutesRemoved == 0) {
                  return null;
              }

              const now = Date.now();

              // If slotIndex provided and valid, use that slot's endTime
              // Otherwise use the latest crop's endTime
              let targetEndTime;
              if (slotIndex !== null && slotIndex >= 0 && slotIndex < currentCrop.length) {
                  targetEndTime = currentCrop[slotIndex]?.endTime || 0;
              } else {
                  targetEndTime = Math.max(...currentCrop.map(c => c.endTime || 0));
              }

              if (targetEndTime <= now) return null; // Crop already mature

              const remainingRealMinutes = (targetEndTime - now) / (1000 * 60);
              const { expectedMinutesRemoved } = turtleExpectations;
              const effectiveRate = expectedMinutesRemoved + 1;
              const expectedRealMinutes = remainingRealMinutes / effectiveRate;

              const hours = Math.floor(expectedRealMinutes / 60);
              const minutes = Math.floor(expectedRealMinutes % 60);

              return `${hours}h ${minutes}m`;
          } catch (error) {
              logError('TURTLE', 'ERROR in estimateUntilLatestCrop:', error);
              return null;
          }
      }
  
      // REPLACE the entire existing insertTurtleEstimate function with this complete robust version:
  // ---------- FULL REPLACEMENT: insertTurtleEstimate() ----------

  // ---------- REPLACEMENT: insertTurtleEstimate() with spatial matching ----------

  // ==================== GENERIC ABILITY EXPECTATIONS ====================
  function getAbilityExpectations(activePets, abilityName, minutesPerBase = 5, odds = 0.27) {
      const pets = (activePets || []).filter(p =>
          p &&
          p.hunger > 0 &&
          p.abilities?.some(a => a === abilityName)
      );

      let expectedMinutesRemoved = 0;

      pets.forEach(p => {
          const base =
              Math.min(Math.floor((p.xp || 0) / (100 * 3600) * 30), 30)
              + Math.floor((((p.targetScale || 1) - 1) / (2.5 - 1)) * 20 + 80)
              - 30;

          expectedMinutesRemoved += (base / 100 * minutesPerBase) * 60 * (1 - Math.pow(1 - odds * base / 100, 1 / 60));
      });

      return {
          expectedMinutesRemoved
      };
  }

  function getEggExpectations(activePets) {
      return getAbilityExpectations(activePets, "EggGrowthBoostII", 10, 0.24);
  }

  function getGrowthExpectations(activePets) {
      return getAbilityExpectations(activePets, "PlantGrowthBoostII", 5, 0.27);
  }

function insertTurtleEstimate() {
    const doc = targetDocument || document;

    // Remove existing turtle estimates and slot values
    doc.querySelectorAll('[data-turtletimer-estimate="true"], [data-turtletimer-slot-value="true"]')
        .forEach((el) => el.remove());

    // CORRECT SELECTOR: Get the last child's parent (where weight/mutations are shown)
    let currentPlantTooltipFlexbox = doc.querySelector(
        'div.QuinoaUI > div.McFlex:nth-of-type(2) > div.McGrid > div.McFlex:nth-of-type(3) > :first-child > :last-child p'
    )?.parentElement;

    if (!currentPlantTooltipFlexbox) {
        // Try alternative selectors
        const altSelectors = [
            'div.QuinoaUI .McFlex .McGrid',
            '[class*="tooltip"] [class*="flex"]',
            'div[class*="plant"] div[class*="info"]',
            '.McFlex .McGrid .McFlex',
            'div.QuinoaUI div.McFlex div.McGrid'
        ];
        for (const sel of altSelectors) {
            const el = doc.querySelector(sel);
            if (el) {
                currentPlantTooltipFlexbox = el;
                break;
            }
        }
        if (!currentPlantTooltipFlexbox) {
            return;
        }
    }

    // Try multiple ways to get current crop/egg
    let currentCrop = targetWindow.currentCrop || UnifiedState.atoms.currentCrop;
    let currentEgg = targetWindow.currentEgg || UnifiedState.atoms.currentEgg;

    // FALLBACK: Try to get from game state directly
    if (!currentCrop && !currentEgg) {
        // Try different possible locations
        const possibleLocations = [
            targetWindow.gameState?.currentCrop,
            targetWindow.gameState?.currentEgg,
            targetWindow.UnifiedState?.atoms?.currentCrop,
            targetWindow.garden?.currentTile?.crop,
            targetWindow.playerState?.standingOn?.crop,
            targetWindow.jotaiAtomCache?.get?.('/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom')?.debugValue
        ];

        for (const loc of possibleLocations) {
            if (loc) {
                currentCrop = Array.isArray(loc) ? loc : [loc];
                break;
            }
        }

        // ULTIMATE FALLBACK: Parse the tooltip DOM itself since game is rendering it
        if (!currentCrop && !currentEgg && currentPlantTooltipFlexbox) {
            const tooltipText = currentPlantTooltipFlexbox.textContent || '';

            // Look for egg species names (Common Egg, Rare Egg, etc.)
            // FIXED: Changed "Mythic" to "Mythical", added "Uncommon", removed non-existent "Epic" and "Special"
            const eggPattern = /(Common|Uncommon|Rare|Legendary|Mythical)\s*Egg/i;
            const eggMatch = tooltipText.match(eggPattern);

            if (eggMatch) {
                const eggSpecies = eggMatch[0].replace(/\s+/g, '');
                currentCrop = [{
                    species: eggSpecies,
                    type: 'egg',
                    category: 'egg',
                    isEgg: true
                }];
            } else {
                // Try to find crop species (Carrot, Wheat, etc.)
                const cropPatterns = [
                    /Carrot/i, /Wheat/i, /Corn/i, /Tomato/i, /Potato/i,
                    /Pumpkin/i, /Watermelon/i, /Strawberry/i, /Blueberry/i,
                    /Rose/i, /Tulip/i, /Sunflower/i, /Daisy/i, /Lily/i
                ];

                for (const pattern of cropPatterns) {
                    const cropMatch = tooltipText.match(pattern);
                    if (cropMatch) {
                        currentCrop = [{
                            species: cropMatch[0],
                            type: 'crop',
                            category: 'plant'
                        }];
                        break;
                    }
                }
            }
        }
    }

    // Check if we're looking at an egg (multiple ways)
    const isPlantedEgg1 = currentCrop?.[0]?.species?.endsWith('Egg');
    const isPlantedEgg2 = currentCrop?.[0]?.species?.includes('Egg');
    const isPlantedEgg3 = currentCrop?.[0]?.type === 'egg';
    const isPlantedEgg4 = currentCrop?.[0]?.category === 'egg';

    const isPlantedEgg = isPlantedEgg1 || isPlantedEgg2 || isPlantedEgg3 || isPlantedEgg4;
    const isEgg = currentEgg || isPlantedEgg;

    if (isEgg) {
        // Handle egg timer with actual calculations
        const activePets = targetWindow.activePets || UnifiedState.atoms.activePets;
        const eggExpectations = getEggExpectations(activePets);

        // CRITICAL: Find the ACTUAL time element in the tooltip (same way as crops)
        const timeElement = [...currentPlantTooltipFlexbox.childNodes].find((el) =>
            /^\d+h(?: \d+m)?(?: \d+s)?$|^\d+m(?: \d+s)?$|^\d+s$/.test(
                (el.textContent || '').trim()
            )
        );

        if (!timeElement) {
            return;
        }

        const timeText = timeElement.textContent.trim();

        // Parse the actual remaining time from tooltip
        const timeMatch = timeText.match(/(?:(\d+)h)?\s*(?:(\d+)m)?\s*(?:(\d+)s)?/);
        if (!timeMatch) {
            return;
        }

        const hours = parseInt(timeMatch[1] || '0', 10);
        const minutes = parseInt(timeMatch[2] || '0', 10);
        const seconds = parseInt(timeMatch[3] || '0', 10);

        // Convert to total seconds
        const totalSeconds = (hours * 3600) + (minutes * 60) + seconds;

        if (totalSeconds <= 0) {
            return;
        }

        if (eggExpectations && eggExpectations.expectedMinutesRemoved > 0) {
            // Calculate boosted time
            const remainingRealMinutes = totalSeconds / 60;
            const effectiveRate = eggExpectations.expectedMinutesRemoved + 1;
            const boostedRealMinutes = remainingRealMinutes / effectiveRate;
            const boostedTotalSeconds = boostedRealMinutes * 60;

            const boostedHours = Math.floor(boostedTotalSeconds / 3600);
            const boostedMinutes = Math.floor((boostedTotalSeconds % 3600) / 60);
            const boostedSeconds = Math.floor(boostedTotalSeconds % 60);

            const eggEstimateEl = doc.createElement("p");
            eggEstimateEl.dataset.turtletimerEstimate = "true";

            // Format output similar to crop timer
            if (boostedHours > 0) {
                eggEstimateEl.textContent = `ü•ö Egg: ${boostedHours}h ${boostedMinutes}m`;
            } else {
                eggEstimateEl.textContent = `ü•ö Egg: ${boostedMinutes}m ${boostedSeconds}s`;
            }

            eggEstimateEl.style.color = '#fbbf24'; // Yellow color
            currentPlantTooltipFlexbox.appendChild(eggEstimateEl);
        }
        return;
    }

    if (!currentCrop || currentCrop.length === 0) return;

    const currentSlotIndex = getCurrentSlotIndex(currentCrop);

    // Find time element (for growing crops)
    const timeElement = [...currentPlantTooltipFlexbox.childNodes].find((el) =>
        /^\d+h(?: \d+m)?(?: \d+s)?$|^\d+m(?: \d+s)?$|^\d+s$/.test(
            (el.textContent || '').trim()
        )
    );

    // Show turtle estimate if there's a time element and crop is growing
    if (timeElement) {
        const activePets = targetWindow.activePets || UnifiedState.atoms.activePets;

        // Get the current slot index for turtle timer
        const slotIndex = getCurrentSlotIndex(currentCrop);
        const sortedIndices = UnifiedState.atoms.sortedSlotIndices || window.sortedSlotIndices;
        let actualSlotIndex = slotIndex;

        if (sortedIndices && Array.isArray(sortedIndices) && sortedIndices.length > 0 && slotIndex < sortedIndices.length) {
            actualSlotIndex = sortedIndices[slotIndex];
        }

        // Pass the actual slot index to estimate function
        const estimate = estimateUntilLatestCrop(currentCrop, activePets, actualSlotIndex);

        if (estimate) {
            const estimateEl = doc.createElement("p");
            estimateEl.dataset.turtletimerEstimate = "true";
            estimateEl.textContent = estimate;
            estimateEl.style.color = '#4ade80'; // Green-400 color
            currentPlantTooltipFlexbox.appendChild(estimateEl);
        }
    }

    // Show current slot value
    const slotValue = calculateCurrentSlotValue(currentCrop);
    if (slotValue > 0) {
        const slotValueEl = doc.createElement("p");
        slotValueEl.dataset.turtletimerSlotValue = "true";
        slotValueEl.innerHTML = `<img src="https://cdn.discordapp.com/emojis/1425389207525920808.webp?size=96" style="width: 14px; height: 14px; vertical-align: middle; margin-right: 2px; display: inline-block;">` + Number(slotValue).toLocaleString();
        currentPlantTooltipFlexbox.appendChild(slotValueEl);
    }
}


      // Track current slot index for multi-harvest crops
      // Updated ONLY when cycling (X/C keys) in handleTooltipChange()
      // CRITICAL: Must be on window object to be accessible from both scopes
      if (typeof window._mgtools_currentSlotIndex === 'undefined') {
          window._mgtools_currentSlotIndex = 0;
      }

      function getCurrentSlotIndex(currentCrop) {
          if (!currentCrop || currentCrop.length <= 1) return 0;
          return window._mgtools_currentSlotIndex || 0;
      }

      function calculateCurrentSlotValue(currentCrop) {
          if (!currentCrop || currentCrop.length === 0) return 0;

          const friendBonus = UnifiedState.atoms.friendBonus || 1;
          let slotIndex = getCurrentSlotIndex(currentCrop);

          // If we have sorted indices, use them to get the actual slot
          const sortedIndices = UnifiedState.atoms.sortedSlotIndices || window.sortedSlotIndices;
          let actualSlotIndex = slotIndex;

          if (sortedIndices && Array.isArray(sortedIndices) && sortedIndices.length > 0) {
              // The window._mgtools_currentSlotIndex is the position in the sorted array
              // The value at that position is the actual slot index in currentCrop
              if (slotIndex < sortedIndices.length) {
                  actualSlotIndex = sortedIndices[slotIndex];
                  console.log(`üîÑ [CROP-VALUE] Using sorted index: position ${slotIndex} ‚Üí actual slot ${actualSlotIndex}`);
              }
          }

          // Debug logging
          console.log(`üìä [CROP-VALUE] Calculating value for slot ${actualSlotIndex}/${currentCrop.length}`, {
              displayIndex: slotIndex,
              actualSlotIndex,
              cropCount: currentCrop.length,
              windowIndex: window._mgtools_currentSlotIndex,
              sortedIndices
          });

          // Validate slot index
          if (actualSlotIndex < 0 || actualSlotIndex >= currentCrop.length) {
              console.error(`[CROP-VALUE] Invalid slot index: ${actualSlotIndex} for crop array length: ${currentCrop.length}`);
              window._mgtools_currentSlotIndex = 0; // Reset to safe value
              return 0;
          }

          const slot = currentCrop[actualSlotIndex];
          if (!slot || !slot.species) {
              console.log(`[CROP-VALUE] No species at slot ${actualSlotIndex}`, slot);
              return 0;
          }

          const multiplier = calculateMutationMultiplier(slot.mutations);
          const speciesVal = speciesValues[slot.species] || 0;
          const scale = slot.targetScale || 1;
          const value = Math.round(multiplier * speciesVal * scale * friendBonus);

          // Always log for debugging the issue
          console.log(`üí∞ [CROP-VALUE] Slot ${actualSlotIndex}/${currentCrop.length}: ${slot.species} = ${value.toLocaleString()}`, {
              species: slot.species,
              speciesVal,
              multiplier,
              scale,
              friendBonus,
              value
          });

          return value;
      }
  
      // Hook currentCrop atom for turtle timer
      
function initializeTurtleTimer() {
    console.log('üê¢üê¢üê¢ [TURTLE-TIMER-START] initializeTurtleTimer() called!');
    productionLog('üê¢ [TURTLE-TIMER] Initializing crop growth estimate...');

    // Start listening to slot index changes
    listenToSlotIndexAtom();

    // Also hook the sorted slot indices atom for proper order tracking
    hookAtom(
        "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentSortedGrowSlotIndicesAtom",
        "sortedSlotIndices",
        (value) => {
            return value;
        }
    );

    // Hook currentCrop atom
    hookAtom(
        "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom",
        "currentCrop",
        (value) => {
            // CRITICAL: Extract the actual crop data from the atom value
            // The atom might return {garden: {tileObjects: [...]}} not just the crop array
            let cropData = null;
            if (value?.garden?.tileObjects) {
                cropData = value.garden.tileObjects;
            } else if (Array.isArray(value)) {
                cropData = value;
            }

            // Store the extracted crop data
            UnifiedState.atoms.currentCrop = cropData;
            targetWindow.currentCrop = cropData;

            const currentHash = getCropHash(cropData || value);

            if (currentHash !== globalThis.prevCropHash) {
                globalThis.prevCropHash = currentHash;

                // Update estimate when crop changes
                requestAnimationFrame(() => insertTurtleEstimate());
            }

            return value; // Return original value to game
        }
    );

    const doc = targetDocument;

    // Also poll while player is on a tile to catch any missed updates
    setInterval(() => {
        let currentCrop = targetWindow.currentCrop || UnifiedState.atoms.currentCrop;
        let currentEgg = targetWindow.currentEgg || UnifiedState.atoms.currentEgg;

        // Try to find crop data manually - DIRECT ATOM READING
        let manualCrop = null;
        if (!currentCrop) {
            // Step 1: Find Jotai store if not already found
            if (!targetWindow.__foundJotaiStore) {
                const possibleStores = [
                    targetWindow.jotaiStore,
                    targetWindow.__JOTAI_STORE__,
                    targetWindow.store,
                    targetWindow.getDefaultStore?.(),
                    targetWindow.globalStore,
                    targetWindow.__jotaiStore,
                    targetWindow._jotaiStore
                ];

                for (const store of possibleStores) {
                    // Make sure it's NOT cookieStore (browser API)
                    // And verify it looks like a Jotai store (has sub/unsub or set methods)
                    if (store &&
                        typeof store.get === 'function' &&
                        store !== targetWindow.cookieStore &&
                        store !== window.cookieStore &&
                        (typeof store.set === 'function' || typeof store.sub === 'function')) {
                        targetWindow.__foundJotaiStore = store;
                        break;
                    }
                }

                // If still not found, explore window properties
                if (!targetWindow.__foundJotaiStore) {
                    const storeKeys = Object.keys(targetWindow).filter(k =>
                        k.toLowerCase().includes('store') ||
                        k.toLowerCase().includes('jotai')
                    );

                    for (const key of storeKeys) {
                        const val = targetWindow[key];
                        if (val &&
                            typeof val === 'object' &&
                            typeof val.get === 'function' &&
                            val !== targetWindow.cookieStore &&
                            val !== window.cookieStore &&
                            (typeof val.set === 'function' || typeof val.sub === 'function')) {
                            targetWindow.__foundJotaiStore = val;
                            break;
                        }
                    }

                    // ENHANCED: Explore jotaiAtomCache itself for store reference
                    if (!targetWindow.__foundJotaiStore && targetWindow.jotaiAtomCache) {
                        const cache = targetWindow.jotaiAtomCache;

                        // Check if cache has store property
                        if (cache.store) {
                            targetWindow.__foundJotaiStore = cache.store;
                        } else if (cache.cache && cache.cache.store) {
                            targetWindow.__foundJotaiStore = cache.cache.store;
                        }
                    }
                }
            }

            // Step 2: Try to read atom using the store
            const atomCache = targetWindow.jotaiAtomCache?.cache || targetWindow.jotaiAtomCache;
            if (atomCache && atomCache.get) {
                const cropAtom = atomCache.get("/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom");

                if (cropAtom) {
                    // Try to read using found store
                    if (targetWindow.__foundJotaiStore) {
                        try {
                            const cropValue = targetWindow.__foundJotaiStore.get(cropAtom);

                            // Handle if it's a Promise
                            if (cropValue && typeof cropValue.then === 'function') {
                                cropValue.then(val => {
                                    targetWindow.currentCrop = val;
                                    UnifiedState.atoms.currentCrop = val;

                                    // Trigger update
                                    if (val && !document.querySelector('[data-turtletimer-estimate="true"]')) {
                                        insertTurtleEstimate();
                                    }
                                }).catch(e => {
                                    // Promise rejected
                                });
                            } else {
                                manualCrop = cropValue;

                                // Store it for next time
                                targetWindow.currentCrop = cropValue;
                                UnifiedState.atoms.currentCrop = cropValue;
                            }
                        } catch (e) {
                            // Error reading atom from store
                        }
                    }

                    // Fallback: try debugValue
                    if (!manualCrop && cropAtom.debugValue !== undefined) {
                        manualCrop = cropAtom.debugValue;
                    }

                    // ENHANCED: Try calling atom.read directly if it exists
                    if (!manualCrop && typeof cropAtom.read === 'function') {
                        try {
                            const mockGetter = (a) => {
                                if (a === cropAtom && cropAtom.init !== undefined) {
                                    return cropAtom.init;
                                }
                                return undefined;
                            };
                            const directValue = cropAtom.read(mockGetter);
                            if (directValue && typeof directValue.then !== 'function') {
                                manualCrop = directValue;
                            }
                        } catch (e) {
                            // Failed to call atom.read()
                        }
                    }
                }
            }
        }

        // Update currentCrop if we found something manually
        if (manualCrop && !currentCrop) {
            currentCrop = manualCrop;
        }

        // Check if tooltip is visible (player might be standing on something)
        const doc = targetDocument || document;
        const tooltipVisible = doc.querySelector('div.QuinoaUI > div.McFlex:nth-of-type(2) > div.McGrid');

        // If player is standing on something (has crop/egg data OR tooltip is visible), ensure estimate is shown
        if (currentCrop || currentEgg || tooltipVisible) {
            const hasExisting = doc.querySelector('[data-turtletimer-estimate="true"], [data-turtletimer-slot-value="true"]');
            if (!hasExisting) {
                insertTurtleEstimate();
            }
        }
    }, 1000); // Check every second

    // Predicate: check if keypress is as movement key
    const isMovementKeypress = (e) =>
        !e.ctrlKey &&
        !e.shiftKey &&
        [
        'KeyW',
        'KeyA',
        'KeyS',
        'KeyD',
        'ArrowUp',
        'ArrowDown',
        'ArrowLeft',
        'ArrowRight',
        ].includes(e.code);

    // Curried helper: takes a handler and runs it only if it's a movement key
    const onMovementKey = (handler) => (e) => {
        if (isMovementKeypress(e)) handler(e);
    };

    // Remove turtle timer hints on movement key down
    doc.addEventListener(
        'keydown',
        onMovementKey(() => {
        doc
            .querySelectorAll(
                '[data-turtletimer-estimate="true"], [data-turtletimer-slot-value="true"]'
            )
            .forEach((el) => el.remove());
        })
    );

    // Insert turtle estimate on movement key up
    doc.addEventListener(
        'keyup',
        onMovementKey(() => {
            insertTurtleEstimate();
        })
    );

    // Slot index tracking is now handled by listenToSlotIndexAtom()
    // which directly listens to the game's myCurrentGrowSlotIndex atom

    productionLog('‚úÖ [TURTLE-TIMER] Turtle timer initialized successfully');

    // Expose a debug function to manually check - make it available in page context
    const debugCropDetectionFunc = function() {
        console.log('=== MANUAL CROP DETECTION DEBUG ===');

        // Check atom cache
        const atomCache = (typeof unsafeWindow !== 'undefined' ? unsafeWindow : window).jotaiAtomCache?.cache ||
                          (typeof unsafeWindow !== 'undefined' ? unsafeWindow : window).jotaiAtomCache;
        console.log('atomCache exists:', !!atomCache);

        if (atomCache && atomCache.get) {
            console.log('Atom cache entries count:', atomCache.size || 'unknown');

            // Look for crop-related atoms
            try {
                const allKeys = Array.from(atomCache.keys ? atomCache.keys() : []);
                console.log('Total atoms:', allKeys.length);

                const cropAtoms = allKeys.filter(k =>
                    k.includes('Crop') || k.includes('crop') || k.includes('Grow') || k.includes('Egg')
                );
                console.log('Crop-related atoms:', cropAtoms);

                // Try to read the current crop atom
                const atom = atomCache.get("/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myCurrentGrowSlotsAtom");
                console.log('Current crop atom:', atom);

                if (atom) {
                    console.log('Atom properties:', Object.keys(atom));
                    console.log('Atom.debugValue:', atom.debugValue);
                    console.log('Atom.init:', atom.init);

                    // Try to find store and read it
                    const tw = typeof unsafeWindow !== 'undefined' ? unsafeWindow : window;
                    if (tw.__foundJotaiStore) {
                        console.log('Found store, trying to read...');
                        try {
                            const val = tw.__foundJotaiStore.get(atom);
                            console.log('‚úÖ Store.get(atom) returned:', val);
                        } catch (e) {
                            console.log('‚ùå Error reading from store:', e);
                        }
                    } else {
                        console.log('‚ö†Ô∏è No Jotai store found yet');
                    }
                }
            } catch (e) {
                console.log('Error exploring atoms:', e);
            }
        }

        // Force call insertTurtleEstimate
        console.log('Calling insertTurtleEstimate()...');
        if (typeof insertTurtleEstimate === 'function') {
            insertTurtleEstimate();
        } else {
            console.log('‚ùå insertTurtleEstimate not available in this context');
        }
    };

    // Attach to multiple contexts
    try {
        window.debugCropDetection = debugCropDetectionFunc;
        if (typeof unsafeWindow !== 'undefined' && unsafeWindow !== window) {
            unsafeWindow.debugCropDetection = debugCropDetectionFunc;
        }
        targetWindow.debugCropDetection = debugCropDetectionFunc;

        console.log('üí° TIP: Run window.debugCropDetection() in console to debug crop detection');
        console.log('üí° Available in:', typeof unsafeWindow !== 'undefined' ? 'window, unsafeWindow, targetWindow' : 'window, targetWindow');
    } catch (e) {
        console.log('‚ö†Ô∏è Could not attach debugCropDetection:', e);
    }
}

  
      function loadSavedData() {
          // PERSISTENCE GUARD v3.6.6: Initialize guard to prevent premature saves during initialization
          window.MGA_PERSISTENCE_GUARD = {
              initializationSavesBlocked: true,
              finalSaveLocation: 23480,
              warningMessage: '‚ö†Ô∏è BLOCKED: Premature save during initialization detected! Only final save at line ~23480 is allowed.'
          };
          productionLog('üõ°Ô∏è [PERSISTENCE-GUARD] Initialized - blocking premature saves during initialization');

          // Enhanced storage diagnostics
          productionLog('üì¶ [STORAGE] Starting comprehensive data loading with diagnostics...');
  
          // ==================== DATA MIGRATION ====================
          // CRITICAL: Migrate existing localStorage data to GM storage before loading
          productionLog('üîÑ [STORAGE] Checking for data migration needs...');
          try {
              // MGA_migrateFromLocalStorage();
          } catch (migrationError) {
              console.error('‚ùå [MIGRATION] Migration failed, but continuing with initialization:', migrationError);
          }
  
          // Verify UnifiedState.data exists and is properly initialized
          if (!UnifiedState.data) {
              console.error('‚ùå [CRITICAL] UnifiedState.data is not initialized!');
              UnifiedState.data = {};
          }
          productionLog('‚úÖ [STORAGE] UnifiedState.data initialized:', typeof UnifiedState.data);
  
          // Storage availability check (lightweight version - removed blocking I/O test)
          productionLog('üìä [STORAGE-DIAGNOSTICS] Basic localStorage info:', {
              available: typeof localStorage !== 'undefined',
              totalItems: localStorage.length,
              mgaKeys: Object.keys(localStorage).filter(k => k.startsWith('MGA_'))
          });
  
          // Load pet presets with enhanced debugging
          productionLog('üì¶ [STORAGE] Loading pet presets...');
          const rawPresets = localStorage.getItem('MGA_petPresets');
          productionLog('üì¶ [STORAGE] Raw pet presets from localStorage:', rawPresets ? rawPresets.substring(0, 200) + '...' : 'null');
  
          UnifiedState.data.petPresets = MGA_loadJSON('MGA_petPresets', {});
          productionLog('üì¶ [STORAGE] Loading pet presets, found:', Object.keys(UnifiedState.data.petPresets).length);
          productionLog('üîç [STORAGE-DEBUG] Pet presets type check:', typeof UnifiedState.data.petPresets, 'keys:', Object.keys(UnifiedState.data.petPresets || {}));
  
          // Load pet presets order (for reordering feature)
          UnifiedState.data.petPresetsOrder = MGA_loadJSON('MGA_petPresetsOrder', []);
          ensurePresetOrder(); // Initialize order if needed
          productionLog('üì¶ [STORAGE] Pet presets order initialized:', UnifiedState.data.petPresetsOrder.length, 'items');
  
          // Verify presets loaded correctly
          if (Object.keys(UnifiedState.data.petPresets).length > 0) {
              productionLog('‚úÖ [STORAGE-VERIFY] Pet presets loaded successfully:', Object.keys(UnifiedState.data.petPresets));
          } else {
              productionWarn('‚ö†Ô∏è [STORAGE-VERIFY] No pet presets found in storage');
              productionLog('   localStorage check:', localStorage.getItem('MGA_petPresets') ? 'Data exists' : 'No data');
  
              // Enhanced debugging - try to parse the raw data manually
              const rawData = localStorage.getItem('MGA_petPresets');
              if (rawData) {
                  productionLog('   Raw data length:', rawData.length);
                  productionLog('   Raw data preview:', rawData.substring(0, 100));
                  try {
                      const parsed = JSON.parse(rawData);
                      productionLog('   Manual parse successful:', typeof parsed, Object.keys(parsed || {}));
                      console.error('‚ùå [STORAGE-ERROR] Data exists and parses correctly, but MGA_loadJSON failed!');
                  } catch (parseError) {
                      console.error('‚ùå [STORAGE-ERROR] JSON parse error:', parseError.message);
                      productionLog('   Corrupted data - will be cleared on next save');
                  }
              }
          }
  
          // Check if logs were manually cleared - if so, keep them empty
          const clearFlag = localStorage.getItem('MGA_logs_manually_cleared') ||
                            (typeof GM_getValue !== 'undefined' ? GM_getValue('MGA_logs_manually_cleared', null) : null);
          const clearSession = localStorage.getItem('MGA_logs_clear_session');

          // If cleared within last 24 hours, stay empty and skip ALL loading
          if (clearFlag && clearSession) {
              const clearTime = parseInt(clearFlag, 10);
              const sessionTime = parseInt(clearSession, 10);

              // 24-hour session lock: If cleared within last 24 hours, respect the clear
              if (Date.now() - clearTime < 86400000) {
                  productionLog('‚úÖ [ABILITY-LOGS] Respecting manual clear - logs remain empty (session lock active)');
                  UnifiedState.data.petAbilityLogs = [];
                  // Skip all loading including archive - jump to after load section
                  // Return statement won't work here, so we use a flag
                  var skipLogLoading = true;
              } else {
                  // Session expired - clear the flags and allow normal loading
                  localStorage.removeItem('MGA_logs_manually_cleared');
                  localStorage.removeItem('MGA_logs_clear_session');
                  try {
                      if (typeof GM_deleteValue !== 'undefined') {
                          GM_deleteValue('MGA_logs_manually_cleared');
                      }
                  } catch(e) {}
                  logDebug('STORAGE', '‚è∞ Clear session expired (>24h) - resuming normal log loading');
                  var skipLogLoading = false;
              }
          } else {
              var skipLogLoading = false;
          }

          const wasManuallyCleared = skipLogLoading;
          logDebug('STORAGE', 'Loading ability logs:', {
              wasManuallyCleared,
              clearFlag: clearFlag,
              clearSession: clearSession,
              skipLogLoading: skipLogLoading
          });

          if (skipLogLoading) {
              // Logs were manually cleared recently - keeping empty
              logDebug('STORAGE', 'Logs were manually cleared recently - keeping empty');
              // Skip to after the loading section
          } else {
              // ENHANCED: Check all storage sources to see where logs will come from
              const gmRaw = typeof GM_getValue !== 'undefined' ? GM_getValue('MGA_petAbilityLogs', null) : null;
              const lsRaw = window.localStorage?.getItem('MGA_petAbilityLogs');
              const tgRaw = (typeof targetWindow !== 'undefined' && targetWindow && targetWindow !== window)
                  ? targetWindow.localStorage?.getItem('MGA_petAbilityLogs')
                  : null;
  
              // Count logs in each source
              const countLogs = (raw) => {
                  if (!raw) return 0;
                  try {
                      const parsed = typeof raw === 'string' ? JSON.parse(raw) : raw;
                      return Array.isArray(parsed) ? parsed.length : 0;
                  } catch (e) {
                      return 0;
                  }
              };
  
              const gmCount = countLogs(gmRaw);
              const lsCount = countLogs(lsRaw);
              const tgCount = countLogs(tgRaw);
  
              logDebug('STORAGE', 'üîç Ability log source analysis:', {
                  gmStorage: gmCount > 0 ? `${gmCount} logs` : 'empty',
                  windowLocalStorage: lsCount > 0 ? `${lsCount} logs` : 'empty',
                  targetLocalStorage: tgCount > 0 ? `${tgCount} logs` : 'empty',
                  willChoose: gmCount >= lsCount && gmCount >= tgCount ? 'GM' : (lsCount >= tgCount ? 'window.localStorage' : 'targetWindow.localStorage')
              });
  
              const loadedLogs = MGA_loadJSON('MGA_petAbilityLogs', []);
              UnifiedState.data.petAbilityLogs = loadedLogs;
  
              logDebug('STORAGE', '‚úÖ Loaded main logs:', {
                  count: loadedLogs.length,
                  sample: loadedLogs.slice(0, 3).map(l => ({ ability: l.abilityType, time: new Date(l.timestamp).toLocaleTimeString() }))
              });
  
              // DIAGNOSTIC: If logs appeared from nowhere after clear, log a warning
              if (loadedLogs.length > 0 && (gmCount > 0 || lsCount > 0 || tgCount > 0)) {
                  const sources = [];
                  if (gmCount > 0) sources.push(`GM:${gmCount}`);
                  if (lsCount > 0) sources.push(`LS:${lsCount}`);
                  if (tgCount > 0) sources.push(`TG:${tgCount}`);
                  logDebug('STORAGE', `üìç Logs restored from: ${sources.join(', ')}`);
              }
          }
  
          // BUGFIX: One-time migration - normalize old "Produce Scale Boost" ability names to "Crop Size Boost"
          // BUGFIX: Normalize malformed ability names (e.g., "Seed FinderII" ‚Üí "Seed Finder II")
          // This fixes "lost logs" issue when game renamed the ability or had typos
          let migrationNeeded = false;
          let normalizationNeeded = false;
          UnifiedState.data.petAbilityLogs = UnifiedState.data.petAbilityLogs.map(log => {
              let updatedLog = { ...log };
              let wasUpdated = false;
  
              // Migration 1: Produce Scale Boost ‚Üí Crop Size Boost
              if (updatedLog.abilityType && /produce\s*scale\s*boost/i.test(updatedLog.abilityType)) {
                  migrationNeeded = true;
                  wasUpdated = true;
                  updatedLog.abilityType = updatedLog.abilityType.replace(/produce\s*scale\s*boost/gi, 'Crop Size Boost');
              }
  
              // Migration 2: Normalize ability names (fix missing spaces before roman numerals)
              if (updatedLog.abilityType) {
                  const normalized = normalizeAbilityName(updatedLog.abilityType);
                  if (normalized !== updatedLog.abilityType) {
                      normalizationNeeded = true;
                      wasUpdated = true;
                      logDebug('STORAGE', `üìù Normalizing ability name: "${updatedLog.abilityType}" ‚Üí "${normalized}"`);
                      updatedLog.abilityType = normalized;
                  }
              }
  
              return updatedLog;
          });
  
          // Also migrate archived logs (BUT skip if logs were manually cleared)
          const archivedLogs = wasManuallyCleared ? [] : MGA_loadJSON('MGA_petAbilityLogs_archive', []);
          logDebug('STORAGE', 'Archive logs:', {
              skippedDueToClear: wasManuallyCleared,
              count: archivedLogs.length,
              logs: archivedLogs.slice(0, 5).map(l => ({ ability: l.abilityType, time: new Date(l.timestamp).toLocaleTimeString() }))
          });
  
          let archivedMigrationNeeded = false;
          let archivedNormalizationNeeded = false;
          const migratedArchive = archivedLogs.map(log => {
              let updatedLog = { ...log };
              let wasUpdated = false;
  
              // Migration 1: Produce Scale Boost ‚Üí Crop Size Boost
              if (updatedLog.abilityType && /produce\s*scale\s*boost/i.test(updatedLog.abilityType)) {
                  archivedMigrationNeeded = true;
                  wasUpdated = true;
                  updatedLog.abilityType = updatedLog.abilityType.replace(/produce\s*scale\s*boost/gi, 'Crop Size Boost');
              }
  
              // Migration 2: Normalize ability names
              if (updatedLog.abilityType) {
                  const normalized = normalizeAbilityName(updatedLog.abilityType);
                  if (normalized !== updatedLog.abilityType) {
                      archivedNormalizationNeeded = true;
                      wasUpdated = true;
                      updatedLog.abilityType = normalized;
                  }
              }
  
              return updatedLog;
          });
  
          // Save if any migrations/normalizations occurred
          if (migrationNeeded || normalizationNeeded) {
              MGA_saveJSON('MGA_petAbilityLogs', UnifiedState.data.petAbilityLogs);
              if (migrationNeeded && normalizationNeeded) {
                  productionLog('‚úÖ [MIGRATION] Migrated "Produce Scale Boost" and normalized malformed ability names');
              } else if (migrationNeeded) {
                  productionLog('‚úÖ [MIGRATION] Migrated old "Produce Scale Boost" logs to "Crop Size Boost"');
              } else if (normalizationNeeded) {
                  productionLog('‚úÖ [MIGRATION] Normalized malformed ability names (fixed missing spaces before roman numerals)');
              }
          }
  
          if (archivedMigrationNeeded || archivedNormalizationNeeded) {
              MGA_saveJSON('MGA_petAbilityLogs_archive', migratedArchive);
              if (archivedMigrationNeeded && archivedNormalizationNeeded) {
                  productionLog('‚úÖ [MIGRATION] Migrated and normalized archived ability logs');
              } else if (archivedMigrationNeeded) {
                  productionLog('‚úÖ [MIGRATION] Migrated archived "Produce Scale Boost" logs to "Crop Size Boost"');
              } else if (archivedNormalizationNeeded) {
                  productionLog('‚úÖ [MIGRATION] Normalized archived malformed ability names');
              }
          }
  
          // NOW clear the manual clear flag (after we've used it for both main and archive)
          if (wasManuallyCleared) {
              // Sticky clear: do not remove here; will be cleared on first new log add.
  }
  
          productionLog('üì¶ [STORAGE] Loading pet ability logs, found:', UnifiedState.data.petAbilityLogs.length, 'entries');
  
          // Check if mainscript.txt pet ability logging is active
          if (window.petAbilityLogs && Array.isArray(window.petAbilityLogs)) {
              productionLog('üìù [COMPAT] Detected mainscript.txt pet ability logging system with', window.petAbilityLogs.length, 'entries');
              productionLog('üìù [COMPAT] Both systems will run independently with separate storage');
          }
          // BUGFIX: Load from MGA_data instead of MGA_settings (saves use MGA_data)
          // Always load from MGA_data first (this is where we save)
          const loadedData = MGA_loadJSON('MGA_data', null);

          // CRITICAL: Verify loaded data integrity before using
          if (loadedData && typeof loadedData === 'object') {
              productionLog('üì¶ [STORAGE-INTEGRITY] Loaded data structure:', {
                  hasSettings: !!loadedData.settings,
                  hasCustomRooms: !!loadedData.customRooms,
                  hasSeedsToDelete: !!loadedData.seedsToDelete,
                  hasLockedCrops: !!loadedData.lockedCrops,
                  topLevelKeys: Object.keys(loadedData),
                  settingsKeys: loadedData.settings ? Object.keys(loadedData.settings).length : 0
              });
          } else {
              productionLog('‚ö†Ô∏è [STORAGE-INTEGRITY] No valid saved data found - will use defaults');
          }

          if (loadedData && loadedData.settings) {
              // If MGA_data exists, use it (this is where saves go)
              UnifiedState.data.settings = loadedData.settings;
              productionLog('üì¶ [STORAGE] Loaded settings from MGA_data');
          } else {
              // Try legacy MGA_settings for migration
              const legacySettings = MGA_loadJSON('MGA_settings', null);
              if (legacySettings) {
                  UnifiedState.data.settings = legacySettings;
                  // Migration will be saved at the end of loadSavedData (line ~23444)
                  productionLog('üì¶ [STORAGE] Migrated settings from MGA_settings to MGA_data (will save at end of init)');
              } else {
                  // Use COMPLETE defaults for first run (must match full structure from lines 2074-2115)
                  UnifiedState.data.settings = {
                      opacity: 95,
                      popoutOpacity: 50,
                      theme: 'default',
                      gradientStyle: 'blue-purple',
                      effectStyle: 'none',
                      compactMode: false,
                      ultraCompactMode: false,
                      useInGameOverlays: true,
                      debugMode: false,
                      hideWeather: false,
                      notifications: {
                          enabled: true,
                          volume: 0.3,
                          notificationType: 'epic',
                          requiresAcknowledgment: false,
                          continuousEnabled: false,
                          watchedSeeds: ["Carrot", "Sunflower", "Moonbinder", "Dawnbinder", "Starweaver"],
                          watchedEggs: ["CommonEgg", "MythicalEgg"],
                          watchedDecor: [],
                          petHungerEnabled: false,
                          petHungerThreshold: 25,
                          petHungerSound: 'double',
                          abilityNotificationsEnabled: false,
                          watchedAbilities: [],
                          watchedAbilityCategories: {
                              xpBoost: true,
                              cropSizeBoost: true,
                              selling: true,
                              harvesting: true,
                              growthSpeed: true,
                              specialMutations: true,
                              other: true
                          },
                          abilityNotificationSound: 'single',
                          abilityNotificationVolume: 0.2,
                          weatherNotificationsEnabled: false,
                          watchedWeatherEvents: ['Snow', 'Rain', 'AmberMoon', 'Dawn'],
                          shopFirebaseEnabled: false,
                          lastSeenTimestamps: {}
                      },
                      detailedTimestamps: true,
                      autoFavorite: {
                          enabled: false,
                          species: [],
                          mutations: []
                      }
                  };
                  productionLog('üì¶ [STORAGE] Using complete default settings (first run - will save at end of init)');
                  // Defaults will be saved at the end of loadSavedData (line ~23444)
              }
          }
  
          // Ensure notifications object exists and has all required fields
          if (!UnifiedState.data.settings.notifications) {
              UnifiedState.data.settings.notifications = {};
          }
  
          // Set defaults for any missing notification fields
          const notifDefaults = {
              enabled: true,
              volume: 0.3,
              notificationType: 'epic',
              requiresAcknowledgment: false,
              continuousEnabled: false,
              watchedSeeds: ["Carrot", "Sunflower", "Moonbinder", "Dawnbinder", "Starweaver"],
              watchedEggs: ["CommonEgg", "MythicalEgg"],
              petHungerEnabled: false,
              petHungerThreshold: 25,
              petHungerSound: 'double',
              abilityNotificationsEnabled: false,
              watchedAbilities: [],
              watchedAbilityCategories: {
                  xpBoost: true,
                  cropSizeBoost: true,
                  selling: true,
                  harvesting: true,
                  growthSpeed: true,
                  specialMutations: true,
                  other: true
              },
              abilityNotificationSound: 'single',
              abilityNotificationVolume: 0.2,
              weatherNotificationsEnabled: false,
              watchedWeatherEvents: ['Snow', 'Rain', 'AmberMoon', 'Dawn'],
              shopFirebaseEnabled: false,
              lastSeenTimestamps: {}
          };
  
          // Merge defaults with existing settings
          // CRITICAL: Don't override intentionally empty arrays with defaults
          Object.keys(notifDefaults).forEach(key => {
              const currentValue = UnifiedState.data.settings.notifications[key];

              if (currentValue === undefined) {
                  // Only set default if field truly doesn't exist
                  if (Array.isArray(notifDefaults[key])) {
                      // For array fields, check if key exists in saved data
                      if (!(key in UnifiedState.data.settings.notifications)) {
                          UnifiedState.data.settings.notifications[key] = notifDefaults[key];
                          productionLog(`üì¶ [SETTINGS] Initialized ${key} array with defaults (field was missing)`);
                      } else {
                          // Key exists but value is undefined - keep it undefined (user may have cleared it)
                          productionLog(`üì¶ [SETTINGS] Preserved undefined ${key} (intentionally cleared)`);
                      }
                  } else {
                      // Non-array fields just set default
                      UnifiedState.data.settings.notifications[key] = notifDefaults[key];
                  }
              }
          });
  
          // Ensure watchedAbilityCategories exists and has all categories
          if (!UnifiedState.data.settings.notifications.watchedAbilityCategories) {
              UnifiedState.data.settings.notifications.watchedAbilityCategories = notifDefaults.watchedAbilityCategories;
          }
  
          // Ensure detailedTimestamps setting exists
          if (UnifiedState.data.settings.detailedTimestamps === undefined) {
              UnifiedState.data.settings.detailedTimestamps = false;
          }

          // Ensure autoFavorite setting exists (for v3.3.4+)
          if (!UnifiedState.data.settings.autoFavorite) {
              UnifiedState.data.settings.autoFavorite = {
                  enabled: false,
                  species: [],
                  mutations: []
              };
              productionLog('üåü [AUTO-FAVORITE] Initialized auto-favorite settings');
          }
          // Ensure mutations array exists for existing users
          if (!UnifiedState.data.settings.autoFavorite.mutations) {
              UnifiedState.data.settings.autoFavorite.mutations = [];
              productionLog('üåü [AUTO-FAVORITE] Added mutations array to existing settings');
          }

          // Try to restore auto-favorites from backup if primary data is empty
          if (UnifiedState.data.settings.autoFavorite.species.length === 0 &&
              UnifiedState.data.settings.autoFavorite.mutations.length === 0) {
              try {
                  const backup = localStorage.getItem('mgtools_auto_favorites');
                  if (backup) {
                      const parsed = JSON.parse(backup);
                      if (parsed && (parsed.species?.length > 0 || parsed.mutations?.length > 0)) {
                          UnifiedState.data.settings.autoFavorite = parsed;
                          logInfo('AUTO-FAV', 'Restored auto-favorites from localStorage backup', {
                              species: parsed.species?.length || 0,
                              mutations: parsed.mutations?.length || 0
                          });
                      }
                  }
              } catch (e) {
                  // Silent fail - non-critical
                  logDebug('AUTO-FAV', 'Failed to restore from backup', e);
              }
          }

          // Load customRooms from saved data
          if (loadedData && loadedData.customRooms && Array.isArray(loadedData.customRooms) && loadedData.customRooms.length > 0) {
              // Load from saved data
              UnifiedState.data.customRooms = loadedData.customRooms;
              productionLog('üè† [ROOMS] Loaded custom rooms from storage:', UnifiedState.data.customRooms);
          } else {
              // Initialize with defaults (first time only)
              UnifiedState.data.customRooms = [...DEFAULT_ROOMS];

              // Add Discord play rooms if in Discord environment
              if (isDiscordEnvironment()) {
                  UnifiedState.data.customRooms.push(...DISCORD_PLAY_ROOMS);
                  productionLog('üéÆ [ROOMS] Discord environment detected - added Discord play rooms');
              }

              // Custom rooms will be saved at the end of loadSavedData (line ~23444)
              productionLog('üè† [ROOMS] Initialized custom rooms (first time - will save at end of init):', UnifiedState.data.customRooms);
          }
  
          // Load hotkeys data
          const savedHotkeys = MGA_loadJSON('MGA_hotkeys', null);
          if (savedHotkeys) {
              // Merge saved hotkeys with defaults to handle new keys
              UnifiedState.data.hotkeys = {
                  ...UnifiedState.data.hotkeys,
                  ...savedHotkeys,
                  gameKeys: {
                      ...UnifiedState.data.hotkeys.gameKeys,
                      ...savedHotkeys.gameKeys
                  },
                  mgToolsKeys: {
                      ...UnifiedState.data.hotkeys.mgToolsKeys,
                      ...(savedHotkeys.mgToolsKeys || {})
                  }
              };
              productionLog('üéÆ [HOTKEYS] Loaded saved hotkey configuration');
          } else {
              productionLog('üéÆ [HOTKEYS] Using default hotkey configuration');
          }
  
          // Load pet preset hotkeys
          const savedPresetHotkeys = MGA_loadJSON('MGA_petPresetHotkeys', null);
          if (savedPresetHotkeys) {
              UnifiedState.data.petPresetHotkeys = savedPresetHotkeys;
              productionLog('üéÆ [HOTKEYS] Loaded pet preset hotkeys');
          }
  
          // Load PAL4 filter system data
          UnifiedState.data.filterMode = MGA_loadJSON('MGA_filterMode', 'categories');
          UnifiedState.data.abilityFilters = MGA_loadJSON('MGA_abilityFilters', {
              xpBoost: true,
              cropSizeBoost: true,
              selling: true,
              harvesting: true,
              growthSpeed: true,
              specialMutations: true,
              other: true
          });
          UnifiedState.data.customMode = MGA_loadJSON('MGA_customMode', { selectedAbilities: {} });
          UnifiedState.data.petFilters = MGA_loadJSON('MGA_petFilters', { selectedPets: {} });
  
          // Load seed deletion settings from MGA_data (primary) with fallback to legacy keys
          const rawSeedsData = localStorage.getItem('MGA_seedsToDelete');
          const rawAutoDeleteData = localStorage.getItem('MGA_autoDeleteEnabled');

          // Load seeds to delete from MGA_data (primary) with fallback to legacy keys
          if (loadedData && loadedData.seedsToDelete !== undefined) {
              UnifiedState.data.seedsToDelete = loadedData.seedsToDelete;
              productionLog('üì¶ [STORAGE] Loaded seedsToDelete from MGA_data:', UnifiedState.data.seedsToDelete.length);
          } else {
              // Backward compatibility: Try loading from old separate storage key
              UnifiedState.data.seedsToDelete = MGA_loadJSON('MGA_seedsToDelete', []);
              productionLog('üì¶ [STORAGE] Loaded seedsToDelete from legacy key');
              // Migrate to MGA_data on next save
              if (UnifiedState.data.seedsToDelete.length > 0) {
                  productionLog('üì¶ [MIGRATION] Will migrate seedsToDelete to MGA_data on next save');
              }
          }

          if (loadedData && loadedData.autoDeleteEnabled !== undefined) {
              UnifiedState.data.autoDeleteEnabled = loadedData.autoDeleteEnabled;
              productionLog('üì¶ [STORAGE] Loaded autoDeleteEnabled from MGA_data:', UnifiedState.data.autoDeleteEnabled);
          } else {
              // Backward compatibility
              UnifiedState.data.autoDeleteEnabled = MGA_loadJSON('MGA_autoDeleteEnabled', false);
              productionLog('üì¶ [STORAGE] Loaded autoDeleteEnabled from legacy key');
          }
          productionLog('üîç [STORAGE-DEBUG] Seeds type check:', typeof UnifiedState.data.seedsToDelete, 'length:', UnifiedState.data.seedsToDelete?.length || 0);
  
          productionLog('üì¶ [STORAGE] Loading seed deletion settings:', {
              seedsToDelete: UnifiedState.data.seedsToDelete.length + ' seeds',
              autoDeleteEnabled: UnifiedState.data.autoDeleteEnabled,
              seeds: UnifiedState.data.seedsToDelete,
              rawSeedsToDeleteFromStorage: rawSeedsData,
              rawAutoDeleteFromStorage: rawAutoDeleteData,
              parsedSeedsData: rawSeedsData ? JSON.parse(rawSeedsData) : null,
              parsedAutoDeleteData: rawAutoDeleteData ? JSON.parse(rawAutoDeleteData) : null
          });
  
          // Verify seeds loaded correctly
          if (UnifiedState.data.seedsToDelete.length > 0) {
              productionLog('‚úÖ [STORAGE-VERIFY] Seed selections loaded successfully:', UnifiedState.data.seedsToDelete);
          } else {
              productionWarn('‚ö†Ô∏è [STORAGE-VERIFY] No seed selections found in storage');
              productionLog('   localStorage check:', localStorage.getItem('MGA_seedsToDelete') ? 'Data exists' : 'No data');
  
              // Enhanced debugging for seeds
              const rawSeedsData = localStorage.getItem('MGA_seedsToDelete');
              if (rawSeedsData) {
                  productionLog('   Raw seeds data length:', rawSeedsData.length);
                  productionLog('   Raw seeds data preview:', rawSeedsData.substring(0, 100));
                  try {
                      const parsed = JSON.parse(rawSeedsData);
                      productionLog('   Manual seeds parse successful:', typeof parsed, Array.isArray(parsed) ? parsed.length : 'not array');
                      console.error('‚ùå [STORAGE-ERROR] Seeds data exists and parses correctly, but MGA_loadJSON failed!');
                  } catch (parseError) {
                      console.error('‚ùå [STORAGE-ERROR] Seeds JSON parse error:', parseError.message);
                      productionLog('   Corrupted seeds data - will be cleared on next save');
                  }
              }
          }

          // Load crop protection settings from MGA_data
          if (loadedData && loadedData.lockedCrops) {
              UnifiedState.data.lockedCrops = loadedData.lockedCrops;

              // MIGRATION: Convert old "No Mutation" to "Lock All Mutations"
              if (UnifiedState.data.lockedCrops.mutations) {
                  const mutations = UnifiedState.data.lockedCrops.mutations;
                  const oldIndex = mutations.indexOf('No Mutation');
                  if (oldIndex !== -1) {
                      mutations[oldIndex] = 'Lock All Mutations';
                      productionLog('üì¶ [MIGRATION] Converted old "No Mutation" to "Lock All Mutations"');
                  }
              }

              productionLog('üì¶ [STORAGE] Loaded crop protection locks from MGA_data:', {
                  species: loadedData.lockedCrops.species?.length || 0,
                  mutations: loadedData.lockedCrops.mutations?.length || 0
              });
          } else {
              UnifiedState.data.lockedCrops = { species: [], mutations: [] };
              productionLog('üì¶ [STORAGE] Initialized crop protection with defaults');
          }
  
          if (loadedData && loadedData.sellBlockThreshold !== undefined) {
              UnifiedState.data.sellBlockThreshold = loadedData.sellBlockThreshold;
              productionLog('üì¶ [STORAGE] Loaded sell block threshold:', UnifiedState.data.sellBlockThreshold);
          } else {
              UnifiedState.data.sellBlockThreshold = 1.0;
              productionLog('üì¶ [STORAGE] Initialized sell block threshold to default (1.0)');
          }
  
          // Load persisted ability timestamps to prevent duplicate logging after refresh
          UnifiedState.data.lastAbilityTimestamps = MGA_loadJSON('MGA_lastAbilityTimestamps', {});
  
          // Clean up old ability timestamps (keep only last 24 hours to prevent memory bloat)
          const dayAgo = Date.now() - (24 * 60 * 60 * 1000);
          Object.keys(UnifiedState.data.lastAbilityTimestamps).forEach(petId => {
              if (UnifiedState.data.lastAbilityTimestamps[petId] < dayAgo) {
                  delete UnifiedState.data.lastAbilityTimestamps[petId];
              }
          });
  

          // ==================== SAVE COMPLETE STATE ====================
          // CRITICAL: Save AFTER all data has been loaded from loadedData to prevent data loss
          MGA_saveJSON('MGA_data', UnifiedState.data);
          productionLog('üíæ [STORAGE] Saved complete merged state (settings, customRooms, seedsToDelete, lockedCrops, sellBlockThreshold)');

          // PERSISTENCE GUARD v3.6.6: Clear guard - initialization complete, saves now allowed
          if (window.MGA_PERSISTENCE_GUARD) {
              window.MGA_PERSISTENCE_GUARD.initializationSavesBlocked = false;
              productionLog('üõ°Ô∏è [PERSISTENCE-GUARD] Cleared - saves now allowed outside initialization');
          }

          // ==================== STORAGE LOADING SUMMARY ====================
          productionLog('üìä [STORAGE-SUMMARY] Data loading complete:', {
              petPresets: {
                  loaded: Object.keys(UnifiedState.data.petPresets).length,
                  presets: Object.keys(UnifiedState.data.petPresets),
                  rawExists: !!rawPresets
              },
              abilityLogs: {
                  loaded: UnifiedState.data.petAbilityLogs.length,
                  rawExists: !!localStorage.getItem('MGA_petAbilityLogs')
              },
              seedSettings: {
                  seedsToDelete: UnifiedState.data.seedsToDelete.length,
                  autoDeleteEnabled: UnifiedState.data.autoDeleteEnabled,
                  rawSeedsExists: !!rawSeedsData,
                  rawAutoDeleteExists: !!rawAutoDeleteData
              },
              settings: {
                  loaded: Object.keys(UnifiedState.data.settings).length,
                  rawExists: !!localStorage.getItem('MGA_settings')
              },
              allMgaKeys: Object.keys(localStorage).filter(k => k.startsWith('MGA_')),
              timestamp: new Date().toISOString()
          });
  
          // Persistence verification test
          setTimeout(() => {
              // productionLog('üîç [STORAGE-VERIFICATION] Testing immediate save/load cycle...');
              const testKey = 'MGA_persistenceTest';
              const testData = { test: true, timestamp: Date.now() };
  
              try {
                  MGA_saveJSON(testKey, testData);
                  const retrieved = MGA_loadJSON(testKey, null);
                  const success = retrieved && retrieved.test === true;
  
                  productionLog('üìä [STORAGE-VERIFICATION] Persistence test result:', {
                      success: success,
                      saved: testData,
                      retrieved: retrieved,
                      matching: JSON.stringify(testData) === JSON.stringify(retrieved)
                  });
  
                  // Clean up test data
                  localStorage.removeItem(testKey);
  
                  if (!success) {
                      console.error('‚ùå [STORAGE-VERIFICATION] Persistence test FAILED - data may not be saving correctly');
                  } else {
                      productionLog('‚úÖ [STORAGE-VERIFICATION] Persistence test PASSED - storage is working correctly');
                  }
              } catch (error) {
                  console.error('‚ùå [STORAGE-VERIFICATION] Persistence test ERROR:', error);
              }
          }, 100);
      }
  
      function startIntervals() {
          productionLog('üö®üö®üö® [CRITICAL] startIntervals() CALLED üö®üö®üö®');
  
          // Mark that intervals have been started
          window._mgaIntervalsStarted = true;
  
          // Initialize event-driven shop watcher
          productionLog('üîÑ Initializing event-driven shop monitoring...');
          initializeShopWatcher();
  
          // Initialize the enhanced TimerManager (make it global for debugging)
          window.timerManager = initializeTimerManager();
  
          // OPTIMIZED: Monitor abilities every 3 seconds (reduced from 2s for better FPS)
          productionLog('üö® [CRITICAL] Setting up ability monitoring timer...');
          window.abilityMonitoringInterval = setInterval(() => {
              monitorPetAbilities();
          }, 3000);
          productionLog('üö® [CRITICAL] Ability monitoring started with simple setInterval (3s)');
  
          // OPTIMIZED: Update timers every 2 seconds (reduced from 1s)
          window.timerManager.startTimer('timers', () => updateTimers(), 2000);
  
          // OPTIMIZED: Update values every 3 seconds (reduced from 2s)
          window.timerManager.startTimer('values', () => updateValues(), 3000);
  
          // Optimized notification timer with performance monitoring
          productionLog('üö® [CRITICAL] Setting up optimized notification timer...');
  
          let notificationCheckCounter = 0;
          let skipNextChecks = 0;
  
          // Make notificationInterval global so we can check if it's running
          // OPTIMIZED: Increased to 10 seconds to dramatically reduce FPS impact
          window.notificationInterval = setInterval(() => {
              // Skip checks if we're in a performance-critical situation
              if (skipNextChecks > 0) {
                  skipNextChecks--;
                  productionLog('‚è≠Ô∏è [PERFORMANCE] Skipping notification checks to improve FPS');
                  return;
              }
  
              // Check if we're in a weather event and should throttle
              const currentWeather = window.roomState?.child?.data?.weather || window.roomState?.weather || null;
              const isWeatherActive = currentWeather && currentWeather !== 'none' && currentWeather !== 'clear';
  
              notificationCheckCounter++;
  
              // OPTIMIZED: During weather events, only check every 2nd interval (20s instead of 10s)
              if (isWeatherActive && notificationCheckCounter % 2 !== 0) {
                  productionLog('üå§Ô∏è [PERFORMANCE] Throttling checks during weather event:', currentWeather);
                  return;
              }
  
              // Measure performance impact
              const startTime = performance.now();
  
              try {
                  // Run checks with try-catch to prevent errors from breaking the interval
                  try {
                      checkForWatchedItems();
                  } catch (e) {
                      console.error('‚ùå Error in checkForWatchedItems:', e);
                  }
  
                  try {
                      checkPetHunger();
                  } catch (e) {
                      console.error('‚ùå Error in checkPetHunger:', e);
                  }
  
                  // Only check weather if enabled and not already in weather event
                  if (!isWeatherActive) {
                      try {
                          detectWeatherEvents();
                      } catch (e) {
                          console.error('‚ùå Error in detectWeatherEvents:', e);
                      }
                  }
  
                  // Check if we're taking too long
                  const elapsed = performance.now() - startTime;
                  if (elapsed > 50) { // If checks take more than 50ms
                      productionWarn(`‚ö†Ô∏è [PERFORMANCE] Notification checks took ${elapsed.toFixed(2)}ms - throttling next checks`);
                      skipNextChecks = 2; // Skip next 2 checks (20 seconds total)
                  }
  
              } catch (error) {
                  console.error('‚ùå [CRITICAL] Error in notification interval:', error);
              }
          }, 10000); // OPTIMIZED: Check every 10 seconds (reduced from 5s for better FPS)
  
          // Store interval reference for cleanup
          MGA_addInterval(notificationInterval);
  
          productionLog('üö® [CRITICAL] Optimized notification timer started with performance monitoring');
  
          // HUNGER TIMER: Update hunger countdown timers every second
          productionLog('üçñ [HUNGER-TIMER] Setting up hunger timer updates...');
          window.hungerTimerInterval = setInterval(() => {
              try {
                  // Update all hunger timer elements
                  const timerElements = document.querySelectorAll('.mga-hunger-timer');
                  const activePets = window.activePets || UnifiedState.atoms.activePets || [];
  
                  if (UnifiedState.data.settings?.debugMode) {
                      console.log('üçñ [TIMER-UPDATE] Timer elements found:', timerElements.length);
                      console.log('üçñ [TIMER-UPDATE] Active pets:', activePets.length);
                      if (activePets.length > 0) {
                          activePets.forEach((p, i) => {
                              console.log(`üçñ [TIMER-UPDATE] Pet ${i}:`, {
                                  species: p.petSpecies,
                                  hunger: p.hunger,
                                  abilities: p.abilities,
                                  strength: p.strength,
                                  str: p.str
                              });
                          });
                      }
                  }
  
                  if (timerElements.length > 0) {
                      timerElements.forEach(element => {
                          const petIndex = parseInt(element.dataset.petIndex);
                          if (petIndex >= 0 && petIndex < activePets.length) {
                              const pet = activePets[petIndex];
                              const timeUntilHungry = calculateTimeUntilHungry(pet);
                              const timerText = formatHungerTimer(timeUntilHungry);
                              const timerColor = timeUntilHungry === null ? '#999' :
                                                 timeUntilHungry <= 0 ? '#8B0000' :
                                                 timeUntilHungry < 5 * 60 * 1000 ? '#ff4444' :
                                                 timeUntilHungry < 15 * 60 * 1000 ? '#ffa500' : '#4caf50';
                              element.textContent = timerText;
                              element.style.color = timerColor;
                          }
                      });
                  }
              } catch (error) {
                  console.error('‚ùå Error updating hunger timers:', error);
              }
          }, 1000); // Update every second
  
          MGA_addInterval(window.hungerTimerInterval);
          productionLog('üçñ [HUNGER-TIMER] Hunger timer updates started (1s interval)');
  
          debugLog('INTERVALS', 'All intervals started with TimerManager', {
              timerCount: timerManager.activeTimers.size,
              status: timerManager.getStatus()
          });
  
          // BUGFIX: Visibility-aware performance optimization (from v1.11.3)
          // Slower refresh when tab is hidden to save CPU/battery
          document.addEventListener('visibilitychange', function() {
              const hidden = document.hidden;
              productionLog(`üëÅÔ∏è [VISIBILITY] Tab ${hidden ? 'hidden' : 'visible'} - adjusting intervals`);
  
              // Adjust ability monitoring interval
              if (window.abilityMonitoringInterval) {
                  clearInterval(window.abilityMonitoringInterval);
              }
              window.abilityMonitoringInterval = setInterval(() => {
                  monitorPetAbilities();
              }, hidden ? 5000 : 3000); // 5s when hidden, 3s when visible
  
              // Adjust notification interval
              if (window.notificationInterval) {
                  clearInterval(window.notificationInterval);
              }
              window.notificationInterval = setInterval(() => {
                  // ... notification logic (same as above)
                  if (skipNextChecks > 0) {
                      skipNextChecks--;
                      return;
                  }
                  const currentWeather = window.roomState?.child?.data?.weather || window.roomState?.weather || null;
                  const isWeatherActive = currentWeather && currentWeather !== 'none' && currentWeather !== 'clear';
                  notificationCheckCounter++;
                  if (isWeatherActive && notificationCheckCounter % 2 !== 0) return;
  
                  const startTime = performance.now();
                  try {
                      try {
                          checkPetHunger();
                      } catch (hungerError) {
                          console.error('Error in checkPetHunger:', hungerError);
                      }
                  } catch (error) {
                      console.error('Critical error in notification checks:', error);
                  }
  
                  const checkDuration = performance.now() - startTime;
                  if (checkDuration > 50) {
                      productionLog(`‚è±Ô∏è [PERFORMANCE] Notification checks took ${checkDuration.toFixed(2)}ms`);
                      skipNextChecks = 2;
                  }
              }, hidden ? 20000 : 10000); // 20s when hidden, 10s when visible
  
              productionLog(`üëÅÔ∏è [VISIBILITY] Intervals adjusted for ${hidden ? 'background' : 'foreground'} mode`);
          }, { passive: true });
      }
  
      // ==================== NAVIGATION HELPERS ====================
      function handleTabNavigation(e, forward) {
          const focusableElements = getFocusableElements();
          const currentIndex = focusableElements.indexOf(e.target);
  
          if (currentIndex === -1) return;
  
          const nextIndex = forward
              ? (currentIndex + 1) % focusableElements.length
              : (currentIndex - 1 + focusableElements.length) % focusableElements.length;
  
          focusableElements[nextIndex]?.focus();
      }
  
      function handleArrowNavigation(e, direction) {
          const focusable = getFocusableElements();
          const current = e.target;
  
          if (current.classList.contains('mga-btn') || current.classList.contains('mga-tab')) {
              const siblings = getSiblingsInDirection(current, direction);
              if (siblings.length > 0) {
                  siblings[0].focus();
              }
          }
      }
  
      function getFocusableElements() {
          return Array.from(targetDocument.querySelectorAll(
              'button:not([disabled]), input:not([disabled]), select:not([disabled]), textarea:not([disabled]), [tabindex]:not([tabindex="-1"])'
          )).filter(el => el.offsetParent !== null); // Only visible elements
      }
  
      function getSiblingsInDirection(element, direction) {
          const parent = element.parentElement;
          const siblings = Array.from(parent.children).filter(el =>
              el !== element && getFocusableElements().includes(el)
          );
  
          // Simple directional logic - could be enhanced with position calculations
          return siblings;
      }
  
      function openCommandPalette(e) {
          createCommandPalette();
      }
  
      function openQuickSearch(e) {
          createQuickSearchOverlay();
      }
  
      function handleEnterKey(e) {
          const target = e.target;
          if (target.classList.contains('mga-btn')) {
              target.click();
          }
      }
  
      function handleSpaceKey(e) {
          const target = e.target;
          if (target.classList.contains('mga-btn')) {
              target.click();
          }
      }
  
      function handleEscapeKey() {
          // Close any open modals/overlays in order of priority
          const commandPalette = targetDocument.querySelector('#mga-command-palette');
          if (commandPalette) {
              commandPalette.remove();
              return;
          }
  
          const searchOverlay = targetDocument.querySelector('#mga-search-overlay');
          if (searchOverlay) {
              searchOverlay.remove();
              return;
          }
  
          // Close focused popout
          targetDocument.querySelectorAll('.mga-overlay').forEach(overlay => {
              if (overlay.style.display !== 'none') {
                  overlay.style.display = 'none';
              }
          });
      }
  
      function closeAllPopouts() {
          targetDocument.querySelectorAll('.mga-overlay').forEach(overlay => {
              overlay.style.display = 'none';
          });
  
          // Close separate windows
          UnifiedState.popoutWindows.forEach(window => {
              try { window.close(); } catch(e) {}
          });
          UnifiedState.popoutWindows.clear();
      }
  
      function refreshAllContent() {
          updateTabContent();
          refreshSeparateWindowPopouts();
          productionLog('üîÑ All content refreshed');
      }
  
      function loadPetPreset(preset) {
          if (!preset || !Array.isArray(preset)) {
              productionWarn('[PETS] Invalid preset data');
              return;
          }
  
          // Store current pets
          (UnifiedState.atoms.activePets || []).forEach(p => {
              safeSendMessage({
                  scopePath: ["Room", "Quinoa"],
                  type: "StorePet",
                  itemId: p.id
              });
          });
  
          // Place preset pets with delays
          preset.forEach((p, i) => {
              setTimeout(() => {
                  safeSendMessage({
                      scopePath: ["Room", "Quinoa"],
                      type: "PlacePet",
                      itemId: p.id,
                      position: { x: 17 + i * 2, y: 13 },
                      localTileIndex: 64,
                      tileType: "Boardwalk"
                  });
              }, i * 50);
          });
  
          productionLog(`‚úÖ [PETS] Loaded pet preset`);
      }
  
      function loadPresetByNumber(number) {
          const presets = Object.keys(UnifiedState.data.petPresets);
          if (presets[number - 1]) {
              const presetName = presets[number - 1];
              const preset = UnifiedState.data.petPresets[presetName];
              loadPetPreset(preset);
              productionLog(`üêæ Loaded preset ${number}: ${presetName}`);
          }
      }
  
      function createCommandPalette() {
          // Remove existing palette
          const existing = targetDocument.querySelector('#mga-command-palette');
          if (existing) existing.remove();
  
          const overlay = targetDocument.createElement('div');
          overlay.id = 'mga-command-palette';
          overlay.style.cssText = `
              position: fixed;
              top: 0;
              left: 0;
              width: 100vw;
              height: 100vh;
              background: rgba(0, 0, 0, 0.5);
              z-index: 20000;
              display: flex;
              align-items: flex-start;
              justify-content: center;
              padding-top: 100px;
          `;
  
          const palette = targetDocument.createElement('div');
          palette.style.cssText = `
              background: #1f2937;
              border: 1px solid #4b5563;
              border-radius: 8px;
              width: 500px;
              max-height: 400px;
              box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.3);
              overflow: hidden;
          `;
  
          const input = targetDocument.createElement('input');
          input.type = 'text';
          input.placeholder = 'Type a command...';
          input.style.cssText = `
              width: 100%;
              padding: 16px;
              background: transparent;
              border: none;
              color: white;
              font-size: 16px;
              outline: none;
          `;
  
          const commands = [
              { name: 'Open Pets', action: () => openTabInPopout('pets'), key: 'Alt+P' },
              { name: 'Open Values', action: () => openTabInPopout('values'), key: 'Alt+V' },
              { name: 'Open Abilities', action: () => openTabInPopout('abilities'), key: 'Alt+A' },
              { name: 'Open Seeds', action: () => openTabInPopout('seeds'), key: 'Alt+S' },
              { name: 'Open Settings', action: () => openTabInPopout('settings'), key: 'Alt+G' },
              { name: 'Close All Windows', action: () => closeAllPopouts(), key: 'Alt+W' },
              { name: 'Refresh All Content', action: () => refreshAllContent(), key: 'Alt+R' }
          ];
  
          const commandsList = targetDocument.createElement('div');
          commandsList.style.cssText = `
              max-height: 300px;
              overflow-y: auto;
          `;
  
          const renderCommands = (filter = '') => {
              commandsList.innerHTML = '';
              const filtered = commands.filter(cmd =>
                  cmd.name.toLowerCase().includes(filter.toLowerCase())
              );
  
              filtered.forEach((cmd, index) => {
                  const item = targetDocument.createElement('div');
                  item.style.cssText = `
                      padding: 12px 16px;
                      color: white;
                      cursor: pointer;
                      display: flex;
                      justify-content: space-between;
                      align-items: center;
                      ${index === 0 ? 'background: #374151;' : ''}
                  `;
                  item.innerHTML = `
                      <span>${cmd.name}</span>
                      <span style="color: #9ca3af; font-size: 12px;">${cmd.key}</span>
                  `;
  
                  item.addEventListener('click', () => {
                      cmd.action();
                      overlay.remove();
                  });
  
                  commandsList.appendChild(item);
              });
          };
  
          input.addEventListener('input', (e) => {
              renderCommands(e.target.value);
          });
  
          input.addEventListener('keydown', (e) => {
              if (e.key === 'Escape') {
                  overlay.remove();
              } else if (e.key === 'Enter') {
                  const firstCommand = commandsList.firstElementChild;
                  if (firstCommand) firstCommand.click();
              }
          });
  
          renderCommands();
          palette.appendChild(input);
          palette.appendChild(commandsList);
          overlay.appendChild(palette);
          targetDocument.body.appendChild(overlay);
  
          input.focus();
      }
  
      function createQuickSearchOverlay() {
          // Remove existing search
          const existing = targetDocument.querySelector('#mga-search-overlay');
          if (existing) existing.remove();
  
          const overlay = targetDocument.createElement('div');
          overlay.id = 'mga-search-overlay';
          overlay.style.cssText = `
              position: fixed;
              top: 20px;
              right: 20px;
              background: #1f2937;
              border: 1px solid #4b5563;
              border-radius: 8px;
              padding: 16px;
              z-index: 15000;
              width: 300px;
              box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.3);
          `;
  
          const input = targetDocument.createElement('input');
          input.type = 'text';
          input.placeholder = 'Search content...';
          input.style.cssText = `
              width: 100%;
              padding: 8px;
              background: #374151;
              border: 1px solid #4b5563;
              border-radius: 4px;
              color: white;
              outline: none;
          `;
  
          const results = targetDocument.createElement('div');
          results.style.cssText = `
              margin-top: 8px;
              max-height: 200px;
              overflow-y: auto;
          `;
  
          input.addEventListener('input', (e) => {
              const query = e.target.value.toLowerCase();
              if (query.length < 2) {
                  results.innerHTML = '';
                  return;
              }
  
              // Search through all content
              const searchResults = searchAllContent(query);
              results.innerHTML = searchResults.map(result => `
                  <div style="padding: 8px; cursor: pointer; border-radius: 4px; margin: 4px 0;"
                       onmouseover="this.style.background='#374151'"
                       onmouseout="this.style.background='transparent'"
                       onclick="window.${result.action}">
                      <div style="color: #60a5fa; font-size: 12px;">${result.tab}</div>
                      <div style="color: white; font-size: 14px;">${result.title}</div>
                      <div style="color: #9ca3af; font-size: 11px;">${result.preview}</div>
                  </div>
              `).join('');
          });
  
          input.addEventListener('keydown', (e) => {
              if (e.key === 'Escape') {
                  overlay.remove();
              }
          });
  
          overlay.appendChild(input);
          overlay.appendChild(results);
          targetDocument.body.appendChild(overlay);
  
          input.focus();
      }
  
  
      // ==================== CROP HIGHLIGHTING SYSTEM ====================
      // Ctrl+H clears highlights, UI in settings for crop highlighting
      function setupCropHighlightingSystem() {
          productionLog('üå± [DEBUG] setupCropHighlightingSystem() called - setting up crop highlighting...');
          // FIRST: Verify crop highlighting utilities are installed
          if (typeof window.removeAllTileOverrides !== 'function') {
              debugLog('CROP_HIGHLIGHT', 'Crop highlighting utilities not available - they should have been installed earlier');
          } else {
              debugLog('CROP_HIGHLIGHT', 'Crop highlighting utilities confirmed available');
          }
  
          if (window.__cropHighlightInstalled) {
              debugLog('CROP_HIGHLIGHT', 'Crop highlighting system already installed');
              return;
          }
  
          function cropHighlightHandler(e) {
              // Ctrl+H clears all highlights
              if (e.ctrlKey && e.key === 'h') {
                  e.preventDefault();
                  e.stopPropagation();
  
                  try {
                      if (typeof window.removeAllTileOverrides === 'function') {
                          window.removeAllTileOverrides();
                          debugLog('CROP_HIGHLIGHT', 'Ctrl+H ‚Üí cleared all tile highlights');
                      } else {
                          debugLog('CROP_HIGHLIGHT', 'removeAllTileOverrides function not available');
                      }
                  } catch (err) {
                      debugError('CROP_HIGHLIGHT', 'Failed to clear highlights', err);
                  }
              }
          }
  
          window.addEventListener("keydown", cropHighlightHandler, true);
          window.__cropHighlightInstalled = true;
          debugLog('CROP_HIGHLIGHT', 'Ctrl+H crop highlight hotkey installed');
      }
  
      // Crop highlighting function moved to settings section (line 5505) to avoid duplication
  
      function searchAllContent(query) {
          const results = [];
          const tabs = ['pets', 'abilities', 'seeds', 'values', 'timers', 'settings'];
  
          tabs.forEach(tab => {
              // Mock search results - in real implementation would search actual content
              if (tab.includes(query)) {
                  results.push({
                      tab: tab.charAt(0).toUpperCase() + tab.slice(1),
                      title: `${tab.charAt(0).toUpperCase() + tab.slice(1)} Tab`,
                      preview: `Open the ${tab} management interface`,
                      action: `openTabInPopout('${tab}')`
                  });
              }
          });
  
          return results;
      }
  
      // ==================== KEYBOARD SHORTCUTS ====================
      function initializeKeyboardShortcuts() {
          const shortcuts = {
              // Panel Management
              'Alt+M': () => {
                  const panel = UnifiedState.panels.main;
                  if (panel) {
                      const isVisible = panel.style.display !== 'none';
                      panel.style.display = isVisible ? 'none' : 'block';
  
                      // Hide any stuck tooltips when panel is toggled via keyboard
                      if (window.MGA_Tooltips && window.MGA_Tooltips.hide) {
                          window.MGA_Tooltips.hide();
                      }
  
                      UnifiedState.data.settings.panelVisible = !isVisible;
                      productionLog(`üéÆ MGA Keyboard shortcut: Panel ${isVisible ? 'hidden' : 'shown'}`);
                  }
              },
  
              // Quick Tab Access
              'Alt+V': () => openTabInPopout('values'),
              'Alt+P': () => openTabInPopout('pets'),
              'Alt+A': () => openTabInPopout('abilities'),
              'Alt+T': () => openTabInPopout('timers'),
              'Alt+S': () => openTabInPopout('seeds'),
              'Alt+G': () => openTabInPopout('settings'),
  
              // Navigation
              'Tab': (e) => handleTabNavigation(e, true),
              'Shift+Tab': (e) => handleTabNavigation(e, false),
              'ArrowUp': (e) => handleArrowNavigation(e, 'up'),
              'ArrowDown': (e) => handleArrowNavigation(e, 'down'),
              'ArrowLeft': (e) => handleArrowNavigation(e, 'left'),
              'ArrowRight': (e) => handleArrowNavigation(e, 'right'),
  
              // Quick Actions
              'Ctrl+K': (e) => openCommandPalette(e),
              'Ctrl+F': (e) => openQuickSearch(e),
              'Ctrl+B': () => toggleShopWindows(),
              'Enter': (e) => handleEnterKey(e),
              'Space': (e) => handleSpaceKey(e),
  
              // Window Management
              'Escape': () => handleEscapeKey(),
              'Alt+W': () => closeAllPopouts(),
              'Alt+R': () => refreshAllContent(),
  
              // Quick Pet Actions
              'Shift+1': () => loadPresetByNumber(1),
              'Shift+2': () => loadPresetByNumber(2),
              'Shift+3': () => loadPresetByNumber(3),
              'Shift+4': () => loadPresetByNumber(4),
              'Shift+5': () => loadPresetByNumber(5),
  
              // Crop Highlighting
              'Ctrl+H': () => clearCropHighlighting(),
              'Ctrl+Shift+H': () => {
                  // Open settings tab and focus on crop highlighting section
                  UnifiedState.activeTab = 'settings';
                  updateTabContent();
                  setTimeout(() => {
                      const highlightSection = targetDocument.querySelector('#highlight-species-select');
                      if (highlightSection) {
                          highlightSection.scrollIntoView({ behavior: 'smooth', block: 'center' });
                          highlightSection.focus();
                      }
                  }, 100);
                  productionLog('üå± Opened crop highlighting settings');
              }
          };
  
          document.addEventListener('keydown', (e) => {
              // Skip if typing in input/textarea
              if (['INPUT', 'TEXTAREA', 'SELECT'].includes(e.target.tagName)) {
                  return;
              }
  
              const key = [];
              if (e.altKey) key.push('Alt');
              if (e.ctrlKey) key.push('Ctrl');
              if (e.shiftKey) key.push('Shift');
  
              // Special key handling
              if (e.key === 'Escape') key.push('Escape');
              else if (e.key === 'Tab') key.push('Tab');
              else if (e.key === 'Enter') key.push('Enter');
              else if (e.key === ' ') key.push('Space');
              else if (e.key.startsWith('Arrow')) key.push(e.key);
              else if (e.key.length === 1) key.push(e.key.toUpperCase());
  
              const shortcut = key.join('+');
              if (shortcuts[shortcut]) {
                  e.preventDefault();
                  shortcuts[shortcut](e);
              }
          });
  
          productionLog('‚å®Ô∏è Keyboard shortcuts initialized:', Object.keys(shortcuts));
      }
  
      // ==================== LOCAL TELEPORT UTILITIES ====================
      // Install window.localTeleport function for client-side position updates
      function installLocalTeleport() {
          if (window.localTeleport && window.localTeleport.__installed) {
              debugLog('TELEPORT', 'localTeleport already installed');
              return;
          }
  
          window.localTeleport = async function localTeleport(x, y, opts = {}) {
              const timeout = typeof opts.timeout === "number" ? opts.timeout : 3000;
  
              // 1) Prefer built-in PlayerService if available (clean)
              try {
                  const PS = targetWindow.PlayerService || (targetWindow.Quinoa && targetWindow.Quinoa.PlayerService) || null;
                  if (PS && typeof PS.setPosition === "function") {
                      await PS.setPosition(x, y);
                      targetWindow.MagicCircle_RoomConnection.sendMessage({
                          "scopePath": [
                              "Room",
                              "Quinoa"
                          ],
                          "type": "PlayerPosition",
                          "position": {
                              "x": x,
                              "y": y
                          }
                      })
                      try { globalThis.__lastLocalTeleport = { x, y, at: Date.now() }; } catch (e) {}
                      return { ok: true, x, y, method: "PlayerService.setPosition" };
                  }
              } catch (e) {
                  // ignore and continue to fallback
              }
  
              // 2) Fallback: use jotai atom cache capture technique (captures store.set)
              try {
                  const cache = targetWindow.jotaiAtomCache?.cache;
                  if (!cache) return { ok: false, error: "jotaiAtomCache.cache not found" };
  
                  // find positionAtom
                  let positionAtom = null;
                  for (const a of cache.values()) {
                      const lbl = a?.debugLabel || a?.label || "";
                      if (String(lbl) === "positionAtom") { positionAtom = a; break; }
                  }
                  if (!positionAtom) return { ok: false, error: 'positionAtom not found in atom cache' };
  
                  // capture set by temporarily wrapping write functions
                  let capturedSet = null;
                  const patched = [];
                  try {
                      for (const atom of cache.values()) {
                          if (!atom || typeof atom.write !== "function") continue;
                          const orig = atom.write;
                          // avoid double-wrap
                          if (atom.__lt_origWrite) { patched.push(atom); continue; }
  
                          atom.__lt_origWrite = orig;
                          atom.write = function(get, set, ...args) {
                              if (!capturedSet) {
                                  capturedSet = set;
                                  // restore patched writes immediately after capture (so we don't keep wrappers)
                                  for (const p of patched) {
                                      if (p.__lt_origWrite) {
                                          try { p.write = p.__lt_origWrite; } catch (e) {}
                                          try { delete p.__lt_origWrite; } catch (e) {}
                                      }
                                  }
                              }
                              return orig.call(this, get, set, ...args);
                          };
                          patched.push(atom);
                      }
  
                      // trigger the app to call writes (same trick used before)
                      try { globalThis.dispatchEvent?.(new Event("visibilitychange")); } catch (e) {}
  
                      // wait for capture (short loop)
                      const until = Date.now() + timeout;
                      while (!capturedSet && Date.now() < until) {
                          await new Promise(r => setTimeout(r, 40));
                      }
                  } finally {
                      // restore any remaining patched atoms
                      for (const p of patched) {
                          if (p.__lt_origWrite) {
                              try { p.write = p.__lt_origWrite; } catch (e) {}
                              try { delete p.__lt_origWrite; } catch (e) {}
                          }
                      }
                  }
  
                  if (!capturedSet) return { ok: false, error: "Could not capture store.set from atom writes (timeout)" };
  
                  // perform the local-only set (this does NOT send teleport packet)
                  try {
                      capturedSet(positionAtom, { x, y });
                      try { globalThis.__lastLocalTeleport = { x, y, at: Date.now() }; } catch (e) {}
                      return { ok: true, x, y, method: "jotai-capture" };
                  } catch (err) {
                      return { ok: false, error: "capturedSet failed: " + String(err) };
                  }
              } catch (err) {
                  return { ok: false, error: "unexpected error: " + String(err) };
              }
          };
  
          window.localTeleport.__installed = true;
          debugLog('TELEPORT', 'localTeleport(x,y) installed on window');
      }
  
      // ==================== TELEPORT SYSTEM ====================
      function initializeTeleportSystem() {
          productionLog('üöÄ [DEBUG] initializeTeleportSystem() called - setting up teleport system...');
          // FIRST: Install window.localTeleport if not already installed
          if (typeof window.localTeleport !== 'function' || !window.localTeleport.__installed) {
              installLocalTeleport();
          }
  
          if (window.__altSlotTeleportInstalled) {
              debugLog('TELEPORT', 'Alt-slot teleport hotkeys already installed');
              return;
          }
  
          async function teleportHandler(e) {
              if (!e.altKey) return;
              const num = parseInt(e.key, 10);
              if (!(num >= 1 && num <= 6)) return;
  
              e.preventDefault();
              e.stopPropagation();
  
              try {
                  const slots = targetWindow.MagicCircle_RoomConnection
                      ?.lastRoomStateJsonable?.child?.data?.userSlots;
                  if (!Array.isArray(slots)) {
                      productionWarn("‚ö†Ô∏è userSlots not found in room state");
                      return;
                  }
  
                  const slot = slots[num - 1];
                  const pos = slot?.position;
                  if (!pos || typeof pos.x !== "number" || typeof pos.y !== "number") {
                      productionWarn(`‚ö†Ô∏è userSlots[${num - 1}] has no valid position`);
                      return;
                  }
  
                  productionLog(`üéØ TELEPORTING Alt+${num} to userSlots[${num - 1}] @ (${pos.x}, ${pos.y})`);
  
                  let clientUpdateSuccess = false;
                  let serverSyncSuccess = false;
  
                  // Method 1: CLIENT-SIDE POSITION UPDATE (using jotai atom access)
                  try {
                      productionLog(`üîß CLIENT: Updating local position via jotai atoms...`);
  
                      // Method 1A: Try jotaiAtomCache for player position
                      if (targetWindow.jotaiAtomCache) {
                          productionLog(`üîç CLIENT: Searching jotaiAtomCache for player position atom...`);
  
                          // Common player position atom paths to try
                          const playerPositionPaths = [
                              "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/myPositionAtom",
                              "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/myAtoms.ts/playerPositionAtom",
                              "/home/runner/work/magiccircle.gg/magiccircle.gg/client/src/games/Quinoa/atoms/playerAtoms.ts/myPositionAtom"
                          ];
  
                          let playerPositionAtom = null;
                          for (const atomPath of playerPositionPaths) {
                              const atom = targetWindow.jotaiAtomCache.get(atomPath);
                              if (atom) {
                                  productionLog(`‚úÖ CLIENT: Found player position atom at: ${atomPath}`);
                                  playerPositionAtom = atom;
                                  break;
                              }
                          }
  
                          // If we found the atom, try to use it
                          if (playerPositionAtom && playerPositionAtom.write) {
                              try {
                                  // Try to get the jotai store from window
                                  const store = targetWindow.jotaiStore || targetWindow.store;
                                  if (store && store.set) {
                                      await store.set(playerPositionAtom, { x: pos.x, y: pos.y });
                                      clientUpdateSuccess = true;
                                      productionLog(`‚úÖ CLIENT: jotai atom position update successful to (${pos.x}, ${pos.y})`);
                                  } else {
                                      productionLog(`‚ö†Ô∏è CLIENT: Found atom but no jotai store available`);
                                  }
                              } catch (atomError) {
                                  productionLog(`‚ùå CLIENT: jotai atom update failed:`, atomError);
                              }
                          } else {
                              productionLog(`‚ùå CLIENT: No player position atom found in jotaiAtomCache`);
  
                              // Debug: List available atoms
                              if (UnifiedState.data.settings.debugMode) {
                                  productionLog(`üîç CLIENT: Available atoms in cache:`, Array.from(targetWindow.jotaiAtomCache.keys()).filter(key => key.includes('position') || key.includes('Position') || key.includes('player') || key.includes('Player')));
                              }
                          }
                      }
  
                      // Method 1B: Try direct Atoms access (from reference script)
                      if (!clientUpdateSuccess && window.Atoms?.player?.position?.set) {
                          await window.Atoms.player.position.set({ x: pos.x, y: pos.y });
                          clientUpdateSuccess = true;
                          productionLog(`‚úÖ CLIENT: Atoms.player.position.set successful to (${pos.x}, ${pos.y})`);
                      }
  
                      // Method 1C: Fallback to existing localTeleport
                      if (!clientUpdateSuccess && typeof window.localTeleport === 'function') {
                          const res = await window.localTeleport(pos.x, pos.y);
                          if (res?.ok) {
                              clientUpdateSuccess = true;
                              productionLog(`‚úÖ CLIENT: window.localTeleport successful to (${pos.x}, ${pos.y})`);
                          }
                      }
  
                      // Method 1D: Fallback to PlayerService
                      if (!clientUpdateSuccess) {
                          const PS = targetWindow.PlayerService || (targetWindow.Quinoa?.PlayerService);
                          if (PS?.setPosition) {
                              await PS.setPosition(pos.x, pos.y);
                              clientUpdateSuccess = true;
                              productionLog(`‚úÖ CLIENT: PlayerService.setPosition successful to (${pos.x}, ${pos.y})`);
                          }
                      }
  
                      if (!clientUpdateSuccess) {
                          productionLog(`‚ùå CLIENT: All client-side position update methods failed`);
                          productionLog(`üîç CLIENT: Available globals:`, {
                              jotaiAtomCache: !!targetWindow.jotaiAtomCache,
                              windowAtoms: !!window.Atoms,
                              localTeleport: typeof window.localTeleport,
                              PlayerService: !!(targetWindow.PlayerService || targetWindow.Quinoa?.PlayerService)
                          });
                      }
  
                  } catch (error) {
                      productionLog(`‚ùå CLIENT: Client-side position update failed:`, error);
                  }
  
                  // Method 2: SERVER SYNC (using reference script pattern)
                  try {
                      productionLog(`üåê SERVER: Syncing position for multiplayer...`);
  
                      // Use the proven working pattern: sendToGame with "Teleport" type
                      const teleportSuccess = sendToGame({
                          type: "Teleport",
                          position: { x: pos.x, y: pos.y }
                      });
  
                      if (teleportSuccess) {
                          serverSyncSuccess = true;
                          productionLog(`‚úÖ SERVER: Teleport message sent successfully`);
                      } else {
                          // Fallback to PlayerPosition message
                          productionLog(`üîÑ SERVER: Trying PlayerPosition fallback...`);
                          const fallbackSuccess = sendToGame({
                              type: "PlayerPosition",
                              position: { x: pos.x, y: pos.y }
                          });
  
                          if (fallbackSuccess) {
                              serverSyncSuccess = true;
                              productionLog(`‚úÖ SERVER: PlayerPosition fallback successful`);
                          }
                      }
  
                      if (!serverSyncSuccess) {
                          productionLog(`‚ùå SERVER: All server sync methods failed`);
                      }
  
                  } catch (error) {
                      productionLog(`‚ùå SERVER: Server sync failed:`, error);
                  }
  
                  // FINAL STATUS REPORT
                  productionLog(`üéØ TELEPORT RESULT for Alt+${num}:`);
                  productionLog(`   üë§ Client Update: ${clientUpdateSuccess ? '‚úÖ SUCCESS' : '‚ùå FAILED'}`);
                  productionLog(`   üåê Server Sync: ${serverSyncSuccess ? '‚úÖ SUCCESS' : '‚ùå FAILED'}`);
  
                  if (clientUpdateSuccess && serverSyncSuccess) {
                      productionLog(`üéâ COMPLETE SUCCESS: Player teleported to (${pos.x}, ${pos.y})!`);
                      debugLog('TELEPORT', `Complete teleport success for Alt+${num} to userSlots[${num - 1}] @ (${pos.x}, ${pos.y})`);
                  } else if (clientUpdateSuccess) {
                      productionWarn(`‚ö†Ô∏è PARTIAL: You moved but others may not see it (server sync failed)`);
                  } else if (serverSyncSuccess) {
                      productionWarn(`‚ö†Ô∏è PARTIAL: Server updated but you didn't move visually (client update failed)`);
                  } else {
                      console.error(`‚ùå TOTAL FAILURE: Neither client nor server teleport worked`);
                  }
  
              } catch (err) {
                  console.error("‚ùå Alt-slot teleport error:", err);
                  debugError('TELEPORT', 'Alt-slot teleport error', err);
              }
          }
  
          window.addEventListener("keydown", teleportHandler, true);
          window.__altSlotTeleportInstalled = true;
          productionLog('üöÄ Alt+1..Alt+6 teleport hotkeys installed');
          debugLog('TELEPORT', 'Teleport system initialized successfully');
      }
  
      // ==================== STANDALONE INITIALIZATION ====================
      function initializeStandalone() {
          if (UnifiedState.initialized) {
              productionLog('‚ö†Ô∏è Magic Garden Unified Assistant already initialized, skipping...');
              return;
          }
  
          productionLog('üéÆ Magic Garden Assistant - Demo Mode');
          productionLog('üí° Running in standalone mode with demo data');
          productionLog('üìù Note: This is a demonstration - no real game integration');
  
          // Ensure DOM is ready
          if (document.readyState === 'loading') {
              productionLog('‚è≥ DOM not ready, waiting for DOMContentLoaded...');
              document.addEventListener('DOMContentLoaded', initializeStandalone);
              return;
          }
  
          try {
              // Initialize demo data
              const demoData = createDemoData();
  
              // Populate UnifiedState with demo data
              UnifiedState.atoms.inventory = demoData.inventory;
              UnifiedState.atoms.myGarden = {
                  garden: {
                      tileObjects: generateDemoTiles(demoData.garden.readyTiles)
                  }
              };
              UnifiedState.atoms.friendBonus = 1.2; // Demo bonus
              // Demo data disabled - only use real ability logs from users actual gameplay
              // UnifiedState.data.petAbilityLogs = demoData.abilityLogs;
              logDebug("DEMO", "üìù Skipping demo ability logs injection - using real logs only");
              UnifiedState.data.timers = demoData.timers;
  
              // Load saved data (or use defaults)
              productionLog('üíæ Loading saved settings...');
              loadSavedData();
  
              // Create UI with demo banner
              productionLog('üé® Creating Demo UI...');
              createUnifiedUI();
              addDemoBanner();
  
              // Setup demo timers
              productionLog('‚è∞ Setting up demo timers...');
              setupDemoTimers();
  
              // Mark as initialized
              UnifiedState.initialized = true;
              productionLog('‚úÖ Magic Garden Assistant Demo initialized successfully!');
              productionLog('üéØ Try the features - they work with realistic demo data');
  
          } catch (error) {
              console.error('‚ùå Failed to initialize demo mode:', error);
              debugError('STANDALONE_INIT', 'Demo initialization failed', error);
              UnifiedState.initialized = false;
          }
      }
  
      function generateDemoTiles(count) {
          const tiles = {};
          const species = ['Carrot', 'Apple', 'Banana', 'Lily', 'Dragon Fruit'];
  
          for (let i = 0; i < count; i++) {
              tiles[i] = {
                  objectType: 'plant',
                  slots: [{
                      species: species[i % species.length],
                      endTime: Date.now() - 1000, // Ready for harvest
                      targetScale: 1 + Math.random() * 0.5, // Random scale
                      mutations: i % 3 === 0 ? ['Gold'] : [] // Some have mutations
                  }]
              };
          }
  
          return tiles;
      }
  
      function addDemoBanner() {
          // Add a demo mode banner to the main panel
          const panel = UnifiedState.panels.main;
          if (!panel) return;
  
          const banner = targetDocument.createElement('div');
          banner.style.cssText = `
              background: linear-gradient(90deg, #3b82f6, #8b5cf6);
              color: white;
              text-align: center;
              padding: 6px 12px;
              font-size: 11px;
              font-weight: 600;
              position: relative;
              margin: -1px -1px 8px -1px;
              border-radius: 6px 6px 0 0;
              box-shadow: 0 2px 4px rgba(0, 0, 0, 0.30);
          `;
          banner.innerHTML = 'üéÆ DEMO MODE - Showcasing full functionality with sample data';
  
          // Insert banner at the top of the panel
          const header = panel.querySelector('.mga-header');
          if (header) {
              panel.insertBefore(banner, header.nextSibling);
          }
      }
  
      function setupDemoTimers() {
          // Start demo timer countdown
          const timerManager = globalTimerManager || initializeTimerManager();
  
          timerManager.startTimer('demo-timer', 1000, () => {
              // Update demo timers
              if (UnifiedState.data.timers.seed > 0) UnifiedState.data.timers.seed--;
              if (UnifiedState.data.timers.egg > 0) UnifiedState.data.timers.egg--;
              if (UnifiedState.data.timers.tool > 0) UnifiedState.data.timers.tool--;
  
              // Update timer displays
              updateTimerDisplay();
          });
      }
  
      // ==================== WEBSOCKET INITIALIZATION ====================
      function initializeScript() {
          // DEBUG: Log initialization attempt
          if (window.MGA_DEBUG) {
              window.MGA_DEBUG.logStage('INITIALIZE_SCRIPT_CALLED', {
                  initialized: UnifiedState.initialized,
                  domState: document.readyState,
                  retryAttempt: window.MGA_initRetryCount || 0
              });
          }
  
          if (UnifiedState.initialized) {
              productionLog('‚ö†Ô∏è Magic Garden Unified Assistant already initialized, skipping...');
              if (window.MGA_DEBUG) {
                  window.MGA_DEBUG.logStage('ALREADY_INITIALIZED', { skipReason: 'UnifiedState.initialized is true' });
              }
              return;
          }
  
          // Ensure DOM is ready
          if (document.readyState === 'loading') {
              productionLog('‚è≥ DOM not ready, waiting for DOMContentLoaded...');
              if (window.MGA_DEBUG) {
                  window.MGA_DEBUG.logStage('DOM_NOT_READY', { domState: document.readyState });
              }
              document.addEventListener('DOMContentLoaded', initializeScript);
              return;
          }
  
          // REMOVED: Modal check - was causing false positives and infinite retry loops
  
          // Improved initialization timing to prevent splash screen stall
          productionLog('‚è≥ Waiting for game initialization to complete...');
          let retryCount = 0;
          const maxRetries = 3;
          // CRITICAL FIX: If game is already ready, don't delay! Only delay if we need to retry
          const gameAlreadyReady = (targetWindow.jotaiAtomCache?.cache || targetWindow.jotaiAtomCache) && targetWindow.MagicCircle_RoomConnection;
          const initialDelay = gameAlreadyReady ? 0 : 2000;
  
          const attemptInit = () => {
              // Check if game is ready
              const gameReadiness = {
                  jotaiAtomCache: !!targetWindow.jotaiAtomCache,
                  magicCircleConnection: !!targetWindow.MagicCircle_RoomConnection,
                  jotaiType: typeof targetWindow.jotaiAtomCache,
                  connectionType: typeof targetWindow.MagicCircle_RoomConnection
              };
  
              if (window.MGA_DEBUG) {
                  window.MGA_DEBUG.logStage('GAME_READINESS_CHECK', {
                      retryCount,
                      maxRetries,
                      gameReadiness,
                      timestamp: performance.now()
                  });
              }
  
              if (targetWindow.jotaiAtomCache && targetWindow.MagicCircle_RoomConnection) {
                  productionLog('‚úÖ Game ready, initializing script...');
                  if (window.MGA_DEBUG) {
                      window.MGA_DEBUG.logStage('GAME_READY', gameReadiness);
                      // Safe performance metric setting
                      if (window.MGA_DEBUG.performanceMetrics) {
                          window.MGA_DEBUG.performanceMetrics.gameReady = performance.now();
                      }
                  }
                  continueInitialization();
              } else if (retryCount < maxRetries) {
                  retryCount++;
                  productionLog(`‚è≥ Game not ready (jotaiAtomCache: ${!!targetWindow.jotaiAtomCache}, RoomConnection: ${!!targetWindow.MagicCircle_RoomConnection}), retry ${retryCount}/${maxRetries} in 1s...`);
                  if (window.MGA_DEBUG) {
                      window.MGA_DEBUG.logStage('GAME_NOT_READY_RETRYING', { retryCount, gameReadiness });
                  }
                  setTimeout(attemptInit, 1000);
              } else {
                  productionWarn('‚ö†Ô∏è Max retries reached, initializing anyway...');
                  if (window.MGA_DEBUG) {
                      window.MGA_DEBUG.logStage('MAX_RETRIES_REACHED', { retryCount, gameReadiness });
                  }
                  continueInitialization();
              }
          };
  
          setTimeout(attemptInit, initialDelay);
  
          // CRITICAL: Ensure intervals start even if initialization partially fails
          setTimeout(() => {
              if (typeof window.notificationInterval === 'undefined' || !window._mgaIntervalsStarted) {
                  productionWarn('‚ö†Ô∏è [FAILSAFE] Intervals not started after 30s, forcing start...');
                  try {
                      if (typeof startIntervals === 'function') {
                          startIntervals();
                          productionLog('‚úÖ [FAILSAFE] Successfully started intervals');
                      } else {
                          console.error('‚ùå [FAILSAFE] startIntervals function not found!');
                      }
                  } catch(e) {
                      console.error('‚ùå [FAILSAFE] Could not start intervals:', e);
                  }
              } else {
                  productionLog('‚úÖ [FAILSAFE] Intervals already running, no action needed');
              }
          }, 30000); // Failsafe after 30 seconds
  
          function continueInitialization() {
              productionLog('üå± Magic Garden Unified Assistant initializing...');
              productionLog('üìä Connection Status:', targetWindow.MagicCircle_RoomConnection ? '‚úÖ Available' : '‚ùå Not found');
  
              if (window.MGA_DEBUG) {
                  window.MGA_DEBUG.logStage('CONTINUE_INITIALIZATION', {
                      connectionStatus: !!targetWindow.MagicCircle_RoomConnection,
                      jotaiStatus: !!targetWindow.jotaiAtomCache,
                      domState: document.readyState,
                      timestamp: performance.now()
                  });
              }
  
          // ==================== IDLE PREVENTION MOVED ====================
          // NOTE: Idle prevention code has been moved to line ~380 to execute immediately
          // This ensures the game doesn't kick users out while the script loads
          productionLog('üìù [IDLE-PREVENTION] Idle prevention already applied at script start');
  
          try {
              // Load saved data
              productionLog('üíæ Loading saved data...');
              loadSavedData();
  
              // Firebase removed - using /info endpoint instead
              productionLog('üì° Room tracking initialized via /info endpoint');
              // initializeFirebase().then(firebase => {
              //     if (firebase) {
              //         startRoomReporting(firebase);
              //         startRoomListener(firebase);
              //         productionLog('‚úÖ Room tracking active');
              //     }
              // }).catch(err => {
              //     console.error('Firebase initialization error:', err);
              // });
  
              // Verify data loaded before UI creation
              // productionLog('üîç [STARTUP-VERIFY] Data loaded before UI creation:', {
              //     petPresets: Object.keys(UnifiedState.data.petPresets).length,
              //     seedsToDelete: UnifiedState.data.seedsToDelete.length,
              //     autoDeleteEnabled: UnifiedState.data.autoDeleteEnabled,
              //     dataLoaded: !!UnifiedState.data
              // });
  
              // Create UI
              // productionLog('üé® Creating UI...');
              if (window.MGA_DEBUG) {
                  window.MGA_DEBUG.logStage('CREATE_UI_STARTING', {
                      dataLoaded: !!UnifiedState.data,
                      petPresets: Object.keys(UnifiedState.data?.petPresets || {}).length,
                      targetDocumentReady: !!targetDocument.body
                  });
              }
  
              try {
                  createUnifiedUI();
  
                  if (window.MGA_DEBUG) {
                      window.MGA_DEBUG.logStage('CREATE_UI_COMPLETED', {
                          uiElements: targetDocument.querySelectorAll('.mga-panel, .mga-toggle-btn').length,
                          mainPanelExists: !!targetDocument.querySelector('.mga-panel'),
                          toggleBtnExists: !!targetDocument.querySelector('.mga-toggle-btn')
                      });
                      // Safe performance metric setting
                      if (window.MGA_DEBUG.performanceMetrics) {
                          window.MGA_DEBUG.performanceMetrics.uiCreated = performance.now();
                      }
                  }
              } catch (error) {
                  console.error('‚ùå Error creating UI:', error);

                  // Show visible error popup for user (especially important in Discord browser)
                  try {
                      const errorDiv = targetDocument.createElement('div');
                      errorDiv.style.cssText = `
                          position: fixed;
                          top: 50%;
                          left: 50%;
                          transform: translate(-50%, -50%);
                          background: rgba(220, 38, 38, 0.95);
                          color: white;
                          padding: 20px;
                          border-radius: 8px;
                          z-index: 9999999;
                          font-family: monospace;
                          max-width: 500px;
                          box-shadow: 0 8px 32px rgba(0,0,0,0.5);
                      `;
                      errorDiv.innerHTML = `
                          <div style="font-weight: bold; margin-bottom: 10px; font-size: 14px;">‚ùå MGTools UI Failed to Load</div>
                          <div style="font-size: 12px; margin-bottom: 10px; color: #fecaca;">${error.message}</div>
                          <div style="font-size: 11px; color: #fef2f2;">Press F12 and check Console for details</div>
                          <button onclick="this.parentElement.remove()" style="margin-top: 10px; padding: 8px 16px; background: white; color: #dc2626; border: none; border-radius: 4px; cursor: pointer; font-weight: bold;">Close</button>
                      `;
                      targetDocument.body.appendChild(errorDiv);
                  } catch (e) {
                      // If even error display fails, log it
                      console.error('Failed to show error UI:', e);
                  }

                  if (window.MGA_DEBUG) {
                      window.MGA_DEBUG.logError(error, 'createUnifiedUI');
                  }
                  productionWarn('‚ö†Ô∏è UI creation failed, but continuing with initialization...');
                  // DON'T throw error - continue with intervals even if UI fails
              }
  
              // Verify UI reflects loaded data immediately after creation
              setTimeout(() => {
                  const checkedSeeds = targetDocument.querySelectorAll('.seed-checkbox:checked');
                  // productionLog('üîç [UI-VERIFY] UI state after creation:', {
                  //     checkedSeedsInUI: checkedSeeds.length,
                  //     seedsInState: UnifiedState.data.seedsToDelete.length,
                  //     matches: checkedSeeds.length === UnifiedState.data.seedsToDelete.length
                  // });
              }, 100);
  
              // Initialize atom hooks
              productionLog('üîó Initializing atom hooks...');
              initializeAtoms();
  
              // Initialize turtle timer
              productionLog('üê¢ Initializing turtle timer...');
              initializeTurtleTimer();
  
              // Start monitoring intervals
              productionLog('‚è±Ô∏è Starting monitoring intervals...');
              startIntervals();
  
              // Apply saved theme settings
              productionLog('üé® Applying saved theme settings...');
              applyTheme();
  
              // Apply saved UI mode
              if (UnifiedState.data.settings.ultraCompactMode) {
                  productionLog('üì± Applying saved ultra-compact mode...');
                  applyUltraCompactMode(true);
              }
  
              // Apply saved weather setting
              productionLog('üåßÔ∏è Applying saved weather setting...');
              applyWeatherSetting();
  
              // Initialize keyboard shortcuts
              initializeKeyboardShortcuts();
  
              // Force UI refresh to apply saved state (timing fix for data persistence)
              productionLog('üîÑ Applying delayed UI refresh to ensure saved state is displayed...');
              setTimeout(() => {
                  productionLog('üîÑ [DATA-PERSISTENCE] Applying delayed UI refresh...');
  
                  // Verify data before refreshing UI
                  productionLog('üìä [DATA-PERSISTENCE] Current state:', {
                      petPresets: Object.keys(UnifiedState.data.petPresets).length,
                      seedsToDelete: UnifiedState.data.seedsToDelete.length,
                      autoDeleteEnabled: UnifiedState.data.autoDeleteEnabled
                  });
  
                  // Update main tab content to reflect loaded data
                  if (typeof updateTabContent === 'function') {
                      updateTabContent();
                      productionLog('‚úÖ [DATA-PERSISTENCE] UI refreshed with saved state');
                  }
  
                  // Update any open popout overlays
                  if (UnifiedState.data?.popouts?.overlays) {
                      UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                          if (overlay && document.contains(overlay)) {
                              try {
                                  const content = getContentForTab(tabName, true);
                                  const contentEl = overlay.querySelector('.mga-overlay-content, .mga-content');
                                  if (contentEl) {
                                      contentEl.innerHTML = content;
                                      // Set up handlers for the refreshed content
                                      if (tabName === 'seeds' && typeof setupSeedsTabHandlers === 'function') {
                                          setupSeedsTabHandlers(overlay);
                                      } else if (tabName === 'pets' && typeof setupPetsTabHandlers === 'function') {
                                          setupPetsTabHandlers(overlay);
                                      }
                                      productionLog(`‚úÖ [DATA-PERSISTENCE] Refreshed ${tabName} overlay with saved state`);
                                  }
                              } catch (error) {
                                  productionWarn(`‚ö†Ô∏è [DATA-PERSISTENCE] Failed to refresh ${tabName} overlay:`, error);
                              }
                          }
                      });
                  }
              }, 1000); // 1000ms delay to ensure all data loading is complete (increased for refresh stability)
  
              // Initialize teleport system
              initializeTeleportSystem();
  
              // Initialize crop highlighting system
              setupCropHighlightingSystem();
  
              // Initialize hotkey system
              initializeHotkeySystem();
  
              // Initialize tooltip system
              if (window.MGA_Tooltips) {
                  window.MGA_Tooltips.init();
                  productionLog('üí¨ Tooltip system initialized');
              }
  
              UnifiedState.initialized = true;
              window._MGA_INITIALIZED = true;
              try {
                  delete window._MGA_INITIALIZING;
              } catch (e) {
                  window._MGA_INITIALIZING = false;
              }
              window._MGA_TIMESTAMP = Date.now();  // Update timestamp on completion
  
              // NOW run conflict detection after game has loaded successfully
              // productionLog('üîç [MGA-ISOLATION] Running post-initialization MainScript conflict detection...');
              if (window.MGA_ConflictDetection) {
                  // Detect MainScript presence
                  const mainScriptDetected = window.MGA_ConflictDetection.detectMainScript();
  
                  // Only create barriers if MainScript is detected
                  if (mainScriptDetected) {
                      productionLog('üîí [MGA-ISOLATION] MainScript detected - creating protective barriers');
                      window.MGA_ConflictDetection.createIsolationBarrier();
                      window.MGA_ConflictDetection.preventAccess();
                  }
  
                  // Run integrity checks
                  const integrityOk = window.MGA_ConflictDetection.checkGlobalIntegrity();
                  const isolationOk = window.MGA_ConflictDetection.validateIsolation();
  
                  if (integrityOk && isolationOk) {
                      productionLog('‚úÖ [MGA-ISOLATION] Final integrity check passed - no conflicts detected');
                      if (mainScriptDetected) {
                          productionLog('‚úÖ [MGA-ISOLATION] Complete isolation validated - MainScript protection active');
                      }
                  } else {
                      productionWarn('‚ö†Ô∏è [MGA-ISOLATION] Final integrity check found potential conflicts');
                      if (!integrityOk) productionWarn('‚ö†Ô∏è [MGA-ISOLATION] Global integrity issues detected');
                      if (!isolationOk) productionWarn('‚ö†Ô∏è [MGA-ISOLATION] Isolation validation failed');
                  }
              } else {
                  productionWarn('‚ö†Ô∏è [MGA-ISOLATION] ConflictDetection not available - running without isolation');
              }
  
              productionLog('‚úÖ Magic Garden Unified Assistant initialized successfully!');
  
              // Remove test UI after successful initialization
              const testUI = targetDocument.querySelector('div[style*="Test UI Active"]') ||
                            targetDocument.querySelector('div[style*="MGA Test UI"]') ||
                            Array.from(targetDocument.querySelectorAll('div')).find(div =>
                                div.textContent && div.textContent.includes('Test UI Active'));
              if (testUI) {
                  testUI.remove();
                  debugLog('UI_LIFECYCLE', 'Test UI removed after successful initialization');
              }
  
              // Check connection status periodically using managed interval
              setManagedInterval('connectionCheck', () => {
                  const hasConnection = targetWindow.MagicCircle_RoomConnection &&
                                      typeof targetWindow.MagicCircle_RoomConnection.sendMessage === 'function';
                  if (!UnifiedState.connectionStatus && hasConnection) {
                      productionLog('üîå Game connection established!');
                      UnifiedState.connectionStatus = true;
                  } else if (UnifiedState.connectionStatus && !hasConnection) {
                      productionWarn('‚ö†Ô∏è Game connection lost!');
                      UnifiedState.connectionStatus = false;
                  }
              }, 5000);
  
          } catch (error) {
              console.error('‚ùå Failed to initialize Magic Garden Unified Assistant:', error);
              console.error('Stack trace:', error.stack);
              UnifiedState.initialized = false; // Allow retry
          }
          } // End continueInitialization function
      }
  
      // ==================== ENVIRONMENT-AWARE INITIALIZATION ====================
      /* CHECKPOINT removed: ENVIRONMENT_INITIALIZATION_START */
  
      function initializeBasedOnEnvironment() {
          console.log('üîçüîçüîç [EXECUTION] ENTERED initializeBasedOnEnvironment()');
          /* CHECKPOINT removed: DETECT_ENVIRONMENT_CALL */
          console.log('üîç [EXECUTION] About to call detectEnvironment()');
          const environment = detectEnvironment();
          console.log('üîç [EXECUTION] detectEnvironment() returned:', environment);
          /* CHECKPOINT removed: DETECT_ENVIRONMENT_COMPLETE */
  
          productionLog('üìä Environment Analysis:', {
              domain: environment.domain,
              strategy: environment.initStrategy,
              isGame: environment.isGameEnvironment,
              hasAtoms: environment.hasJotaiAtoms,
              hasConnection: environment.hasMagicCircleConnection
          });
  
          switch (environment.initStrategy) {
              case 'game-ready':
                  productionLog('‚úÖ Game environment ready - initializing with full integration');
                  initializeScript();
                  break;
  
              case 'game-wait':
                  productionLog('‚è≥ Game environment detected - waiting for game atoms...');
                  waitForGameReady();
                  break;
  
              case 'standalone':
                  productionLog('üéÆ Standalone environment - initializing demo mode');
                  initializeStandalone();
                  break;
  
              case 'skip':
                  productionLog('‚è≠Ô∏è Skipping initialization - script will run in game iframe only');
                  // Do not initialize on Discord page itself
                  break;
  
              default:
                  productionLog('‚ùì Unknown environment - attempting standalone mode');
                  initializeStandalone();
                  break;
          }
      }
  
      function waitForGameReady() {
          let attempts = 0;
          const maxAttempts = 20; // 10 seconds at 500ms intervals
  
          const checkGameReady = () => {
              // More flexible game readiness check - be less strict about requirements
              const atomCache = targetWindow.jotaiAtomCache?.cache || targetWindow.jotaiAtomCache;
              const hasAtoms = atomCache && typeof atomCache === 'object';
              const hasConnection = targetWindow.MagicCircle_RoomConnection && typeof targetWindow.MagicCircle_RoomConnection === 'object';
              const hasBasicDom = targetDocument.body && document.readyState === 'complete';
  
              // Check for alternative game indicators if primary ones fail (use regular document for game detection)
              const hasGameElements = document.querySelector('canvas') ||
                                    document.querySelector('[class*="game"]') ||
                                    document.querySelector('[id*="game"]') ||
                                    document.querySelector('div[style*="position"]');
  
              // Additional check: verify atoms actually contain expected keys
              const atomsReady = hasAtoms && atomCache.size > 0;
  
              // Be more lenient - initialize if we have DOM ready and some game indicators
              if ((atomsReady && hasConnection && hasBasicDom) ||
                  (hasBasicDom && hasGameElements && attempts >= 10)) {
  
                  if (atomsReady && hasConnection) {
                      productionLog('‚úÖ Game atoms and connection fully ready - switching to full mode');
                      productionLog('üìä [GAME-READY] Atoms count:', atomCache.size);
                  } else {
                      productionLog('‚úÖ Game elements detected, proceeding with reduced functionality mode');
                  }
  
                  initializeScript();
                  return true;
              }
  
              // Debug logging for what's missing
              if (attempts % 8 === 0) { // Every 4 seconds
                  productionLog('‚è≥ [GAME-WAIT] Still waiting...', {
                      hasAtoms,
                      atomsCount: hasAtoms ? atomCache.size : 0,
                      hasConnection,
                      hasBasicDom,
                      hasGameElements,
                      readyState: document.readyState,
                      attempt: attempts,
                      willProceedAt: attempts >= 10 ? 'Next check (fallback mode)' : `Attempt ${10 - attempts} more`
                  });
              }
  
              return false;
          };
  
          if (!checkGameReady()) {
              // Use managed interval for game check
              setManagedInterval('gameCheck', () => {
                  attempts++;
  
                  if (checkGameReady() || attempts >= maxAttempts) {
                      clearManagedInterval('gameCheck');
  
                      if (attempts >= maxAttempts) {
                          productionLog('‚ö†Ô∏è Game readiness timeout - falling back to demo mode');
                          productionLog('üí° You can try MGA.init() later if the game loads');
                          initializeStandalone();
                      }
                  }
              }, 500);
          }
      }
  
      // Start environment-based initialization
      /* CHECKPOINT removed: CALLING_MAIN_INITIALIZATION */
      console.log('üîçüîçüîç [EXECUTION] Reached end of startMGAInitialization, about to call initializeBasedOnEnvironment()');
      try {
          console.log('üîç [EXECUTION] Calling initializeBasedOnEnvironment()...');
          initializeBasedOnEnvironment();
          console.log('üîç [EXECUTION] initializeBasedOnEnvironment() returned!');
          /* CHECKPOINT removed: MAIN_INITIALIZATION_COMPLETE */
  
          // Initialize crop protection hooks
          setTimeout(() => {
              initializeProtectionHooks();
          }, 3000);
      } catch (error) {
          console.error('‚ùå‚ùå‚ùå [EXECUTION] MAIN_INITIALIZATION_FAILED:', error);
          console.error('‚ùå [EXECUTION] Error stack:', error.stack);
          console.error('üîß This error caused the script to stop working');
      }
      console.log('üîç [EXECUTION] Completed startMGAInitialization try-catch block');
  
      // ==================== IMMEDIATE TEST INITIALIZATION ====================
      // Additional fallback for manual testing - only if initialization failed
      productionLog('üß™ Setting up fallback timer for manual testing...');
      setTimeout(() => {
          // Only run demo mode if game mode completely failed to initialize
          if (!UnifiedState.initialized && !window._MGA_INITIALIZING) {
              productionLog('üîß Final fallback - trying demo mode');
              productionLog('üí° Use MGA.init() to force game mode initialization if needed');
              initializeStandalone();
          } else if (UnifiedState.initialized) {
              productionLog('‚úÖ Game mode already initialized - skipping demo fallback');
          }
      }, 5000);
  
      // ==================== PUBLIC API ====================
      // Expose unified state for debugging
      window.MGA = {
          state: UnifiedState,
  
          // Manual controls
          showPanel: () => {
              if (UnifiedState.panels.main) {
                  UnifiedState.panels.main.style.display = 'block';
              }
          },
  
          hidePanel: () => {
              if (UnifiedState.panels.main) {
                  UnifiedState.panels.main.style.display = 'none';
              }
          },
  
          // Manual initialization - use if script doesn't auto-initialize
          init: () => {
              productionLog('üîÑ Manual initialization requested...');
              UnifiedState.initialized = false; // Reset flag
              initializeScript();
          },
  
          // Recovery function for stuck initialization
          forceReinit: () => {
              productionLog('üîÑ Force reinitialization requested...');
              try {
                  delete window._MGA_INITIALIZING;
              } catch (e) {
                  window._MGA_INITIALIZING = undefined;
              }
              try {
                  delete window._MGA_INITIALIZED;
              } catch (e) {
                  window._MGA_INITIALIZED = undefined;
              }
              try {
                  delete window._MGA_TIMESTAMP;
              } catch (e) {
                  window._MGA_TIMESTAMP = undefined;
              }
              window._MGA_FORCE_INIT = true;
              location.reload();
          },
  
          // Data persistence diagnostics
          checkPersistence: () => {
              productionLog('üìä Data Persistence Check:');
              productionLog('  Pet Presets in State:', Object.keys(UnifiedState.data.petPresets).length);
              productionLog('  Pet Presets in Storage:', localStorage.getItem('MGA_petPresets') ? 'EXISTS' : 'MISSING');
              productionLog('  Seeds in State:', UnifiedState.data.seedsToDelete.length);
              productionLog('  Seeds in Storage:', localStorage.getItem('MGA_seedsToDelete') ? 'EXISTS' : 'MISSING');
  
              if (localStorage.getItem('MGA_petPresets')) {
                  productionLog('  Raw Presets:', localStorage.getItem('MGA_petPresets'));
              }
              if (localStorage.getItem('MGA_seedsToDelete')) {
                  productionLog('  Raw Seeds:', localStorage.getItem('MGA_seedsToDelete'));
              }
          },
  
          // Pop-out functionality
          popout: {
              openTab: (tabName) => openTabInPopout(tabName),
              openSeparateWindow: (tabName) => openTabInSeparateWindow(tabName),
              createOverlay: (tabName) => createInGameOverlay(tabName),
              closeOverlay: (tabName) => closeInGameOverlay(tabName),
              refreshOverlay: (tabName) => refreshOverlayContent(tabName)
          },
  
          // Debug functions
          debug: {
              logState: () => productionLog('MGA State:', UnifiedState),
              logAtoms: () => productionLog('Atoms:', UnifiedState.atoms),
              logData: () => productionLog('Data:', UnifiedState.data),
              testTheming: () => {
                  productionLog('üé® Testing universal theming system...');
                  productionLog('Current theme:', UnifiedState.currentTheme);
                  productionLog('Active overlays:', UnifiedState.data.popouts.overlays.size);
                  productionLog('Theme sync working:', !!UnifiedState.currentTheme);
  
                  // Apply a test theme change
                  const originalStyle = UnifiedState.data.settings.gradientStyle;
                  UnifiedState.data.settings.gradientStyle = 'rainbow-burst';
                  UnifiedState.data.settings.opacity = 75;
                  applyTheme();
  
                  productionLog('‚úÖ Test theme applied! Check all windows for rainbow theme.');
                  productionLog('üí° Open a pop-out or overlay to see the theme in action!');
  
                  // Restore original after 5 seconds
                  setTimeout(() => {
                      UnifiedState.data.settings.gradientStyle = originalStyle;
                      UnifiedState.data.settings.opacity = 95;
                      applyTheme();
                      productionLog('üîÑ Original theme restored.');
                  }, 5000);
              },
  
              checkConnection: () => {
                  const hasConnection = targetWindow.MagicCircle_RoomConnection &&
                                      typeof targetWindow.MagicCircle_RoomConnection.sendMessage === 'function';
                  productionLog('üîå Connection Status:', hasConnection ? '‚úÖ Available' : '‚ùå Not Available');
                  productionLog('üì° RoomConnection Object:', targetWindow.MagicCircle_RoomConnection);
                  return hasConnection;
              },
  
              testSendMessage: () => {
                  productionLog('üß™ Testing safeSendMessage...');
                  const result = safeSendMessage({
                      scopePath: ["Room"],
                      type: "Ping"
                  });
                  productionLog('Result:', result ? '‚úÖ Success' : '‚ùå Failed');
                  return result;
              },
  
              debugStorage: () => window.MGA_debugStorage(),
  
              // Test functions
              testAbilityLog: () => {
                  UnifiedState.data.petAbilityLogs.unshift({
                      petName: 'Test Pet',
                      abilityType: 'Test Ability',
                      timestamp: Date.now(),
                      timeString: new Date().toLocaleTimeString(),
                      data: { test: true }
                  });
  
                  // Apply memory management for test logs too
                  UnifiedState.data.petAbilityLogs = MGA_manageLogMemory(UnifiedState.data.petAbilityLogs);
                  MGA_debouncedSave('MGA_petAbilityLogs', UnifiedState.data.petAbilityLogs);
                  if (UnifiedState.activeTab === 'abilities') {
                      updateTabContent();
                  }
                  // Update all overlay windows showing abilities tab
                  UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                      if (overlay && document.contains(overlay) && tabName === 'abilities') {
                          if (overlay.className.includes('mga-overlay-content-only')) {
                              // NEW: Pure content overlays - refresh entire overlay
                              updatePureOverlayContent(overlay, tabName);
                              debugLog('OVERLAY_LIFECYCLE', 'Updated pure abilities overlay after test ability');
                          } else {
                              // LEGACY: Old overlay structure
                              const overlayContent = overlay.querySelector('.mga-overlay-content > div');
                              if (overlayContent) {
                                  overlayContent.innerHTML = getAbilitiesTabContent();
                                  // Update ability log display within this overlay context
                                  setTimeout(() => updateAbilityLogDisplay(overlay), 10);
                                  // Re-add resize handle after content update
                                  setTimeout(() => {
                                      if (!overlay.querySelector('.mga-resize-handle')) {
                                          addResizeHandleToOverlay(overlay);
                                          productionLog('üîß [RESIZE] Re-added missing resize handle to ability logs overlay');
                                      }
                                  }, 50);
                              }
                          }
                      }
                  });
              },
  
              testTimer: () => {
                  UnifiedState.data.timers = {
                      seed: 120,
                      egg: 240,
                      tool: 180,
                      lunar: 3600
                  };
                  if (UnifiedState.activeTab === 'timers') {
                      updateTimerDisplay();
                  }
              },
  
              testValues: () => {
                  UnifiedState.data.inventoryValue = 123456;
                  UnifiedState.data.tileValue = 78900;
                  UnifiedState.data.gardenValue = 456789;
                  if (UnifiedState.activeTab === 'values') {
                      updateTabContent();
                  }
              }
          },
  
          // Manual refresh functions
          refresh: {
              pets: () => {
                  if (UnifiedState.activeTab === 'pets') {
                      // Use targeted updates instead of full DOM rebuild to prevent UI interruption
                      const context = document.getElementById('mga-tab-content');
                      if (context) {
                          updatePetPresetDropdown(context);
                          // Update popouts without touching main tab
                          refreshSeparateWindowPopouts('pets');
                          UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                              if (overlay && document.contains(overlay) && tabName === 'pets') {
                                  if (overlay.className.includes('mga-overlay-content-only')) {
                                      updatePureOverlayContent(overlay, tabName);
                                  }
                              }
                          });
                      }
                  }
              },
              abilities: () => {
                  if (UnifiedState.activeTab === 'abilities') updateTabContent();
              },
              seeds: () => {
                  if (UnifiedState.activeTab === 'seeds') updateTabContent();
              },
              values: () => {
                  updateValues();
                  if (UnifiedState.activeTab === 'values') updateTabContent();
              },
              timers: () => {
                  updateTimers();
                  if (UnifiedState.activeTab === 'timers') updateTimerDisplay();
              },
              all: () => {
                  updateTabContent();
                  updateValues();
                  updateTimers();
              }
          },
  
          // Export functions
          export: {
              petPresets: () => {
                  const data = JSON.stringify(UnifiedState.data.petPresets, null, 2);
                  const blob = new Blob([data], { type: 'application/json' });
                  const link = targetDocument.createElement('a');
                  link.href = URL.createObjectURL(blob);
                  link.download = 'MGA_PetPresets.json';
                  link.click();
              },
  
              abilityLogs: () => exportAbilityLogs(),
  
              allData: () => {
                  const data = JSON.stringify({
                      petPresets: UnifiedState.data.petPresets,
                      petAbilityLogs: UnifiedState.data.petAbilityLogs,
                      settings: {
                          seedsToDelete: UnifiedState.data.seedsToDelete,
                          autoDeleteEnabled: UnifiedState.data.autoDeleteEnabled
                      }
                  }, null, 2);
                  const blob = new Blob([data], { type: 'application/json' });
                  const link = targetDocument.createElement('a');
                  link.href = URL.createObjectURL(blob);
                  link.download = `MGA_AllData_${new Date().toISOString().split('T')[0]}.json`;
                  link.click();
              }
          },
  
          // Import functions
          import: {
              petPresets: (jsonString) => {
                  try {
                      const data = JSON.parse(jsonString);
                      UnifiedState.data.petPresets = data;
                      MGA_saveJSON('MGA_petPresets', data);
                      if (UnifiedState.activeTab === 'pets') {
                          // Use targeted update to prevent UI interruption
                          const context = document.getElementById('mga-tab-content');
                          if (context) {
                              updatePetPresetDropdown(context);
                              refreshSeparateWindowPopouts('pets');
                          }
                      }
                      productionLog('‚úÖ Pet presets imported successfully');
                  } catch (e) {
                      console.error('‚ùå Failed to import pet presets:', e);
                  }
              },
  
              allData: (jsonString) => {
                  try {
                      const data = JSON.parse(jsonString);
                      if (data.petPresets) {
                          UnifiedState.data.petPresets = data.petPresets;
                          MGA_saveJSON('MGA_petPresets', data.petPresets);
                      }
                      if (data.petAbilityLogs) {
                          UnifiedState.data.petAbilityLogs = data.petAbilityLogs;
                          MGA_saveJSON('MGA_petAbilityLogs', data.petAbilityLogs);
                      }
                      if (data.settings) {
                          if (data.settings.seedsToDelete) {
                              UnifiedState.data.seedsToDelete = data.settings.seedsToDelete;
                          }
                          if (typeof data.settings.autoDeleteEnabled === 'boolean') {
                              UnifiedState.data.autoDeleteEnabled = data.settings.autoDeleteEnabled;
                          }
                      }
                      updateTabContent();
                      productionLog('‚úÖ All data imported successfully');
                  } catch (e) {
                      console.error('‚ùå Failed to import data:', e);
                  }
              }
          },
  
          // Clear functions
          clear: {
              petPresets: () => {
                  if (confirm('Clear all pet presets?')) {
                      UnifiedState.data.petPresets = {};
                      MGA_saveJSON('MGA_petPresets', {});
                      if (UnifiedState.activeTab === 'pets') {
                          // Use targeted update to prevent UI interruption
                          const context = document.getElementById('mga-tab-content');
                          if (context) {
                              updatePetPresetDropdown(context);
                              refreshSeparateWindowPopouts('pets');
                          }
                      }
                  }
              },
  
              abilityLogs: () => {
                  if (confirm('Clear all ability logs?')) {
                      UnifiedState.data.petAbilityLogs = [];
                      MGA_saveJSON('MGA_petAbilityLogs', []);
                      if (UnifiedState.activeTab === 'abilities') updateTabContent();
  
                      // Also update ability overlays
                      UnifiedState.data.popouts.overlays.forEach((overlay, tabName) => {
                          if (overlay && document.contains(overlay) && tabName === 'abilities') {
                              if (overlay.className.includes('mga-overlay-content-only')) {
                                  // NEW: Pure content overlays - refresh entire overlay
                                  updatePureOverlayContent(overlay, tabName);
                                  debugLog('OVERLAY_LIFECYCLE', 'Updated pure abilities overlay after clearing logs');
                              } else {
                                  // LEGACY: Old overlay structure
                                  const overlayContent = overlay.querySelector('.mga-overlay-content > div');
                                  if (overlayContent) {
                                      overlayContent.innerHTML = getAbilitiesTabContent();
                                      setTimeout(() => updateAbilityLogDisplay(overlay), 10);
                                      // Re-add resize handle after content update
                                      setTimeout(() => {
                                          if (!overlay.querySelector('.mga-resize-handle')) {
                                              addResizeHandleToOverlay(overlay);
                                              productionLog('üîß [RESIZE] Re-added missing resize handle to ability logs overlay');
                                          }
                                      }, 50);
                                  }
                              }
                          }
                      });
                  }
              },
  
              allData: () => {
                  if (confirm('Clear ALL saved data? This cannot be undone!')) {
                      UnifiedState.data.petPresets = {};
                      UnifiedState.data.petAbilityLogs = [];
                      UnifiedState.data.seedsToDelete = [];
                      UnifiedState.data.autoDeleteEnabled = false;
                      MGA_saveJSON('MGA_petPresets', {});
                      MGA_saveJSON('MGA_petAbilityLogs', []);
                      updateTabContent();
                  }
              }
          },
  
          // Debug controls for development and testing
          debug: {
              forceInit: () => {
                  productionLog('üîÑ [DEBUG] Force re-initialization requested');
                  window._MGA_FORCE_INIT = true;
                  location.reload();
              },
  
              resetFlags: () => {
                  productionLog('üîÑ [DEBUG] Resetting initialization flags');
                  window._MGA_INITIALIZED = false;
                  try {
                      delete window._MGA_INITIALIZING;
                  } catch (e) {
                      window._MGA_INITIALIZING = false;
                  }
                  window._MGA_FORCE_INIT = false;
                  productionLog('‚úÖ [DEBUG] Flags reset - you can now re-run the script');
              },
  
              checkPets: () => {
                  productionLog('üêæ [DEBUG] Current pet state:');
                  productionLog('‚Ä¢ UnifiedState.atoms.activePets:', UnifiedState.atoms.activePets);
                  productionLog('‚Ä¢ window.activePets:', window.activePets);
                  productionLog('‚Ä¢ Room state pets:', getActivePetsFromRoomState());
                  return {
                      unifiedState: UnifiedState.atoms.activePets,
                      windowPets: window.activePets,
                      roomState: getActivePetsFromRoomState()
                  };
              },
  
              refreshPets: () => {
                  productionLog('üîÑ [DEBUG] Manually refreshing pets from room state');
                  const pets = updateActivePetsFromRoomState();
                  productionLog('‚úÖ [DEBUG] Pets refreshed:', pets);
                  return pets;
              },
  
              listIntervals: () => {
                  productionLog('‚è∞ [DEBUG] Active managed intervals:');
                  Object.entries(UnifiedState.intervals).forEach(([name, interval]) => {
                      productionLog(`‚Ä¢ ${name}: ${interval ? 'Running' : 'Stopped'}`);
                  });
                  return UnifiedState.intervals;
              }
          }
      };
  
      // ==================== LOADING STATE UTILITIES ====================
      window.MGA_LoadingStates = {
          show: (element, text = 'Loading...') => {
              if (!element) return;
              const loadingHtml = `
                  <div class="mga-loading">
                      <div class="mga-loading-spinner"></div>
                      <span>${text}</span>
                  </div>
              `;
              element.innerHTML = loadingHtml;
          },
  
          showSkeleton: (element, lines = 3) => {
              if (!element) return;
              const skeletonLines = Array(lines).fill(0).map(() =>
                  `<div class="mga-skeleton" style="height: 20px; margin-bottom: 8px; width: ${Math.floor(Math.random() * 40 + 60)}%;"></div>`
              ).join('');
              element.innerHTML = `<div style="padding: 20px;">${skeletonLines}</div>`;
          },
  
          hide: (element, content, fadeIn = true) => {
              if (!element) return;
              element.innerHTML = content;
              if (fadeIn) {
                  element.classList.add('mga-fade-in');
                  setTimeout(() => element.classList.remove('mga-fade-in'), 300);
              }
          },
  
          addToButton: (button, originalText) => {
              if (!button) return;
              button.disabled = true;
              button.innerHTML = `<div class="mga-loading-spinner" style="margin-right: 4px; width: 16px; height: 16px;"></div>Loading...`;
          },
  
          removeFromButton: (button, originalText) => {
              if (!button) return;
              button.disabled = false;
              button.innerHTML = originalText;
          }
      };
  
      // ==================== ERROR RECOVERY MECHANISMS ====================
      window.MGA_ErrorRecovery = {
          wrapFunction: (fn, fallback = null, context = 'Unknown') => {
              return function(...args) {
                  try {
                      return fn.apply(this, args);
                  } catch (error) {
                      debugError('ERROR_RECOVERY', `Error in ${context}`, error);
  
                      // Show user-friendly error message
                      const errorToast = targetDocument.createElement('div');
                      errorToast.style.cssText = `
                          position: fixed; top: 20px; right: 20px; z-index: 20000;
                          background: rgba(220, 38, 38, 0.95); color: white;
                          padding: 12px 20px; border-radius: 8px;
                          font-family: Arial, sans-serif; font-size: 13px;
                          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
                          animation: mga-fade-in 0.3s ease-out;
                      `;
                      errorToast.innerHTML = `‚ö†Ô∏è Something went wrong in ${context}. Please try again.`;
                      targetDocument.body.appendChild(errorToast);
  
                      setTimeout(() => {
                          errorToast.style.animation = 'mga-fade-out 0.3s ease-in forwards';
                          setTimeout(() => targetDocument.body.removeChild(errorToast), 300);
                      }, 4000);
  
                      return fallback ? fallback.apply(this, args) : null;
                  }
              };
          },
  
          safeAsync: async (asyncFn, fallback = null, context = 'Async Operation') => {
              try {
                  return await asyncFn();
              } catch (error) {
                  debugError('ERROR_RECOVERY', `Async error in ${context}`, error);
                  return fallback;
              }
          },
  
          retryOperation: async (operation, maxRetries = 3, delay = 1000, context = 'Operation') => {
              for (let i = 0; i < maxRetries; i++) {
                  try {
                      return await operation();
                  } catch (error) {
                      if (i === maxRetries - 1) {
                          debugError('ERROR_RECOVERY', `Final retry failed for ${context}`, error);
                          throw error;
                      }
                      debugLog('ERROR_RECOVERY', `Retry ${i + 1}/${maxRetries} for ${context}`);
                      await new Promise(resolve => setTimeout(resolve, delay));
                  }
              }
          }
      };
  
      // ==================== PERFORMANCE OPTIMIZATIONS ====================
      window.MGA_Performance = {
          debounce: (func, wait) => {
              let timeout;
              return function executedFunction(...args) {
                  const later = () => {
                      clearTimeout(timeout);
                      func(...args);
                  };
                  clearTimeout(timeout);
                  timeout = setTimeout(later, wait);
              };
          },
  
          throttle: (func, limit) => {
              let inThrottle;
              return function() {
                  const args = arguments;
                  const context = this;
                  if (!inThrottle) {
                      func.apply(context, args);
                      inThrottle = true;
                      setTimeout(() => inThrottle = false, limit);
                  }
              };
          },
  
          batchDOMUpdates: (updates) => {
              requestAnimationFrame(() => {
                  const fragment = document.createDocumentFragment();
                  updates.forEach(update => {
                      if (typeof update === 'function') {
                          update(fragment);
                      }
                  });
              });
          },
  
          optimizeScrolling: (element) => {
              if (!element) return;
              element.style.willChange = 'scroll-position';
              element.style.transform = 'translateZ(0)';
          }
      };
  
      // ==================== COMPREHENSIVE TOOLTIP SYSTEM ====================
      window.MGA_Tooltips = {
          tooltip: null,
          showTimeout: null,
          hideTimeout: null,
          currentEvent: null, // Store current mouse event for positioning
  
          init: () => {
              // Create tooltip element
              if (!window.MGA_Tooltips.tooltip) {
                  window.MGA_Tooltips.tooltip = targetDocument.createElement('div');
                  window.MGA_Tooltips.tooltip.className = 'mga-tooltip';
                  targetDocument.body.appendChild(window.MGA_Tooltips.tooltip);
              }
  
              // Add event listeners to all elements with tooltip data
              document.addEventListener('mouseenter', window.MGA_Tooltips.handleMouseEnter, true);
              document.addEventListener('mouseleave', window.MGA_Tooltips.handleMouseLeave, true);
              document.addEventListener('mousemove', window.MGA_Tooltips.handleMouseMove, true);
          },
  
          handleMouseEnter: (e) => {
              const element = e.target?.closest?.('[data-tooltip]');
              if (!element) return;
  
              // Don't interfere with button interactions - check if target is a button or interactive element
              if (e.target && typeof e.target.matches === 'function' &&
                  (e.target.matches('button, input, select, .mga-btn') || e.target.closest('button, .mga-btn'))) {
                  return; // Skip tooltip for interactive elements to prevent hover interference
              }
  
              const text = element.dataset.tooltip;
              const delay = element.dataset.tooltipDelay || 500;
  
              // Store the event for positioning
              window.MGA_Tooltips.currentEvent = e;
  
              window.MGA_Tooltips.showTimeout = setTimeout(() => {
                  window.MGA_Tooltips.show(element, text);
              }, parseInt(delay));
          },
  
          handleMouseLeave: (e) => {
              const element = e.target?.closest?.('[data-tooltip]');
              if (!element) return;
  
              clearTimeout(window.MGA_Tooltips.showTimeout);
              window.MGA_Tooltips.hide();
          },
  
          handleMouseMove: (e) => {
              // CRITICAL: Only handle MGA-related tooltip events
              if (!isMGAEvent(e)) {
                  return;
              }
  
              // Don't interfere with button hover states
              if (e.target && typeof e.target.matches === 'function' &&
                  (e.target.matches('button, input, select, .mga-btn') || e.target.closest('button, .mga-btn'))) {
                  return;
              }
  
              // Update current event for positioning
              window.MGA_Tooltips.currentEvent = e;
  
              if (window.MGA_Tooltips.tooltip && window.MGA_Tooltips.tooltip.classList.contains('show')) {
                  // Check if we're still over a tooltip element
                  const tooltipElement = e.target?.closest?.('[data-tooltip]');
                  if (!tooltipElement) {
                      window.MGA_Tooltips.hide();
                      return;
                  }
                  window.MGA_Tooltips.position(e);
              }
          },
  
          show: (element, text) => {
              const tooltip = window.MGA_Tooltips.tooltip;
              tooltip.textContent = text;
  
              // BUGFIX: Position immediately before showing to prevent flash at (0,0)
              if (window.MGA_Tooltips.currentEvent) {
                  window.MGA_Tooltips.position(window.MGA_Tooltips.currentEvent);
              }
  
              tooltip.classList.add('show');
          },
  
          hide: () => {
              const tooltip = window.MGA_Tooltips.tooltip;
              tooltip.classList.remove('show');
  
              // BUGFIX: Reset position to prevent stuck tooltips
              tooltip.style.left = '-9999px';
              tooltip.style.top = '-9999px';
              window.MGA_Tooltips.currentEvent = null;
          },
  
          position: (e) => {
              const tooltip = window.MGA_Tooltips.tooltip;
              const rect = tooltip.getBoundingClientRect();
              const padding = 10;
  
              let x = e.clientX + padding;
              let y = e.clientY - rect.height - padding;
  
              // Adjust if tooltip goes off screen
              if (x + rect.width > window.innerWidth) {
                  x = e.clientX - rect.width - padding;
              }
              if (y < 0) {
                  y = e.clientY + padding;
              }
  
              tooltip.style.left = x + 'px';
              tooltip.style.top = y + 'px';
          },
  
          addToElement: (element, text, options = {}) => {
              if (!element) return;
              element.setAttribute('data-tooltip', text);
              if (options.delay) element.setAttribute('data-tooltip-delay', options.delay);
          },
  
          removeFromElement: (element) => {
              if (!element) return;
              element.removeAttribute('data-tooltip');
              element.removeAttribute('data-tooltip-delay');
          }
      };
  
      // Add fade-out animation for error toasts and slot value centering
      const additionalStyles = `
    @keyframes mga-fade-out {
      from { opacity: 1; transform: translateY(0); }
      to { opacity: 0; transform: translateY(-10px); }
    }
  
    /* Ensure our estimate/slot-value paragraphs behave as full-width, centered lines
       so they appear centered inside the game's tooltip textbox regardless of container quirks. */
    [data-turtletimer-estimate="true"] {
      display: block !important;
      width: 100% !important;
      box-sizing: border-box !important;
      text-align: center !important;       /* centers text inside the tooltip textbox */
      margin: 2px 0 !important;
      padding: 0 !important;
      color: lime !important;
      font-weight: bold !important;
      font-size: 14px !important;
      line-height: 1.25 !important;
    }

    [data-turtletimer-slot-value="true"] {
      display: block !important;
      width: 100% !important;
      box-sizing: border-box !important;
      text-align: center !important;       /* centers text inside the tooltip textbox */
      margin: 2px 0 !important;
      padding: 0 !important;
      color: #FFD700 !important;
      font-weight: 600 !important;
      font-size: 13px !important;
      line-height: 1.25 !important;
    }
  `;
      const styleSheet = targetDocument.createElement('style');
      styleSheet.textContent = additionalStyles;
      targetDocument.head.appendChild(styleSheet);
  
  
  
  
      // ==================== AUTO-SAVE ====================
      // Auto-save data every 30 seconds using managed interval
      setManagedInterval('autoSave', () => {
          MGA_saveJSON('MGA_petPresets', UnifiedState.data.petPresets);
          // Only save ability logs if not in clear session
          const clearSession = localStorage.getItem('MGA_logs_clear_session');
          if (!clearSession || (Date.now() - parseInt(clearSession, 10)) > 86400000) {
              MGA_saveJSON('MGA_petAbilityLogs', UnifiedState.data.petAbilityLogs);
          }
          MGA_saveJSON('MGA_seedsToDelete', UnifiedState.data.seedsToDelete);
          MGA_saveJSON('MGA_autoDeleteEnabled', UnifiedState.data.autoDeleteEnabled);
  
          // Update resource tracking
          if (window.resourceDashboard) {
              window.resourceDashboard.updateResourceHistory();
          }
      }, 30000);
  
      // ==================== CLEANUP ====================
      window.addEventListener('beforeunload', () => {
          // Save all data before leaving - CRITICAL: Use immediate saves, not debounced!
          MGA_saveJSON('MGA_petPresets', UnifiedState.data.petPresets);
          // Only save ability logs if not in clear session
          const clearSession = localStorage.getItem('MGA_logs_clear_session');
          if (!clearSession || (Date.now() - parseInt(clearSession, 10)) > 86400000) {
              MGA_saveJSON('MGA_petAbilityLogs', UnifiedState.data.petAbilityLogs);
          }
          MGA_saveJSON('MGA_seedsToDelete', UnifiedState.data.seedsToDelete);
          MGA_saveJSON('MGA_autoDeleteEnabled', UnifiedState.data.autoDeleteEnabled);
  
          // Clean up all managed intervals
          clearAllManagedIntervals();
  
          // Close all popout windows
          closeAllPopoutWindows();
  
          debugLog('PERFORMANCE', 'Cleanup completed on window unload');
      });
  
      // ==================== VERSION INFO ====================
      productionLog(
          "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó\n" +
          "‚ïë   üå± Magic Garden Unified Assistant    ‚ïë\n" +
          "‚ïë            Version 1.3.2               ‚ïë\n" +
          "‚ïë                                        ‚ïë\n" +
          "‚ïë  üéÆ Works in ANY browser console!     ‚ïë\n" +
          "‚ïë  ‚Ä¢ Game Mode: Full integration        ‚ïë\n" +
          "‚ïë  ‚Ä¢ Demo Mode: Standalone with samples ‚ïë\n" +
          "‚ïë                                        ‚ïë\n" +
          "‚ïë  Features:                             ‚ïë\n" +
          "‚ïë  ‚Ä¢ Pet Loadout Management             ‚ïë\n" +
          "‚ïë  ‚Ä¢ Ability Log Tracking               ‚ïë\n" +
          "‚ïë  ‚Ä¢ Seed Deletion & Auto-Delete        ‚ïë\n" +
          "‚ïë  ‚Ä¢ Value Calculations                 ‚ïë\n" +
          "‚ïë  ‚Ä¢ Restock & Event Timers            ‚ïë\n" +
          "‚ïë  ‚Ä¢ Theme Customization                ‚ïë\n" +
          "‚ïë  ‚Ä¢ Pop-out Windows                    ‚ïë\n" +
          "‚ïë                                        ‚ïë\n" +
          "‚ïë  Controls:                            ‚ïë\n" +
          "‚ïë  ‚Ä¢ window.MGA - Full API              ‚ïë\n" +
          "‚ïë  ‚Ä¢ MGA.showPanel() - Show UI          ‚ïë\n" +
          "‚ïë  ‚Ä¢ MGA.init() - Manual start          ‚ïë\n" +
          "‚ïë  ‚Ä¢ Alt+M - Toggle apanel               ‚ïë\n" +
          "‚ïë                                        ‚ïë\n" +
          "‚ïë  Debugging (if issues occur):         ‚ïë\n" +
          "‚ïë  ‚Ä¢ MGA.debug.debugStorage() - Storage ‚ïë\n" +
          "‚ïë  ‚Ä¢ MGA_debugStorage() - Same as above ‚ïë\n" +
          "‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù"
      );
  
      // ==================== IMMEDIATE INITIALIZATION TEST ====================
      // Final safety initialization for testing - removed to prevent demo mode interference
      // Demo mode is only triggered by the 8-second fallback if game mode completely fails
      productionLog('üß™ Skipping 2-second fallback to prevent demo mode interference');
  
      // Final checkpoint - script execution complete
      /* CHECKPOINT removed: SCRIPT_EXECUTION_COMPLETE */
      productionLog('‚úÖ Magic Garden Assistant script finished loading');
  
  }
  })();
  
  
  /* ==== MGTP Overlay + Ability Logs Proxy + Rooms /info + WS Watcher (2025-10-07) ==== */
  (function(){
    'use strict';
    const d=document;
  
    // ---------- Slot/Estimate Overlay ----------
    const rootHost = d.createElement('div');
    rootHost.id = 'mgtp-overlay-root';
    rootHost.style.cssText = 'position:fixed;left:0;top:0;width:0;height:0;z-index:2147483646;pointer-events:none;';
    const shadow = rootHost.attachShadow({mode:'open'});
    const style = d.createElement('style');
    style.textContent = `
      .wrap{position:absolute;transform:translate(-50%,-100%); background:transparent; pointer-events:none; font-family: system-ui, sans-serif;}
      .line{display:block; white-space:nowrap; text-shadow:0 1px 1px rgba(0,0,0,.6); font-weight:700; text-align:center;}
      .estimate{font-size:13px; color:#70ff70;}
      .slot{font-size:14px; color:#ffd24d;}
      .hidden{display:none;}
    `;
    const wrap = d.createElement('div'); wrap.className='wrap hidden';
    const est = d.createElement('div'); est.className='line estimate';
    const slot = d.createElement('div'); slot.className='line slot';
    wrap.appendChild(est); wrap.appendChild(slot);
    shadow.appendChild(style); shadow.appendChild(wrap);
    d.documentElement.appendChild(rootHost);
  
    function placeAtRect(rect){
      wrap.style.left = (rect.left + rect.width/2) + 'px';
      wrap.style.top = (rect.top + 2) + 'px';
    }
    function visible(v){ wrap.classList.toggle('hidden', !v); }
  
    function bestAnchorFrom(el){
      try{
        if (el && el.getBoundingClientRect) return el.getBoundingClientRect();
      }catch{}
      // fallback: any visible tooltip-like container
      const cand = d.querySelectorAll('[role="tooltip"], [data-popper-placement], .chakra-tooltip, .chakra-tooltip__popper');
      let best=null, bestArea=-1;
      cand.forEach(e=>{
        const r=e.getBoundingClientRect();
        if (r.width>0&&r.height>0){
          // avoid pet panel/sidebar
          if (e.closest('[data-panel="pet-stats"], .pet-panel, [data-sidebar]')) return;
          const area = r.width*r.height;
          if (area>bestArea){ bestArea=area; best=r; }
        }
      });
      if (best) return best;
      // viewport fallback
      return {left: innerWidth/2-1, top: innerHeight/2-1, width:2, height:2};
    }
  
    window.MGTP_slotOverlay = {
      update({estimateText, slotValueText, anchorElement}={}){
        const hasEst = !!(estimateText && String(estimateText).trim());
        const hasSlot = !!(slotValueText && String(slotValueText).trim());
        est.textContent = hasEst ? String(estimateText) : '';
        slot.textContent = hasSlot ? String(slotValueText) : '';
        if (!hasEst && !hasSlot){ visible(false); return; }
        const r = bestAnchorFrom(anchorElement);
        placeAtRect(r);
        visible(true);
      },
      hide(){ visible(false); }
    };
  
    // ---------- Ability Logs: Sticky Clear + Proxy dedupe ----------
    const CLEAR_FLAG = 'MGA_logs_manually_cleared';
    function clearFlagIfNeededOnAdd(){
      if (localStorage.getItem(CLEAR_FLAG)==='true'){
        try{ localStorage.removeItem(CLEAR_FLAG);}catch{}
      }
    }
    function wrapLogsArray(arr){
      if (!Array.isArray(arr)) arr = [];
      const seen = new Set();
      const fp = (l)=> {
        const t=(l&&l.abilityType)||'', p=(l&&l.petName)||'';
        const ts= String((l&&l.timestamp)||0);
        let h=2166136261>>>0, s = (t+'|'+p+'|'+ts);
        for (let i=0;i<s.length;i++){ h^=s.charCodeAt(i); h=Math.imul(h,16777619); }
        return (h>>>0).toString(36);
      };
      const dedupePush = (item)=>{
        const id = item.id || fp(item);
        if (seen.has(id)) return 0;
        seen.add(id); arr.push({...item, id}); return 1;
      };
      // seed seen
      for (const it of arr){ seen.add(it.id||fp(it)); }
      return new Proxy(arr, {
        get(target, prop, recv){
          if (['push','unshift','splice','concat'].includes(prop)) {
            return function(...args){
              let added = 0;
              if (prop==='push' || prop==='unshift'){
                for (const it of args){ added += dedupePush(it); }
                if (added>0) clearFlagIfNeededOnAdd();
                return target.length;
              }
              if (prop==='splice'){
                // if items provided after start/deleteCount, dedupe them
                if (args.length>2){
                  const start=args[0]>>>0, del=args[1]>>>0, newItems=args.slice(2);
                  const before = target.slice(0,start);
                  const after = target.slice(start+del);
                  const rebuilt = wrapLogsArray(before);
                  for (const it of newItems){ dedupePush.call({arr:rebuilt}, it); }
                  for (const it of after){ dedupePush.call({arr:rebuilt}, it); }
                  while (target.length) target.pop();
                  for (const it of rebuilt) target.push(it);
                  clearFlagIfNeededOnAdd();
                  return [];
                }
              }
              return Array.prototype[prop].apply(target, args);
            };
          }
          return Reflect.get(target, prop, recv);
        },
        set(target, key, val){
          // direct index sets count as add
          if (!isNaN(key)){
            const added = dedupePush(val);
            if (added>0) clearFlagIfNeededOnAdd();
            return true;
          }
          return Reflect.set(target, key, val);
        }
      });
    }
  
    // Install proxy once UnifiedState is ready
    (function waitUnified(){
      const us = window.UnifiedState && UnifiedState.data;
      if (us){
        if (!us.petAbilityLogs || !us.petAbilityLogs.__proxied){
          us.petAbilityLogs = wrapLogsArray(us.petAbilityLogs||[]);
          Object.defineProperty(us.petAbilityLogs, '__proxied', {value:true});
        }
        // Intercept clear button globally to ensure sticky clear + full purge
        d.addEventListener('click', function(e){
          const tgt = e.target;
          if (tgt && tgt.id === 'clear-ability-logs'){
            e.preventDefault(); e.stopImmediatePropagation();
            try{
              us.petAbilityLogs.length = 0;
              if (typeof GM_setValue !== 'undefined'){ GM_setValue('MGA_petAbilityLogs', JSON.stringify([])); }
              localStorage.setItem('MGA_petAbilityLogs', JSON.stringify([]));
              localStorage.setItem(CLEAR_FLAG, 'true'); // keep sticky until next new log
              const archKeys = ['MGA_petAbilityLogs_archive'];
              archKeys.forEach(k=>{
                try{ if (typeof GM_setValue !== 'undefined') GM_setValue(k, JSON.stringify([])); }catch{}
                try{ localStorage.removeItem(k);}catch{}
              });
              if (window.updateAbilityLogDisplay){
                try{ window.updateAbilityLogDisplay(document);}catch{}
              }
            }catch(err){ console.error('[MGTP] clear logs failed', err); }
          }
        }, true);
        return;
      }
      setTimeout(waitUnified, 200);
    })();
  
  
    function rerenderRoomsUI(){
      try{
        // BUGFIX: Use getRoomStatusTabContent directly (not window.getRoomStatusTabContent) - same scope
        if (typeof getRoomStatusTabContent !== 'function') {
          return;
        }

        // Find any active rooms tab content areas (main or overlays)
        const candidates = document.querySelectorAll('[data-tab="rooms"], .mga-tab-content, .mga-overlay-content');
        let updated = false;

        candidates.forEach((c, idx) => {
          // Check if this element contains or is a rooms UI
          const list = c.querySelector('#room-status-list');
          const isRoomsTab = c.getAttribute && c.getAttribute('data-tab') === 'rooms';

          if (list || isRoomsTab) {
            const html = getRoomStatusTabContent();
            c.innerHTML = html;
            if (typeof setupRoomJoinButtons === 'function') {
              setupRoomJoinButtons();
            }
            updated = true;
          }
        });
      }catch(e){
        if (typeof logDebug === 'function') {
            logDebug('ROOMS-UI', '‚ùå Render error:', e);
        }
      }
    }
  
    // ---------- Rooms via /api/rooms/{code}/info with Fallbacks ----------
    (function roomsInfo(){
      // Get correct API base URL (handles Discord browser context)
      // Access the function from global scope (unsafeWindow or window)
      const globalScope = (typeof unsafeWindow !== 'undefined' ? unsafeWindow : window);
      const getApiBase = globalScope.getGameApiBaseUrl || (() => location.origin);
      const apiBase = getApiBase();
      const API_V1 = (name)=> `${apiBase}/api/rooms/${encodeURIComponent(name)}/info`;
      const API_V2 = (name)=> `${apiBase}/info?room=${encodeURIComponent(name)}`;
      const TRACKED = (window.UnifiedState?.data?.customRooms || window.TRACKED_ROOMS || ['MG1','MG2','MG3','MG4','MG5','MG6','MG7','MG8','MG9','MG10','SLAY']);
      let extra = new Set();
      const counts = {};

      // Log API base for debugging Discord browser issues
      productionLog(`üîó [ROOMS-API] Using API base: ${apiBase}`);
      if (apiBase !== location.origin) {
          productionLog(`üîó [ROOMS-API] Discord context detected - using magiccircle.gg APIs instead of ${location.origin}`);
      }

      // Parse player count from various API response formats
      function parsePlayerCount(data) {
        if (!data) return 0;

        // Try multiple field names
        const count = data?.numPlayers ??
                     data?.players?.online ??
                     data?.players?.count ??
                     data?.online ??
                     data?.count ??
                     data?.playerCount ??
                     0;

        return Math.max(0, Number(count) || 0);
      }

      // Fetch using standard fetch API
      async function fetchWithFetch(url, name) {
        const r = await fetch(url, {
          method: 'GET',
          credentials: 'include',
          headers: {'Accept':'application/json'},
          signal: AbortSignal.timeout(10000)
        });

        if (!r.ok) {
          throw new Error(`HTTP ${r.status}`);
        }

        const data = await r.json();
        return data;
      }

      // Fallback: Fetch using GM_xmlhttpRequest (bypasses CORS)
      async function fetchWithGM(url, name) {
        return new Promise((resolve, reject) => {
          if (typeof GM_xmlhttpRequest !== 'function') {
            reject(new Error('GM_xmlhttpRequest not available'));
            return;
          }

          GM_xmlhttpRequest({
            method: 'GET',
            url: url,
            headers: {'Accept': 'application/json'},
            timeout: 10000,
            onload: (response) => {
              if (response.status >= 200 && response.status < 300) {
                try {
                  const data = JSON.parse(response.responseText);
                  resolve(data);
                } catch (e) {
                  reject(new Error(`Parse error: ${e.message}`));
                }
              } else {
                reject(new Error(`HTTP ${response.status}`));
              }
            },
            onerror: (error) => reject(new Error('Network error')),
            ontimeout: () => reject(new Error('Timeout'))
          });
        });
      }

      async function fetchOne(name){
        try {
          let data = null;

          // Try API v1: /api/rooms/{code}/info
          try {
            const url1 = API_V1(name);
            data = await fetchWithFetch(url1, name);
          } catch (e1) {
            // Try API v2: /info?room={code}
            try {
              const url2 = API_V2(name);
              data = await fetchWithFetch(url2, name);
            } catch (e2) {
              // Try GM_xmlhttpRequest fallback
              try {
                const url1 = API_V1(name);
                data = await fetchWithGM(url1, name);
              } catch (e3) {
                throw new Error(`All methods failed`);
              }
            }
          }

          // Parse the count from whichever API succeeded
          const online = parsePlayerCount(data);
          counts[name.toUpperCase()] = online;
        } catch(e) {
          counts[name.toUpperCase()] = 0;
        }
      }

      async function tick(){
        const names = [...TRACKED, ...extra];
        await Promise.all(names.map(fetchOne));

        // write into UnifiedState so UI updates
        // BUGFIX: Use UnifiedState directly (not window.UnifiedState) since it's defined in same scope
        if (typeof UnifiedState !== 'undefined' && UnifiedState?.data){
          UnifiedState.data.roomStatus = UnifiedState.data.roomStatus || {};
          // CRITICAL: Directly replace counts to ensure fresh data
          UnifiedState.data.roomStatus.counts = {...counts};

          // refresh any open rooms views
          if (typeof window.refreshSeparateWindowPopouts === 'function'){
            try{ window.refreshSeparateWindowPopouts('rooms'); }catch{}
          }
          try{
            rerenderRoomsUI();
            // Force update room counts in any visible room UI
            document.querySelectorAll('.mga-tab-item[data-tab="rooms"]').forEach(tab => tab.click());
          }catch{}
          // Inline rooms lists
          const list = document.getElementById('room-status-list');
          if (list){
            // trigger the existing re-render path if available
            if (typeof window.updateRoomStatusUI === 'function'){ window.updateRoomStatusUI(); }
            else {
              // minimal DOM update: replace counts in .room-count els
              list.querySelectorAll('.room-row').forEach(row=>{
                const code = (row.getAttribute('data-room')||'').toUpperCase();
                const span = row.querySelector('.room-count');
                if (span && code){ span.textContent = String(counts[code] ?? UnifiedState.data.roomStatus.counts[code] ?? 0); }
              });
            }
          }
        }
      }
      // Watch the search input to include searched room
      const obs = new MutationObserver(()=>{
        const inp = document.getElementById('room-search-input');
        if (inp && !inp.__mgtpBound){
          inp.__mgtpBound = true;
          inp.addEventListener('input', ()=>{
            const q = (inp.value||'').trim().toUpperCase();
            extra = new Set(q ? q.split(',').map(s=>s.trim()).filter(Boolean) : []);
          });
        }
      });
      obs.observe(document.documentElement, {subtree:true, childList:true});

      // Start fetching
      setTimeout(tick, 1000); // First tick after 1 second
      setInterval(tick, 5000); // Then every 5 seconds
    })();
  
    // ==================== ENHANCED WEBSOCKET AUTO-RECONNECT SYSTEM ====================
    (function enhancedSocketReconnect() {
        const Native = window.WebSocket;
        if (!Native || Native.__mgtoolsPatched) return; // Prevent double-patching

        let attempts = 0;
        const MAX_ATTEMPTS = 6;
        let reconnectTimer = null;
        let userNotified = false;

        // Platform detection for context-aware reconnection
        const isDiscord = /discord|overlay|electron/i.test(navigator.userAgent) ||
                          !!(window.DiscordNative || window.__discordApp);
        const isIframe = window !== window.top;
        const isMobile = /Mobile|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);

        // ==================== DOCUMENT.HIDDEN OVERRIDE FOR COMPAT MODE ====================
        // The game checks document.hidden and refuses to reconnect when hidden
        // In compat mode (Discord/managed devices), we override this to always return false
        if (typeof CompatibilityMode !== 'undefined' && CompatibilityMode.flags.wsReconnectWhenHidden) {
            try {
                const originalDescriptor = Object.getOwnPropertyDescriptor(Document.prototype, 'hidden') ||
                                          Object.getOwnPropertyDescriptor(document, 'hidden');

                if (originalDescriptor && originalDescriptor.get) {
                    Object.defineProperty(document, 'hidden', {
                        get: function() {
                            // Always return false in compat mode to allow reconnection
                            return false;
                        },
                        configurable: true
                    });

                    logInfo('COMPAT-WS', 'Overrode document.hidden to enable reconnection in hidden state');
                }

                // Also patch visibilityState
                const originalVisibilityDescriptor = Object.getOwnPropertyDescriptor(Document.prototype, 'visibilityState') ||
                                                    Object.getOwnPropertyDescriptor(document, 'visibilityState');

                if (originalVisibilityDescriptor && originalVisibilityDescriptor.get) {
                    Object.defineProperty(document, 'visibilityState', {
                        get: function() {
                            // Always return 'visible' in compat mode
                            return 'visible';
                        },
                        configurable: true
                    });
                }
            } catch (e) {
                logWarn('COMPAT-WS', 'Failed to override document.hidden', e);
            }
        }

        // Add CSS animations
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideInRight {
                from { transform: translateX(400px); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOutRight {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(400px); opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        // User feedback: Visual toast notification
        function showReconnectToast(attemptNum, maxAttempts, nextWait) {
            let toast = document.getElementById('mga-reconnect-toast');

            const toastHTML = `
                <div style="display: flex; align-items: center; gap: 12px;">
                    <div style="font-size: 24px;">üîÑ</div>
                    <div>
                        <div style="font-weight: 600; margin-bottom: 4px;">Connection Lost</div>
                        <div style="font-size: 12px; opacity: 0.9;">
                            Reconnecting... (${attemptNum}/${maxAttempts})
                            <br>Next attempt in ${Math.round(nextWait/1000)}s
                        </div>
                    </div>
                </div>
            `;

            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'mga-reconnect-toast';
                toast.style.cssText = `
                    position: fixed; top: 20px; right: 20px; z-index: 2147483647;
                    background: linear-gradient(135deg, rgba(59, 130, 246, 0.95), rgba(37, 99, 235, 0.95));
                    color: white; padding: 16px 24px; border-radius: 12px;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                    font-size: 14px; font-weight: 500; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
                    animation: slideInRight 0.3s ease-out; max-width: 320px; pointer-events: auto;
                `;
                document.body.appendChild(toast);
            }

            toast.innerHTML = toastHTML;
            userNotified = true;

            setTimeout(() => {
                if (toast && toast.parentNode) {
                    toast.style.animation = 'slideOutRight 0.3s ease-out';
                    setTimeout(() => toast.remove(), 300);
                }
            }, 5000);
        }

        // Show max attempts failure with manual reload button
        function showFailureToast() {
            const failToast = document.createElement('div');
            failToast.id = 'mga-reconnect-fail-toast';
            failToast.style.cssText = `
                position: fixed; top: 20px; right: 20px; z-index: 2147483647;
                background: linear-gradient(135deg, rgba(220, 38, 38, 0.95), rgba(185, 28, 28, 0.95));
                color: white; padding: 16px 24px; border-radius: 12px;
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                font-size: 14px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3); max-width: 320px;
            `;

            failToast.innerHTML = `
                <div style="font-weight: 600; margin-bottom: 8px;">‚ö†Ô∏è Connection Failed</div>
                <div style="font-size: 12px; opacity: 0.9; margin-bottom: 12px;">
                    Unable to reconnect after ${MAX_ATTEMPTS} attempts
                </div>
                <button onclick="location.reload()" style="
                    background: white; color: #dc2626; border: none; padding: 8px 16px;
                    border-radius: 6px; cursor: pointer; font-weight: 600; width: 100%; font-size: 13px;
                ">Reload Page</button>
            `;

            document.body.appendChild(failToast);
        }

        // Schedule reconnect with exponential backoff
        function scheduleReload(code, wasClean, reason) {
            // Handle version expired (4710) immediately - auto-refresh with notification
            if (code === 4710 || /version.?expired/i.test(reason || '')) {
                if (typeof productionLog === 'function') {
                    productionLog('[WebSocket] Version expired detected (code 4710) - auto-refreshing in 5 seconds');
                }

                // Show friendly update notification with countdown
                let countdown = 5;
                const updateToast = document.createElement('div');
                updateToast.id = 'mga-update-toast';
                updateToast.style.cssText = `
                    position: fixed; top: 20px; right: 20px; z-index: 2147483647;
                    background: linear-gradient(135deg, rgba(16, 185, 129, 0.95), rgba(5, 150, 105, 0.95));
                    color: white; padding: 16px 24px; border-radius: 12px;
                    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
                    font-size: 14px; box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
                    animation: slideInRight 0.3s ease-out; max-width: 320px;
                `;

                updateToast.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <div style="font-size: 24px;">üéÆ</div>
                        <div>
                            <div style="font-weight: 600; margin-bottom: 4px;">Game Update Available</div>
                            <div style="font-size: 12px; opacity: 0.9;">
                                Refreshing in <span id="mga-countdown">${countdown}</span>s...
                            </div>
                        </div>
                    </div>
                `;

                document.body.appendChild(updateToast);

                // Update countdown every second
                const countdownInterval = setInterval(() => {
                    countdown--;
                    const countdownEl = document.getElementById('mga-countdown');
                    if (countdownEl) {
                        countdownEl.textContent = countdown;
                    }
                    if (countdown <= 0) {
                        clearInterval(countdownInterval);
                    }
                }, 1000);

                // Auto-refresh after 5 seconds
                setTimeout(() => {
                    if (typeof productionLog === 'function') {
                        productionLog('[WebSocket] Auto-refreshing for game update...');
                    }
                    window.location.reload();
                }, 5000);

                return;
            }

            // Only reconnect for 1006 (abnormal) or if reason mentions update
            if (wasClean && code !== 1006 && !/update/i.test(reason || '')) {
                if (typeof productionLog === 'function') {
                    productionLog('[WebSocket] Clean close detected - no reconnect needed');
                }
                return;
            }

            // Clear any existing timer
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }

            // Check if max attempts exceeded
            if (attempts >= MAX_ATTEMPTS) {
                if (typeof productionWarn === 'function') {
                    productionWarn(`[WebSocket] Max reconnect attempts (${MAX_ATTEMPTS}) reached - manual refresh required`);
                }
                showFailureToast();
                return;
            }

            // Exponential backoff: 1s, 2s, 4s, 8s, 15s, 15s
            const wait = Math.min(1000 * Math.pow(2, attempts), 15000);
            attempts++;

            if (typeof productionLog === 'function') {
                productionLog(`[WebSocket] Reconnect attempt ${attempts}/${MAX_ATTEMPTS} in ${wait}ms (code: ${code}, reason: "${reason || 'none'}")`);
            }

            // Show user feedback
            showReconnectToast(attempts, MAX_ATTEMPTS, wait);

            reconnectTimer = setTimeout(() => {
                try {
                    // Add timestamp to force reload and bypass cache
                    const u = new URL(location.href);
                    u.searchParams.set('_mgtp', Date.now().toString());

                    // Platform-specific reload strategy
                    if (isDiscord && isIframe) {
                        // Discord iframe: try parent reload first
                        try {
                            window.parent.location.reload();
                        } catch (e) {
                            // Fallback to self reload if parent is inaccessible
                            location.replace(u.toString());
                        }
                    } else if (isMobile) {
                        // Mobile: hard reload to clear any cached state
                        location.href = u.toString();
                    } else {
                        // Desktop: use replace to avoid back button issues
                        location.replace(u.toString());
                    }
                } catch (e) {
                    if (typeof productionError === 'function') {
                        productionError('[WebSocket] Reload failed:', e);
                    }
                    // Last resort: simple reload
                    location.href = location.href + '?_t=' + Date.now();
                }
            }, wait);
        }

        // Patch WebSocket constructor
        window.WebSocket = function(url, protocols) {
            const ws = new Native(url, protocols);

            // Reset attempts on successful connection
            ws.addEventListener('open', () => {
                if (typeof productionLog === 'function') {
                    productionLog('[WebSocket] Connection established successfully');
                }
                attempts = 0;
                userNotified = false;

                // Remove any reconnect toasts
                const toast = document.getElementById('mga-reconnect-toast');
                if (toast) toast.remove();
            });

            // Handle close events
            ws.addEventListener('close', (e) => {
                if (typeof productionLog === 'function') {
                    productionLog(`[WebSocket] Closed - Code: ${e.code}, Clean: ${e.wasClean}, Reason: "${e.reason || 'none'}"`);
                }
                scheduleReload(e.code, e.wasClean, e.reason);
            });

            // Handle errors
            ws.addEventListener('error', (e) => {
                if (typeof productionError === 'function') {
                    productionError('[WebSocket] Error detected:', e);
                }
            });

            return ws;
        };

        // Preserve prototype and static properties
        Object.setPrototypeOf(window.WebSocket, Native);
        window.WebSocket.prototype = Native.prototype;
        window.WebSocket.__mgtoolsPatched = true;

        // Network state listeners for smarter reconnection
        window.addEventListener('online', () => {
            if (typeof productionLog === 'function') {
                productionLog('[Network] Back online - reducing reconnect attempt counter');
            }
            attempts = Math.max(0, attempts - 2); // Give extra chances when network returns

            // If we have a toast, update it
            const toast = document.getElementById('mga-reconnect-toast');
            if (toast) toast.remove();
        });

        window.addEventListener('offline', () => {
            if (typeof productionWarn === 'function') {
                productionWarn('[Network] Offline detected - pausing reconnection attempts');
            }
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }

            // Update toast if visible
            const toast = document.getElementById('mga-reconnect-toast');
            if (toast) {
                toast.innerHTML = `
                    <div style="display: flex; align-items: center; gap: 12px;">
                        <div style="font-size: 24px;">üì°</div>
                        <div>
                            <div style="font-weight: 600; margin-bottom: 4px;">Network Offline</div>
                            <div style="font-size: 12px; opacity: 0.9;">
                                Reconnection paused<br>Waiting for network...
                            </div>
                        </div>
                    </div>
                `;
            }
        });

        if (typeof productionLog === 'function') {
            productionLog('‚úÖ [WebSocket] Enhanced auto-reconnect system initialized (max attempts: ' + MAX_ATTEMPTS + ')');
        }
    })();

    // DOM update popup monitor disabled - WebSocket code 4710 detection is reliable enough
    // The DOM monitor was causing false positives by matching MGTools' own UI elements

  })();


/* MGTOOLS_MERGE_BLOCK_v1 */

/* 1) Ability Logs: ghost-free hard clear with tombstone and writers lifting the flag */
(function(){
  const LOG_MAIN = 'MGA_petAbilityLogs';
  const LOG_ARCH = 'MGA_petAbilityLogs_archive';
  const FLAG = 'MGA_logs_manually_cleared';

  function gmGet(k, d=null){ try{ const raw = typeof GM_getValue==='function'?GM_getValue(k, null):null; if(raw==null) return d; return typeof raw==='string'?JSON.parse(raw):raw; }catch{return d;} }
  function gmSet(k, v){ try{ if(typeof GM_setValue==='function') GM_setValue(k, JSON.stringify(v)); }catch{} }

  // Enforce tombstone on read paths (localStorage + GM)
  try{
    const _get = Storage.prototype.getItem;
    if(!_get.__mgtoolsPatched){
      Storage.prototype.getItem = function(k){
        if ((k===LOG_MAIN || k===LOG_ARCH) && localStorage.getItem(FLAG)==='true') return '[]';
        return _get.apply(this, arguments);
      };
      Storage.prototype.getItem.__mgtoolsPatched = true;
    }
  }catch{}

  try{
    if (typeof GM_getValue==='function' && !GM_getValue.__mgtoolsPatched){
      const _gm = GM_getValue;
      window.GM_getValue = function(k, d){
        if ((k===LOG_MAIN || k===LOG_ARCH) && localStorage.getItem(FLAG)==='true') return '[]';
        return _gm.apply(this, arguments);
      };
      window.GM_getValue.__mgtoolsPatched = true;
    }
  }catch{}

  try{
    if (typeof GM_setValue==='function' && !GM_setValue.__mgtoolsPatched){
      const _gm = GM_setValue;
      window.GM_setValue = function(k, v){
        if (k===LOG_MAIN){
          try{
            const arr = Array.isArray(v)?v:(typeof v==='string'?JSON.parse(v):[]);
            if (arr && arr.length) localStorage.removeItem(FLAG);
          }catch{}
        }
        return _gm.apply(this, arguments);
      };
      window.GM_setValue.__mgtoolsPatched = true;
    }
  }catch{}

  function hardClear(){
    try{
      localStorage.setItem(FLAG, 'true');
      gmSet(LOG_MAIN, []);
      gmSet(LOG_ARCH, []);
      try{ localStorage.removeItem(LOG_MAIN); localStorage.removeItem(LOG_ARCH); }catch{}
      if (window.UnifiedState?.data) window.UnifiedState.data.petAbilityLogs = [];
      if (Array.isArray(window.petAbilityLogs)) window.petAbilityLogs.length = 0;
    }catch(e){ console.error('[MGTools] hardClear logs failed', e); }
  }
  window.MGTOOLS_hardClearAbilityLogs = hardClear;

  document.addEventListener('click', (ev)=>{
    const t = ev.target && ev.target.closest('#clear-ability-logs,[data-role="clear-ability-logs"],[data-action="clear-ability-logs"],[data-mga-clear-logs],#mga-clear-logs');
    if (t){ hardClear(); }
  }, true);

  // Startup sanitizer (short burst to defeat late rehydrations)
  let n=0; const iv=setInterval(()=>{
    if (localStorage.getItem(FLAG)==='true'){
      try{ localStorage.setItem(LOG_MAIN,'[]'); localStorage.setItem(LOG_ARCH,'[]'); }catch{}
      if (window.UnifiedState?.data) window.UnifiedState.data.petAbilityLogs = [];
    }
    if (++n>80) clearInterval(iv);
  }, 200);
})();


/* WebSocket reconnect handled by enhanced implementation above (lines 22603+) */
